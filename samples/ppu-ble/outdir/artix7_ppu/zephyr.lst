
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

50000000 <vinit>:
50000000:	00000013          	nop
50000004:	00000013          	nop
50000008:	00000013          	nop
5000000c:	00000013          	nop
50000010:	00000013          	nop
50000014:	00000013          	nop
50000018:	00000013          	nop
5000001c:	00000013          	nop
50000020:	00000013          	nop
50000024:	00000013          	nop
50000028:	00000013          	nop
5000002c:	00000013          	nop
50000030:	00000013          	nop
50000034:	00000013          	nop
50000038:	00000013          	nop
5000003c:	0580006f          	j	50000094 <__irq_wrapper>
50000040:	0540006f          	j	50000094 <__irq_wrapper>
50000044:	0500006f          	j	50000094 <__irq_wrapper>
50000048:	04c0006f          	j	50000094 <__irq_wrapper>
5000004c:	0480006f          	j	50000094 <__irq_wrapper>
50000050:	0440006f          	j	50000094 <__irq_wrapper>
50000054:	0400006f          	j	50000094 <__irq_wrapper>
50000058:	03c0006f          	j	50000094 <__irq_wrapper>
5000005c:	0380006f          	j	50000094 <__irq_wrapper>
50000060:	0340006f          	j	50000094 <__irq_wrapper>
50000064:	0300006f          	j	50000094 <__irq_wrapper>
50000068:	02c0006f          	j	50000094 <__irq_wrapper>
5000006c:	0280006f          	j	50000094 <__irq_wrapper>
50000070:	0240006f          	j	50000094 <__irq_wrapper>
50000074:	0200006f          	j	50000094 <__irq_wrapper>
50000078:	01c0006f          	j	50000094 <__irq_wrapper>
5000007c:	0180006f          	j	50000094 <__irq_wrapper>
50000080:	0100006f          	j	50000090 <__reset>
50000084:	0100006f          	j	50000094 <__irq_wrapper>
50000088:	00c0006f          	j	50000094 <__irq_wrapper>
5000008c:	0080006f          	j	50000094 <__irq_wrapper>

Disassembly of section reset:

50000090 <__reset>:
50000090:	33c050ef          	jal	500053cc <__start>

Disassembly of section exceptions:

50000094 <__irq_wrapper>:
50000094:	f9010113          	addi	sp,sp,-112
50000098:	00112023          	sw	ra,0(sp)
5000009c:	00312223          	sw	gp,4(sp)
500000a0:	00412423          	sw	tp,8(sp)
500000a4:	00512623          	sw	t0,12(sp)
500000a8:	00612823          	sw	t1,16(sp)
500000ac:	00712a23          	sw	t2,20(sp)
500000b0:	01c12c23          	sw	t3,24(sp)
500000b4:	01d12e23          	sw	t4,28(sp)
500000b8:	03e12023          	sw	t5,32(sp)
500000bc:	03f12223          	sw	t6,36(sp)
500000c0:	02a12423          	sw	a0,40(sp)
500000c4:	02b12623          	sw	a1,44(sp)
500000c8:	02c12823          	sw	a2,48(sp)
500000cc:	02d12a23          	sw	a3,52(sp)
500000d0:	02e12c23          	sw	a4,56(sp)
500000d4:	02f12e23          	sw	a5,60(sp)
500000d8:	05012023          	sw	a6,64(sp)
500000dc:	05112223          	sw	a7,68(sp)
500000e0:	341022f3          	csrr	t0,mepc
500000e4:	04512423          	sw	t0,72(sp)
500000e8:	7c0022f3          	csrr	t0,0x7c0
500000ec:	04512623          	sw	t0,76(sp)
500000f0:	1c8000ef          	jal	500002b8 <__soc_save_context>
500000f4:	250000ef          	jal	50000344 <__soc_is_irq>
500000f8:	00000313          	li	t1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500000fc:	02051a63          	bnez	a0,50000130 <is_interrupt>
50000100:	04812283          	lw	t0,72(sp)
50000104:	00428293          	addi	t0,t0,4
50000108:	04512423          	sw	t0,72(sp)
5000010c:	342022f3          	csrr	t0,mcause
50000110:	01f00393          	li	t2,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
50000114:	0072f2b3          	and	t0,t0,t2
50000118:	00b00313          	li	t1,11 # b <___thread_base_t_sched_locked_OFFSET>
5000011c:	0a628463          	beq	t0,t1,500001c4 <reschedule>
50000120:	00010513          	mv	a0,sp
50000124:	00000097          	auipc	ra,0x0
50000128:	13008093          	addi	ra,ra,304 # 50000254 <no_reschedule>
5000012c:	4540506f          	j	50005580 <_Fault>

50000130 <is_interrupt>:
50000130:	00010293          	mv	t0,sp
50000134:	01002397          	auipc	t2,0x1002
50000138:	18c38393          	addi	t2,t2,396 # 510022c0 <_kernel>
5000013c:	0043a103          	lw	sp,4(t2)
50000140:	ff010113          	addi	sp,sp,-16
50000144:	00512023          	sw	t0,0(sp)

50000148 <on_irq_stack>:
50000148:	0003ae03          	lw	t3,0(t2)
5000014c:	001e0e13          	addi	t3,t3,1
50000150:	01c3a023          	sw	t3,0(t2)
50000154:	00030863          	beqz	t1,50000164 <call_irq>
50000158:	00000097          	auipc	ra,0x0
5000015c:	03808093          	addi	ra,ra,56 # 50000190 <on_thread_stack>
50000160:	5680506f          	j	500056c8 <_irq_do_offload>

50000164 <call_irq>:
50000164:	34202573          	csrr	a0,mcause
50000168:	01f00293          	li	t0,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
5000016c:	00557533          	and	a0,a0,t0
50000170:	1b0000ef          	jal	50000320 <__soc_handle_irq>
50000174:	01000297          	auipc	t0,0x1000
50000178:	ee028293          	addi	t0,t0,-288 # 51000054 <__devconfig_end>
5000017c:	00351513          	slli	a0,a0,0x3
50000180:	00a282b3          	add	t0,t0,a0
50000184:	0002a503          	lw	a0,0(t0)
50000188:	0042a303          	lw	t1,4(t0)
5000018c:	000300e7          	jalr	t1

50000190 <on_thread_stack>:
50000190:	01002317          	auipc	t1,0x1002
50000194:	13030313          	addi	t1,t1,304 # 510022c0 <_kernel>
50000198:	00032383          	lw	t2,0(t1)
5000019c:	fff38393          	addi	t2,t2,-1
500001a0:	00732023          	sw	t2,0(t1)
500001a4:	00012283          	lw	t0,0(sp)
500001a8:	00028113          	mv	sp,t0
500001ac:	00832383          	lw	t2,8(t1)
500001b0:	00a3de03          	lhu	t3,10(t2)
500001b4:	08000e93          	li	t4,128 # 80 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN>
500001b8:	09de7e63          	bleu	t4,t3,50000254 <no_reschedule>
500001bc:	01432e03          	lw	t3,20(t1)
500001c0:	087e0a63          	beq	t3,t2,50000254 <no_reschedule>

500001c4 <reschedule>:
500001c4:	534060ef          	jal	500066f8 <_update_time_slice_before_swap>
500001c8:	01002297          	auipc	t0,0x1002
500001cc:	0f828293          	addi	t0,t0,248 # 510022c0 <_kernel>
500001d0:	0082a303          	lw	t1,8(t0)
500001d4:	02832623          	sw	s0,44(t1)
500001d8:	02932823          	sw	s1,48(t1)
500001dc:	03232a23          	sw	s2,52(t1)
500001e0:	03332c23          	sw	s3,56(t1)
500001e4:	03432e23          	sw	s4,60(t1)
500001e8:	05532023          	sw	s5,64(t1)
500001ec:	05632223          	sw	s6,68(t1)
500001f0:	05732423          	sw	s7,72(t1)
500001f4:	05832623          	sw	s8,76(t1)
500001f8:	05932823          	sw	s9,80(t1)
500001fc:	05a32a23          	sw	s10,84(t1)
50000200:	05b32c23          	sw	s11,88(t1)
50000204:	02232423          	sw	sp,40(t1)
50000208:	01002397          	auipc	t2,0x1002
5000020c:	ae438393          	addi	t2,t2,-1308 # 51001cec <_k_neg_eagain>
50000210:	0003ae03          	lw	t3,0(t2)
50000214:	07c32423          	sw	t3,104(t1)
50000218:	0142a303          	lw	t1,20(t0)
5000021c:	0062a423          	sw	t1,8(t0)
50000220:	02832103          	lw	sp,40(t1)
50000224:	02c32403          	lw	s0,44(t1)
50000228:	03032483          	lw	s1,48(t1)
5000022c:	03432903          	lw	s2,52(t1)
50000230:	03832983          	lw	s3,56(t1)
50000234:	03c32a03          	lw	s4,60(t1)
50000238:	04032a83          	lw	s5,64(t1)
5000023c:	04432b03          	lw	s6,68(t1)
50000240:	04832b83          	lw	s7,72(t1)
50000244:	04c32c03          	lw	s8,76(t1)
50000248:	05032c83          	lw	s9,80(t1)
5000024c:	05432d03          	lw	s10,84(t1)
50000250:	05832d83          	lw	s11,88(t1)

50000254 <no_reschedule>:
50000254:	098000ef          	jal	500002ec <__soc_restore_context>
50000258:	04812283          	lw	t0,72(sp)
5000025c:	34129073          	csrw	mepc,t0
50000260:	04c12283          	lw	t0,76(sp)
50000264:	7c029073          	csrw	0x7c0,t0
50000268:	00012083          	lw	ra,0(sp)
5000026c:	00412183          	lw	gp,4(sp)
50000270:	00812203          	lw	tp,8(sp)
50000274:	00c12283          	lw	t0,12(sp)
50000278:	01012303          	lw	t1,16(sp)
5000027c:	01412383          	lw	t2,20(sp)
50000280:	01812e03          	lw	t3,24(sp)
50000284:	01c12e83          	lw	t4,28(sp)
50000288:	02012f03          	lw	t5,32(sp)
5000028c:	02412f83          	lw	t6,36(sp)
50000290:	02812503          	lw	a0,40(sp)
50000294:	02c12583          	lw	a1,44(sp)
50000298:	03012603          	lw	a2,48(sp)
5000029c:	03412683          	lw	a3,52(sp)
500002a0:	03812703          	lw	a4,56(sp)
500002a4:	03c12783          	lw	a5,60(sp)
500002a8:	04012803          	lw	a6,64(sp)
500002ac:	04412883          	lw	a7,68(sp)
500002b0:	07010113          	addi	sp,sp,112
500002b4:	10000073          	eret

500002b8 <__soc_save_context>:
500002b8:	7b0022f3          	csrr	t0,0x7b0
500002bc:	7b102373          	csrr	t1,0x7b1
500002c0:	7b2023f3          	csrr	t2,0x7b2
500002c4:	04512823          	sw	t0,80(sp)
500002c8:	04612a23          	sw	t1,84(sp)
500002cc:	04712c23          	sw	t2,88(sp)
500002d0:	7b4022f3          	csrr	t0,0x7b4
500002d4:	7b502373          	csrr	t1,0x7b5
500002d8:	7b6023f3          	csrr	t2,0x7b6
500002dc:	04512e23          	sw	t0,92(sp)
500002e0:	06612023          	sw	t1,96(sp)
500002e4:	06712223          	sw	t2,100(sp)
500002e8:	00008067          	ret

500002ec <__soc_restore_context>:
500002ec:	05012283          	lw	t0,80(sp)
500002f0:	05412303          	lw	t1,84(sp)
500002f4:	05812383          	lw	t2,88(sp)
500002f8:	7b029073          	csrw	0x7b0,t0
500002fc:	7b131073          	csrw	0x7b1,t1
50000300:	7b239073          	csrw	0x7b2,t2
50000304:	05c12283          	lw	t0,92(sp)
50000308:	06012303          	lw	t1,96(sp)
5000030c:	06412383          	lw	t2,100(sp)
50000310:	7b429073          	csrw	0x7b4,t0
50000314:	7b531073          	csrw	0x7b5,t1
50000318:	7b639073          	csrw	0x7b6,t2
5000031c:	00008067          	ret

50000320 <__soc_handle_irq>:
50000320:	1a104337          	lui	t1,0x1a104
50000324:	00c30313          	addi	t1,t1,12 # 1a10400c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f8c>
50000328:	00100393          	li	t2,1 # 1 <CONFIG_ARCH>
5000032c:	00a39e33          	sll	t3,t2,a0
50000330:	01c32023          	sw	t3,0(t1)
50000334:	1a104337          	lui	t1,0x1a104
50000338:	01c30313          	addi	t1,t1,28 # 1a10401c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f9c>
5000033c:	01c32023          	sw	t3,0(t1)
50000340:	00008067          	ret

50000344 <__soc_is_irq>:
50000344:	342022f3          	csrr	t0,mcause
50000348:	01f2f293          	andi	t0,t0,31
5000034c:	00f00313          	li	t1,15 # f <CONFIG_NUM_PREEMPT_PRIORITIES>
50000350:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000354:	0062c463          	blt	t0,t1,5000035c <not_interrupt>
50000358:	00150513          	addi	a0,a0,1

5000035c <not_interrupt>:
5000035c:	00008067          	ret

50000360 <__swap>:
50000360:	00000073          	ecall
50000364:	01002297          	auipc	t0,0x1002
50000368:	f5c28293          	addi	t0,t0,-164 # 510022c0 <_kernel>
5000036c:	0082a303          	lw	t1,8(t0)
50000370:	06832383          	lw	t2,104(t1)
50000374:	00157513          	andi	a0,a0,1
50000378:	300522f3          	csrrs	t0,mstatus,a0
5000037c:	00038513          	mv	a0,t2
50000380:	00008067          	ret

Disassembly of section text:

50000384 <main>:
#include <misc/printk.h>

#include <bluetooth/bluetooth.h>

void main(void)
{
50000384:	ff010113          	addi	sp,sp,-16
	int err;

	err = bt_enable(NULL);
50000388:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
#include <misc/printk.h>

#include <bluetooth/bluetooth.h>

void main(void)
{
5000038c:	00112623          	sw	ra,12(sp)
	int err;

	err = bt_enable(NULL);
50000390:	7c0040ef          	jal	50004b50 <bt_enable>
	if (err) {
50000394:	00050e63          	beqz	a0,500003b0 <main+0x2c>
50000398:	00050593          	mv	a1,a0
		printk("Bluetooth init failed (err %d)\n", err);
5000039c:	51000537          	lui	a0,0x51000
		return;
	}

	printk("Bluetooth initialized\n");
}
500003a0:	00c12083          	lw	ra,12(sp)
{
	int err;

	err = bt_enable(NULL);
	if (err) {
		printk("Bluetooth init failed (err %d)\n", err);
500003a4:	17c50513          	addi	a0,a0,380 # 5100017c <__devconfig_end+0x128>
		return;
	}

	printk("Bluetooth initialized\n");
}
500003a8:	01010113          	addi	sp,sp,16
{
	int err;

	err = bt_enable(NULL);
	if (err) {
		printk("Bluetooth init failed (err %d)\n", err);
500003ac:	3790106f          	j	50001f24 <printk>
		return;
	}

	printk("Bluetooth initialized\n");
500003b0:	51000537          	lui	a0,0x51000
}
500003b4:	00c12083          	lw	ra,12(sp)
	if (err) {
		printk("Bluetooth init failed (err %d)\n", err);
		return;
	}

	printk("Bluetooth initialized\n");
500003b8:	19c50513          	addi	a0,a0,412 # 5100019c <__devconfig_end+0x148>
}
500003bc:	01010113          	addi	sp,sp,16
	if (err) {
		printk("Bluetooth init failed (err %d)\n", err);
		return;
	}

	printk("Bluetooth initialized\n");
500003c0:	3650106f          	j	50001f24 <printk>

500003c4 <strcpy>:
			n--;
		}
	}

	return d;
}
500003c4:	00050793          	mv	a5,a0
500003c8:	0015c70b          	p.lbu	a4,1(a1!)
500003cc:	00070663          	beqz	a4,500003d8 <strcpy+0x14>
500003d0:	00e780ab          	p.sb	a4,1(a5!)
500003d4:	ff5ff06f          	j	500003c8 <strcpy+0x4>
500003d8:	00078023          	sb	zero,0(a5)
500003dc:	00008067          	ret

500003e0 <strcmp>:
500003e0:	0015478b          	p.lbu	a5,1(a0!)
500003e4:	0015c70b          	p.lbu	a4,1(a1!)
500003e8:	00e79663          	bne	a5,a4,500003f4 <strcmp+0x14>
500003ec:	fe079ae3          	bnez	a5,500003e0 <strcmp>
500003f0:	00078713          	mv	a4,a5
500003f4:	40e78533          	sub	a0,a5,a4
500003f8:	00008067          	ret

500003fc <memcmp>:
500003fc:	02060e63          	beqz	a2,50000438 <memcmp+0x3c>
50000400:	00058713          	mv	a4,a1
50000404:	00050793          	mv	a5,a0
50000408:	fff60613          	addi	a2,a2,-1
5000040c:	00061a63          	bnez	a2,50000420 <memcmp+0x24>
50000410:	0007c783          	lbu	a5,0(a5)
50000414:	00074503          	lbu	a0,0(a4)
50000418:	40a78533          	sub	a0,a5,a0
5000041c:	00008067          	ret
50000420:	0007c803          	lbu	a6,0(a5)
50000424:	00074683          	lbu	a3,0(a4)
50000428:	00150513          	addi	a0,a0,1
5000042c:	00158593          	addi	a1,a1,1
50000430:	fcd808e3          	beq	a6,a3,50000400 <memcmp+0x4>
50000434:	fddff06f          	j	50000410 <memcmp+0x14>
50000438:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000043c:	00008067          	ret

50000440 <memcpy>:
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
50000440:	00a5c7b3          	xor	a5,a1,a0
50000444:	fa27b7b3          	p.bclr	a5,a5,29,2
50000448:	00078863          	beqz	a5,50000458 <memcpy+0x18>

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
5000044c:	00050793          	mv	a5,a0
50000450:	00160613          	addi	a2,a2,1
50000454:	0780006f          	j	500004cc <memcpy+0x8c>
50000458:	00050713          	mv	a4,a0
5000045c:	00160693          	addi	a3,a2,1

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
50000460:	fa273833          	p.bclr	a6,a4,29,2
50000464:	00070793          	mv	a5,a4
50000468:	02080063          	beqz	a6,50000488 <memcpy+0x48>
5000046c:	fff68693          	addi	a3,a3,-1
50000470:	00069463          	bnez	a3,50000478 <memcpy+0x38>
50000474:	00008067          	ret
			if (n == 0) {
				return d;
			}
			*(d_byte++) = *(s_byte++);
50000478:	0015878b          	p.lb	a5,1(a1!)
			n--;
5000047c:	fff60613          	addi	a2,a2,-1

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
				return d;
			}
			*(d_byte++) = *(s_byte++);
50000480:	00f700ab          	p.sb	a5,1(a4!)
50000484:	fddff06f          	j	50000460 <memcpy+0x20>
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
50000488:	00265693          	srli	a3,a2,0x2

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
5000048c:	00058813          	mv	a6,a1
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
50000490:	00168693          	addi	a3,a3,1
50000494:	fff68693          	addi	a3,a3,-1
50000498:	02069063          	bnez	a3,500004b8 <memcpy+0x78>
5000049c:	00265713          	srli	a4,a2,0x2
500004a0:	ffc00693          	li	a3,-4 # fffffffc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffd>
500004a4:	42d70633          	p.mac	a2,a4,a3
500004a8:	00271713          	slli	a4,a4,0x2
500004ac:	00e787b3          	add	a5,a5,a4
500004b0:	00e585b3          	add	a1,a1,a4
500004b4:	f9dff06f          	j	50000450 <memcpy+0x10>
			*(d_word++) = *(s_word++);
500004b8:	0048288b          	p.lw	a7,4(a6!)
500004bc:	0117222b          	p.sw	a7,4(a4!)
500004c0:	fd5ff06f          	j	50000494 <memcpy+0x54>
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
500004c4:	0015870b          	p.lb	a4,1(a1!)
500004c8:	00e780ab          	p.sb	a4,1(a5!)
500004cc:	fff60613          	addi	a2,a2,-1
500004d0:	fe061ae3          	bnez	a2,500004c4 <memcpy+0x84>
		n--;
	}

	return d;
}
500004d4:	00008067          	ret

500004d8 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
500004d8:	0ff5f693          	andi	a3,a1,255

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
500004dc:	00050793          	mv	a5,a0
500004e0:	00160713          	addi	a4,a2,1
	unsigned char c_byte = (unsigned char)c;

	while (((unsigned int)d_byte) & 0x3) {
500004e4:	fa27b833          	p.bclr	a6,a5,29,2
500004e8:	00080e63          	beqz	a6,50000504 <memset+0x2c>
500004ec:	fff70713          	addi	a4,a4,-1
500004f0:	00071463          	bnez	a4,500004f8 <memset+0x20>
500004f4:	00008067          	ret
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
500004f8:	00d780ab          	p.sb	a3,1(a5!)
		n--;
500004fc:	fff60613          	addi	a2,a2,-1
50000500:	fe5ff06f          	j	500004e4 <memset+0xc>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
50000504:	ee85b5b3          	p.bclr	a1,a1,23,8

	c_word |= c_word << 8;
50000508:	00859713          	slli	a4,a1,0x8
5000050c:	00e5e5b3          	or	a1,a1,a4
	c_word |= c_word << 16;
50000510:	01059713          	slli	a4,a1,0x10
50000514:	00e5e5b3          	or	a1,a1,a4

	while (n >= sizeof(unsigned int)) {
50000518:	00265713          	srli	a4,a2,0x2
5000051c:	00078813          	mv	a6,a5
50000520:	00170713          	addi	a4,a4,1
50000524:	fff70713          	addi	a4,a4,-1
50000528:	02071063          	bnez	a4,50000548 <memset+0x70>
5000052c:	00265713          	srli	a4,a2,0x2
50000530:	00271593          	slli	a1,a4,0x2
50000534:	00b787b3          	add	a5,a5,a1
50000538:	ffc00593          	li	a1,-4 # fffffffc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffd>
5000053c:	42b70633          	p.mac	a2,a4,a1
50000540:	00160613          	addi	a2,a2,1
50000544:	0100006f          	j	50000554 <memset+0x7c>
		*(d_word++) = c_word;
50000548:	00b8222b          	p.sw	a1,4(a6!)
5000054c:	fd9ff06f          	j	50000524 <memset+0x4c>
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
		*(d_byte++) = c_byte;
50000550:	00d780ab          	p.sb	a3,1(a5!)
50000554:	fff60613          	addi	a2,a2,-1
50000558:	fe061ce3          	bnez	a2,50000550 <memset+0x78>
		n--;
	}

	return buf;
}
5000055c:	00008067          	ret

50000560 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
50000560:	ff010113          	addi	sp,sp,-16
50000564:	00812423          	sw	s0,8(sp)
50000568:	51002437          	lui	s0,0x51002
5000056c:	00912223          	sw	s1,4(sp)
50000570:	00112623          	sw	ra,12(sp)
50000574:	00050493          	mv	s1,a0
50000578:	d0040413          	addi	s0,s0,-768 # 51001d00 <__bss_start>
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
5000057c:	00a53c63          	p.bneimm	a0,10,50000594 <console_out+0x34>
		uart_poll_out(uart_console_dev, '\r');
50000580:	00042503          	lw	a0,0(s0)
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
50000584:	00d00593          	li	a1,13 # d <_DEVICE_STRUCT_SIZE+0x1>
50000588:	00452783          	lw	a5,4(a0)
5000058c:	0047a783          	lw	a5,4(a5)
50000590:	000780e7          	jalr	a5
	}
	uart_poll_out(uart_console_dev, c);
50000594:	00042503          	lw	a0,0(s0)
50000598:	0ff4f593          	andi	a1,s1,255
5000059c:	00452783          	lw	a5,4(a0)
500005a0:	0047a783          	lw	a5,4(a5)
500005a4:	000780e7          	jalr	a5

	return c;
}
500005a8:	00c12083          	lw	ra,12(sp)
500005ac:	00048513          	mv	a0,s1
500005b0:	00812403          	lw	s0,8(sp)
500005b4:	00412483          	lw	s1,4(sp)
500005b8:	01010113          	addi	sp,sp,16
500005bc:	00008067          	ret

500005c0 <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
500005c0:	50000537          	lui	a0,0x50000
500005c4:	56050513          	addi	a0,a0,1376 # 50000560 <console_out>
500005c8:	58c0106f          	j	50001b54 <__printk_hook_install>

500005cc <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500005cc:	51000537          	lui	a0,0x51000
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
500005d0:	ff010113          	addi	sp,sp,-16

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500005d4:	1b450513          	addi	a0,a0,436 # 510001b4 <__devconfig_end+0x160>
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
500005d8:	00112623          	sw	ra,12(sp)

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500005dc:	1dc050ef          	jal	500057b8 <device_get_binding>
500005e0:	510027b7          	lui	a5,0x51002
500005e4:	d0a7a023          	sw	a0,-768(a5) # 51001d00 <__bss_start>
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
500005e8:	fd9ff0ef          	jal	500005c0 <uart_console_hook_install>

	return 0;
}
500005ec:	00c12083          	lw	ra,12(sp)
500005f0:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500005f4:	01010113          	addi	sp,sp,16
500005f8:	00008067          	ret

500005fc <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
500005fc:	ff010113          	addi	sp,sp,-16
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
50000600:	00852603          	lw	a2,8(a0)
 * @param dev UART device struct
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
50000604:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50000608:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
		dev->driver_api = NULL;
		return -ENOTSUP;
	}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0;
5000060c:	000604a3          	sb	zero,9(a2)
50000610:	30073773          	csrrc	a4,mstatus,a4
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
50000614:	00462583          	lw	a1,4(a2)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50000618:	fc173733          	p.bclr	a4,a4,30,1
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
5000061c:	06058a63          	beqz	a1,50000690 <uart_ns16550_init+0x94>
}
#endif

static void set_baud_rate(struct device *dev, u32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
50000620:	00052783          	lw	a5,0(a0)
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
50000624:	0087a783          	lw	a5,8(a5)
50000628:	0007a783          	lw	a5,0(a5)
5000062c:	06078263          	beqz	a5,50000690 <uart_ns16550_init+0x94>
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
50000630:	02b7d7b3          	divu	a5,a5,a1
#endif

static void set_baud_rate(struct device *dev, u32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
50000634:	00852303          	lw	t1,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000638:	00032683          	lw	a3,0(t1)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
5000063c:	f8000e13          	li	t3,-128 # ffffff80 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffff81>
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000640:	00c68693          	addi	a3,a3,12
50000644:	0006c803          	lbu	a6,0(a3)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000648:	01c68023          	sb	t3,0(a3)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
5000064c:	0ff87813          	andi	a6,a6,255
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
50000650:	0047d893          	srli	a7,a5,0x4

		/* set the DLAB to access the baud rate divisor registers */
		lcr_cache = INBYTE(LCR(dev));
		OUTBYTE(LCR(dev), LCR_DLAB);
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
50000654:	0ff8f693          	andi	a3,a7,255
50000658:	00852883          	lw	a7,8(a0)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
5000065c:	0008a883          	lw	a7,0(a7)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
50000660:	00c7d793          	srli	a5,a5,0xc
50000664:	00d88023          	sb	a3,0(a7)
50000668:	00852683          	lw	a3,8(a0)
5000066c:	0006a683          	lw	a3,0(a3)
50000670:	0ff7f793          	andi	a5,a5,255
50000674:	00468693          	addi	a3,a3,4
50000678:	00f68023          	sb	a5,0(a3)

		/* restore the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), lcr_cache);
5000067c:	00852783          	lw	a5,8(a0)
50000680:	0007a783          	lw	a5,0(a5)
50000684:	00c78793          	addi	a5,a5,12
50000688:	01078023          	sb	a6,0(a5)

		dev_data->baud_rate = baud_rate;
5000068c:	00b32223          	sw	a1,4(t1)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
50000690:	00852783          	lw	a5,8(a0)
50000694:	0007a783          	lw	a5,0(a5)
50000698:	00300693          	li	a3,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
5000069c:	00c78793          	addi	a5,a5,12
500006a0:	00d78023          	sb	a3,0(a5)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
500006a4:	00864783          	lbu	a5,8(a2)
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
500006a8:	00b00693          	li	a3,11 # b <___thread_base_t_sched_locked_OFFSET>
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
500006ac:	fc17b7b3          	p.bclr	a5,a5,30,1
500006b0:	00078463          	beqz	a5,500006b8 <uart_ns16550_init+0xbc>
		mdc |= MCR_AFCE;
500006b4:	02b00693          	li	a3,43 # 2b <CONFIG_KERNEL_INIT_PRIORITY_DEFAULT+0x3>

	OUTBYTE(MDC(dev), mdc);
500006b8:	00852783          	lw	a5,8(a0)
500006bc:	0007a783          	lw	a5,0(a5)
500006c0:	01078793          	addi	a5,a5,16
500006c4:	00d78023          	sb	a3,0(a5)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
500006c8:	00852783          	lw	a5,8(a0)
500006cc:	0007a783          	lw	a5,0(a5)
500006d0:	fa700693          	li	a3,-89 # ffffffa7 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffa8>
500006d4:	00878793          	addi	a5,a5,8
500006d8:	00d78023          	sb	a3,0(a5)
		| FCR_FIFO_64
#endif
		);

	/* clear the port */
	INBYTE(RDR(dev));
500006dc:	00852783          	lw	a5,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500006e0:	0007a783          	lw	a5,0(a5)
500006e4:	0047868b          	p.lb	a3,4(a5!)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
500006e8:	00078023          	sb	zero,0(a5)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500006ec:	30072773          	csrrs	a4,mstatus,a4
	OUTBYTE(IER(dev), 0x00);

	irq_unlock(old_level);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
500006f0:	00052783          	lw	a5,0(a0)
500006f4:	0087a783          	lw	a5,8(a5)
500006f8:	0047a783          	lw	a5,4(a5)
500006fc:	000780e7          	jalr	a5
#endif

	return 0;
}
50000700:	00c12083          	lw	ra,12(sp)
50000704:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000708:	01010113          	addi	sp,sp,16
5000070c:	00008067          	ret

50000710 <uart_ns16550_poll_in>:
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
50000710:	00852503          	lw	a0,8(a0)
50000714:	00052703          	lw	a4,0(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000718:	01470793          	addi	a5,a4,20
5000071c:	0007c783          	lbu	a5,0(a5)
50000720:	fc17b7b3          	p.bclr	a5,a5,30,1
50000724:	00078a63          	beqz	a5,50000738 <uart_ns16550_poll_in+0x28>
50000728:	00074783          	lbu	a5,0(a4)
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));

	return 0;
5000072c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
50000730:	00f58023          	sb	a5,0(a1)

	return 0;
50000734:	00008067          	ret
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
		return (-1);
50000738:	fff00513          	li	a0,-1

	/* got a character */
	*c = INBYTE(RDR(dev));

	return 0;
}
5000073c:	00008067          	ret

50000740 <uart_ns16550_poll_out>:
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
50000740:	00852503          	lw	a0,8(a0)
50000744:	00052703          	lw	a4,0(a0)
50000748:	01470693          	addi	a3,a4,20
5000074c:	0006c783          	lbu	a5,0(a3)
50000750:	0407f793          	andi	a5,a5,64
50000754:	fe078ce3          	beqz	a5,5000074c <uart_ns16550_poll_out+0xc>
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000758:	00b70023          	sb	a1,0(a4)
		;

	OUTBYTE(THR(dev), c);

	return c;
}
5000075c:	00058513          	mv	a0,a1
50000760:	00008067          	ret

50000764 <uart_ns16550_err_check>:
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
50000764:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000768:	00052783          	lw	a5,0(a0)
5000076c:	01478793          	addi	a5,a5,20
50000770:	0007c503          	lbu	a0,0(a5)
50000774:	01e57513          	andi	a0,a0,30
}
50000778:	00155513          	srli	a0,a0,0x1
5000077c:	00008067          	ret

50000780 <uart_ns16550_fifo_fill>:
static int uart_ns16550_fifo_fill(struct device *dev, const u8_t *tx_data,
				  int size)
{
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
50000780:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000784:	00160793          	addi	a5,a2,1
50000788:	02065863          	bgez	a2,500007b8 <uart_ns16550_fifo_fill+0x38>
5000078c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50000790:	0280006f          	j	500007b8 <uart_ns16550_fifo_fill+0x38>
50000794:	00852683          	lw	a3,8(a0)
50000798:	0006a603          	lw	a2,0(a3)
5000079c:	01460693          	addi	a3,a2,20
500007a0:	0006c683          	lbu	a3,0(a3)
500007a4:	0206f693          	andi	a3,a3,32
500007a8:	00068c63          	beqz	a3,500007c0 <uart_ns16550_fifo_fill+0x40>
		OUTBYTE(THR(dev), tx_data[i]);
500007ac:	0015c68b          	p.lbu	a3,1(a1!)
static int uart_ns16550_fifo_fill(struct device *dev, const u8_t *tx_data,
				  int size)
{
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
500007b0:	00170713          	addi	a4,a4,1
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
500007b4:	00d60023          	sb	a3,0(a2)
500007b8:	fff78793          	addi	a5,a5,-1
500007bc:	fc079ce3          	bnez	a5,50000794 <uart_ns16550_fifo_fill+0x14>
		OUTBYTE(THR(dev), tx_data[i]);
	}
	return i;
}
500007c0:	00070513          	mv	a0,a4
500007c4:	00008067          	ret

500007c8 <uart_ns16550_fifo_read>:
static int uart_ns16550_fifo_read(struct device *dev, u8_t *rx_data,
				  const int size)
{
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
500007c8:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500007cc:	00160793          	addi	a5,a2,1
500007d0:	02065863          	bgez	a2,50000800 <uart_ns16550_fifo_read+0x38>
500007d4:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500007d8:	0280006f          	j	50000800 <uart_ns16550_fifo_read+0x38>
500007dc:	00852683          	lw	a3,8(a0)
500007e0:	0006a603          	lw	a2,0(a3)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500007e4:	01460693          	addi	a3,a2,20
500007e8:	0006c683          	lbu	a3,0(a3)
500007ec:	fc16b6b3          	p.bclr	a3,a3,30,1
500007f0:	00068c63          	beqz	a3,50000808 <uart_ns16550_fifo_read+0x40>
500007f4:	00064683          	lbu	a3,0(a2)
500007f8:	00170713          	addi	a4,a4,1
		rx_data[i] = INBYTE(RDR(dev));
500007fc:	00d580ab          	p.sb	a3,1(a1!)
50000800:	fff78793          	addi	a5,a5,-1
50000804:	fc079ce3          	bnez	a5,500007dc <uart_ns16550_fifo_read+0x14>
	}

	return i;
}
50000808:	00070513          	mv	a0,a4
5000080c:	00008067          	ret

50000810 <uart_ns16550_irq_tx_enable>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
50000810:	00852503          	lw	a0,8(a0)
50000814:	00052703          	lw	a4,0(a0)
50000818:	00470713          	addi	a4,a4,4
5000081c:	00074783          	lbu	a5,0(a4)
50000820:	0ff7f793          	andi	a5,a5,255
50000824:	c017c7b3          	p.bset	a5,a5,0,1
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000828:	00f70023          	sb	a5,0(a4)
5000082c:	00008067          	ret

50000830 <uart_ns16550_irq_tx_disable>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
50000830:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000834:	00052783          	lw	a5,0(a0)
50000838:	00478793          	addi	a5,a5,4
5000083c:	0007c703          	lbu	a4,0(a5)
50000840:	0fd77713          	andi	a4,a4,253
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000844:	00e78023          	sb	a4,0(a5)
50000848:	00008067          	ret

5000084c <uart_ns16550_irq_tx_ready>:
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(struct device *dev)
{
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
5000084c:	00852503          	lw	a0,8(a0)
50000850:	00954503          	lbu	a0,9(a0)
50000854:	00657513          	andi	a0,a0,6
50000858:	ffe50513          	addi	a0,a0,-2
}
5000085c:	00153513          	seqz	a0,a0
50000860:	00008067          	ret

50000864 <uart_ns16550_irq_tx_complete>:
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_complete(struct device *dev)
{
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
50000864:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000868:	00052783          	lw	a5,0(a0)
5000086c:	01478793          	addi	a5,a5,20
50000870:	0007c503          	lbu	a0,0(a5)
50000874:	06057513          	andi	a0,a0,96
50000878:	fa050513          	addi	a0,a0,-96
}
5000087c:	00153513          	seqz	a0,a0
50000880:	00008067          	ret

50000884 <uart_ns16550_irq_rx_enable>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
50000884:	00852503          	lw	a0,8(a0)
50000888:	00052703          	lw	a4,0(a0)
5000088c:	00470713          	addi	a4,a4,4
50000890:	00074783          	lbu	a5,0(a4)
50000894:	0ff7f793          	andi	a5,a5,255
50000898:	c007c7b3          	p.bset	a5,a5,0,0
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
5000089c:	00f70023          	sb	a5,0(a4)
500008a0:	00008067          	ret

500008a4 <uart_ns16550_irq_rx_disable>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
500008a4:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500008a8:	00052783          	lw	a5,0(a0)
500008ac:	00478793          	addi	a5,a5,4
500008b0:	0007c703          	lbu	a4,0(a5)
500008b4:	0fe77713          	andi	a4,a4,254
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
500008b8:	00e78023          	sb	a4,0(a5)
500008bc:	00008067          	ret

500008c0 <uart_ns16550_irq_rx_ready>:
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(struct device *dev)
{
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
500008c0:	00852503          	lw	a0,8(a0)
500008c4:	00954503          	lbu	a0,9(a0)
500008c8:	00657513          	andi	a0,a0,6
500008cc:	ffc50513          	addi	a0,a0,-4
}
500008d0:	00153513          	seqz	a0,a0
500008d4:	00008067          	ret

500008d8 <uart_ns16550_irq_err_enable>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
500008d8:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500008dc:	00052703          	lw	a4,0(a0)
500008e0:	00470713          	addi	a4,a4,4
500008e4:	00074783          	lbu	a5,0(a4)
500008e8:	0ff7f793          	andi	a5,a5,255
500008ec:	c027c7b3          	p.bset	a5,a5,0,2
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
500008f0:	00f70023          	sb	a5,0(a4)
500008f4:	00008067          	ret

500008f8 <uart_ns16550_irq_err_disable>:
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(struct device *dev)
{
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
500008f8:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500008fc:	00052783          	lw	a5,0(a0)
50000900:	00478793          	addi	a5,a5,4
50000904:	0007c703          	lbu	a4,0(a5)
50000908:	0fb77713          	andi	a4,a4,251
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
5000090c:	00e78023          	sb	a4,0(a5)
50000910:	00008067          	ret

50000914 <uart_ns16550_irq_is_pending>:
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(struct device *dev)
{
	return (!(IIRC(dev) & IIR_NIP));
50000914:	00852503          	lw	a0,8(a0)
50000918:	00954503          	lbu	a0,9(a0)
5000091c:	fc153533          	p.bclr	a0,a0,30,1
}
50000920:	00154513          	xori	a0,a0,1
50000924:	00008067          	ret

50000928 <uart_ns16550_irq_update>:
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(struct device *dev)
{
	IIRC(dev) = INBYTE(IIR(dev));
50000928:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
5000092c:	00052783          	lw	a5,0(a0)
50000930:	00878793          	addi	a5,a5,8
50000934:	0007c783          	lbu	a5,0(a5)
50000938:	00f504a3          	sb	a5,9(a0)

	return 1;
}
5000093c:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
50000940:	00008067          	ret

50000944 <uart_ns16550_irq_callback_set>:
static void uart_ns16550_irq_callback_set(struct device *dev,
					  uart_irq_callback_t cb)
{
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	dev_data->cb = cb;
50000944:	00852503          	lw	a0,8(a0)
50000948:	00b52623          	sw	a1,12(a0)
5000094c:	00008067          	ret

50000950 <uart_ns16550_isr>:
static void uart_ns16550_isr(void *arg)
{
	struct device *dev = arg;
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	if (dev_data->cb) {
50000950:	00852303          	lw	t1,8(a0)
50000954:	00c32303          	lw	t1,12(t1)
50000958:	00030463          	beqz	t1,50000960 <uart_ns16550_isr+0x10>
		dev_data->cb(dev);
5000095c:	00030067          	jr	t1
50000960:	00008067          	ret

50000964 <irq_config_func_0>:

	IRQ_CONNECT(UART_NS16550_PORT_0_IRQ,
		    CONFIG_UART_NS16550_PORT_0_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_0),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_0_IRQ);
50000964:	01800513          	li	a0,24 # 18 <__NANO_ESF_t3_OFFSET>
50000968:	1f50406f          	j	5000535c <_arch_irq_enable>

5000096c <irq_config_func_1>:

	IRQ_CONNECT(UART_NS16550_PORT_1_IRQ,
		    CONFIG_UART_NS16550_PORT_1_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_1),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_1_IRQ);
5000096c:	01400513          	li	a0,20 # 14 <__NANO_ESF_t2_OFFSET>
50000970:	1ed0406f          	j	5000535c <_arch_irq_enable>

50000974 <ppu_timer_irq_handler>:
static void ppu_timer_irq_handler(void *unused)
{
	ARG_UNUSED(unused);

	/* Reset counter */
	timer->val = 0;
50000974:	1a1037b7          	lui	a5,0x1a103
50000978:	0007a023          	sw	zero,0(a5) # 1a103000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17153f80>

	accumulated_cycle_count += sys_clock_hw_cycles_per_tick;
5000097c:	510027b7          	lui	a5,0x51002
50000980:	d0478793          	addi	a5,a5,-764 # 51001d04 <accumulated_cycle_count>
50000984:	510026b7          	lui	a3,0x51002
50000988:	0007a703          	lw	a4,0(a5)
5000098c:	cf86a683          	lw	a3,-776(a3) # 51001cf8 <sys_clock_hw_cycles_per_tick>
50000990:	00d70733          	add	a4,a4,a3
50000994:	00e7a023          	sw	a4,0(a5)

	_sys_clock_tick_announce();
50000998:	510027b7          	lui	a5,0x51002
5000099c:	cf47a503          	lw	a0,-780(a5) # 51001cf4 <_sys_idle_elapsed_ticks>
500009a0:	7f50506f          	j	50006994 <_nano_sys_clock_tick_announce>

500009a4 <_sys_clock_driver_init>:
#ifdef CONFIG_TICKLESS_IDLE
#error "Tickless idle not yet implemented for ppu timer"
#endif

int _sys_clock_driver_init(struct device *device)
{
500009a4:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(device);
	IRQ_CONNECT(PPU_TIMER_A_CMP_IRQ, 0,
		    ppu_timer_irq_handler, NULL, 0);
	irq_enable(PPU_TIMER_A_CMP_IRQ);
500009a8:	01d00513          	li	a0,29 # 1d <__NANO_ESF_t4_OFFSET+0x1>
#ifdef CONFIG_TICKLESS_IDLE
#error "Tickless idle not yet implemented for ppu timer"
#endif

int _sys_clock_driver_init(struct device *device)
{
500009ac:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(device);
	IRQ_CONNECT(PPU_TIMER_A_CMP_IRQ, 0,
		    ppu_timer_irq_handler, NULL, 0);
	irq_enable(PPU_TIMER_A_CMP_IRQ);
500009b0:	1ad040ef          	jal	5000535c <_arch_irq_enable>
	/*
	 * Initialize timer.
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
500009b4:	1a1037b7          	lui	a5,0x1a103
500009b8:	0007a023          	sw	zero,0(a5) # 1a103000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17153f80>
	timer->cmp = sys_clock_hw_cycles_per_tick;
500009bc:	51002737          	lui	a4,0x51002
500009c0:	cf872703          	lw	a4,-776(a4) # 51001cf8 <sys_clock_hw_cycles_per_tick>
	timer->ctrl = TIMER_CTRL_EN;

	return 0;
}
500009c4:	00c12083          	lw	ra,12(sp)
	 * Initialize timer.
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
	timer->cmp = sys_clock_hw_cycles_per_tick;
500009c8:	00e7a423          	sw	a4,8(a5)
	timer->ctrl = TIMER_CTRL_EN;
500009cc:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>

	return 0;
}
500009d0:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
	timer->cmp = sys_clock_hw_cycles_per_tick;
	timer->ctrl = TIMER_CTRL_EN;
500009d4:	00e7a223          	sw	a4,4(a5)

	return 0;
}
500009d8:	01010113          	addi	sp,sp,16
500009dc:	00008067          	ret

500009e0 <uart_fifo_read>:
static inline int uart_fifo_read(struct device *dev, u8_t *rx_data,
				 const int size)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->fifo_read) {
500009e0:	00452303          	lw	t1,4(a0)
500009e4:	01032303          	lw	t1,16(t1)
500009e8:	00030463          	beqz	t1,500009f0 <uart_fifo_read+0x10>
		return api->fifo_read(dev, rx_data, size);
500009ec:	00030067          	jr	t1
	}

	return 0;
}
500009f0:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500009f4:	00008067          	ret

500009f8 <uart_irq_tx_disable>:
 */
static inline void uart_irq_tx_disable(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_tx_disable) {
500009f8:	00452303          	lw	t1,4(a0)
500009fc:	01832303          	lw	t1,24(t1)
50000a00:	00030463          	beqz	t1,50000a08 <uart_irq_tx_disable+0x10>
		api->irq_tx_disable(dev);
50000a04:	00030067          	jr	t1
50000a08:	00008067          	ret

50000a0c <uart_irq_rx_enable>:
 */
static inline void uart_irq_rx_enable(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_rx_enable) {
50000a0c:	00452303          	lw	t1,4(a0)
50000a10:	02032303          	lw	t1,32(t1)
50000a14:	00030463          	beqz	t1,50000a1c <uart_irq_rx_enable+0x10>
		api->irq_rx_enable(dev);
50000a18:	00030067          	jr	t1
50000a1c:	00008067          	ret

50000a20 <uart_irq_rx_disable>:
 */
static inline void uart_irq_rx_disable(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_rx_disable) {
50000a20:	00452303          	lw	t1,4(a0)
50000a24:	02432303          	lw	t1,36(t1)
50000a28:	00030463          	beqz	t1,50000a30 <uart_irq_rx_disable+0x10>
		api->irq_rx_disable(dev);
50000a2c:	00030067          	jr	t1
50000a30:	00008067          	ret

50000a34 <reset_rx>:
	net_buf_add_mem(buf, rx.hdr, rx.hdr_len);
}

static void reset_rx(void)
{
	rx.type = H4_NONE;
50000a34:	510027b7          	lui	a5,0x51002
50000a38:	b8078793          	addi	a5,a5,-1152 # 51001b80 <rx>
50000a3c:	00078fa3          	sb	zero,31(a5)
	rx.remaining = 0;
50000a40:	00079c23          	sh	zero,24(a5)
	rx.have_hdr = false;
50000a44:	00078e23          	sb	zero,28(a5)
	rx.hdr_len = 0;
50000a48:	00078f23          	sb	zero,30(a5)
	rx.discardable = false;
50000a4c:	00078ea3          	sb	zero,29(a5)
50000a50:	00008067          	ret

50000a54 <_bt_uart_init>:

static int _bt_uart_init(struct device *unused)
{
	ARG_UNUSED(unused);

	h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
50000a54:	51000537          	lui	a0,0x51000
	.open		= h4_open,
	.send		= h4_send,
};

static int _bt_uart_init(struct device *unused)
{
50000a58:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(unused);

	h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
50000a5c:	1bc50513          	addi	a0,a0,444 # 510001bc <__devconfig_end+0x168>
	.open		= h4_open,
	.send		= h4_send,
};

static int _bt_uart_init(struct device *unused)
{
50000a60:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(unused);

	h4_dev = device_get_binding(CONFIG_BLUETOOTH_UART_ON_DEV_NAME);
50000a64:	555040ef          	jal	500057b8 <device_get_binding>
50000a68:	510027b7          	lui	a5,0x51002
50000a6c:	d0a7a423          	sw	a0,-760(a5) # 51001d08 <h4_dev>
50000a70:	fea00793          	li	a5,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
	if (!h4_dev) {
50000a74:	00050a63          	beqz	a0,50000a88 <_bt_uart_init+0x34>
		return -EINVAL;
	}

	bt_hci_driver_register(&drv);
50000a78:	51000537          	lui	a0,0x51000
50000a7c:	6b450513          	addi	a0,a0,1716 # 510006b4 <drv>
50000a80:	02c040ef          	jal	50004aac <bt_hci_driver_register>

	return 0;
50000a84:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
}
50000a88:	00c12083          	lw	ra,12(sp)
50000a8c:	00078513          	mv	a0,a5
50000a90:	01010113          	addi	sp,sp,16
50000a94:	00008067          	ret

50000a98 <copy_hdr>:
}


static inline void copy_hdr(struct net_buf *buf)
{
	net_buf_add_mem(buf, rx.hdr, rx.hdr_len);
50000a98:	510025b7          	lui	a1,0x51002
50000a9c:	b8058593          	addi	a1,a1,-1152 # 51001b80 <rx>
50000aa0:	01e5c603          	lbu	a2,30(a1)
50000aa4:	00850513          	addi	a0,a0,8
50000aa8:	02058593          	addi	a1,a1,32
50000aac:	0190406f          	j	500052c4 <net_buf_simple_add_mem>

50000ab0 <get_rx>:
	rx.hdr_len = 0;
	rx.discardable = false;
}

static struct net_buf *get_rx(int timeout)
{
50000ab0:	fe010113          	addi	sp,sp,-32
50000ab4:	00112e23          	sw	ra,28(sp)
50000ab8:	00812c23          	sw	s0,24(sp)
50000abc:	00912a23          	sw	s1,20(sp)
	BT_DBG("type 0x%02x, evt 0x%02x", rx.type, rx.evt.evt);
50000ac0:	51002437          	lui	s0,0x51002
	rx.hdr_len = 0;
	rx.discardable = false;
}

static struct net_buf *get_rx(int timeout)
{
50000ac4:	00050493          	mv	s1,a0
	BT_DBG("type 0x%02x, evt 0x%02x", rx.type, rx.evt.evt);
50000ac8:	3c9050ef          	jal	50006690 <k_current_get>
50000acc:	51002737          	lui	a4,0x51002
50000ad0:	b8040413          	addi	s0,s0,-1152 # 51001b80 <rx>
50000ad4:	99470793          	addi	a5,a4,-1644 # 51001994 <_default_esf+0x288>
50000ad8:	02044883          	lbu	a7,32(s0)
50000adc:	01f44803          	lbu	a6,31(s0)
50000ae0:	510026b7          	lui	a3,0x51002
50000ae4:	00f12023          	sw	a5,0(sp)
50000ae8:	51000637          	lui	a2,0x51000
50000aec:	00050793          	mv	a5,a0
50000af0:	510005b7          	lui	a1,0x51000
50000af4:	51000537          	lui	a0,0x51000
50000af8:	99470713          	addi	a4,a4,-1644
50000afc:	cb868693          	addi	a3,a3,-840 # 51001cb8 <__func__.3470>
50000b00:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50000b04:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50000b08:	1dc50513          	addi	a0,a0,476 # 510001dc <__devconfig_end+0x188>
50000b0c:	418010ef          	jal	50001f24 <printk>

	if (rx.type == H4_EVT && (rx.evt.evt == BT_HCI_EVT_CMD_COMPLETE ||
50000b10:	01f44783          	lbu	a5,31(s0)
50000b14:	0247b863          	p.bneimm	a5,4,50000b44 <get_rx+0x94>
50000b18:	02044783          	lbu	a5,32(s0)
50000b1c:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50000b20:	ff278793          	addi	a5,a5,-14
50000b24:	0ff7f793          	andi	a5,a5,255
50000b28:	02f76663          	bltu	a4,a5,50000b54 <get_rx+0xa4>
				  rx.evt.evt == BT_HCI_EVT_CMD_STATUS)) {
		return bt_buf_get_cmd_complete(timeout);
50000b2c:	00048513          	mv	a0,s1
	if (rx.type == H4_ACL) {
		return bt_buf_get_rx(BT_BUF_ACL_IN, timeout);
	} else {
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
50000b30:	01c12083          	lw	ra,28(sp)
50000b34:	01812403          	lw	s0,24(sp)
50000b38:	01412483          	lw	s1,20(sp)
50000b3c:	02010113          	addi	sp,sp,32
{
	BT_DBG("type 0x%02x, evt 0x%02x", rx.type, rx.evt.evt);

	if (rx.type == H4_EVT && (rx.evt.evt == BT_HCI_EVT_CMD_COMPLETE ||
				  rx.evt.evt == BT_HCI_EVT_CMD_STATUS)) {
		return bt_buf_get_cmd_complete(timeout);
50000b40:	2340406f          	j	50004d74 <bt_buf_get_cmd_complete>
	}

	if (rx.type == H4_ACL) {
50000b44:	0027b863          	p.bneimm	a5,2,50000b54 <get_rx+0xa4>
		return bt_buf_get_rx(BT_BUF_ACL_IN, timeout);
50000b48:	00048593          	mv	a1,s1
50000b4c:	00300513          	li	a0,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
50000b50:	00c0006f          	j	50000b5c <get_rx+0xac>
	} else {
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
50000b54:	00048593          	mv	a1,s1
50000b58:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
	}
}
50000b5c:	01c12083          	lw	ra,28(sp)
50000b60:	01812403          	lw	s0,24(sp)
50000b64:	01412483          	lw	s1,20(sp)
50000b68:	02010113          	addi	sp,sp,32
	}

	if (rx.type == H4_ACL) {
		return bt_buf_get_rx(BT_BUF_ACL_IN, timeout);
	} else {
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
50000b6c:	1b40406f          	j	50004d20 <bt_buf_get_rx>

50000b70 <rx_thread>:
	}
}

static void rx_thread(void *p1, void *p2, void *p3)
{
50000b70:	fc010113          	addi	sp,sp,-64
50000b74:	02112e23          	sw	ra,60(sp)
50000b78:	02812c23          	sw	s0,56(sp)
50000b7c:	02912a23          	sw	s1,52(sp)
50000b80:	03212823          	sw	s2,48(sp)
50000b84:	03312623          	sw	s3,44(sp)
50000b88:	03412423          	sw	s4,40(sp)
50000b8c:	01712e23          	sw	s7,28(sp)
50000b90:	01812c23          	sw	s8,24(sp)
50000b94:	01912a23          	sw	s9,20(sp)
50000b98:	01a12823          	sw	s10,16(sp)
50000b9c:	03512223          	sw	s5,36(sp)
50000ba0:	03612023          	sw	s6,32(sp)
50000ba4:	01b12623          	sw	s11,12(sp)

	ARG_UNUSED(p1);
	ARG_UNUSED(p2);
	ARG_UNUSED(p3);

	BT_DBG("started");
50000ba8:	2e9050ef          	jal	50006690 <k_current_get>
50000bac:	510024b7          	lui	s1,0x51002
50000bb0:	51000a37          	lui	s4,0x51000
50000bb4:	510009b7          	lui	s3,0x51000
50000bb8:	00050793          	mv	a5,a0
50000bbc:	51000937          	lui	s2,0x51000
50000bc0:	51000537          	lui	a0,0x51000

	while (1) {
		BT_DBG("rx.buf %p", rx.buf);
50000bc4:	51002437          	lui	s0,0x51002

	ARG_UNUSED(p1);
	ARG_UNUSED(p2);
	ARG_UNUSED(p3);

	BT_DBG("started");
50000bc8:	99448813          	addi	a6,s1,-1644 # 51001994 <_default_esf+0x288>
50000bcc:	99448713          	addi	a4,s1,-1644
50000bd0:	69c90693          	addi	a3,s2,1692 # 5100069c <__func__.3477>
50000bd4:	1d0a0613          	addi	a2,s4,464 # 510001d0 <__devconfig_end+0x17c>
50000bd8:	1d898593          	addi	a1,s3,472 # 510001d8 <__devconfig_end+0x184>
50000bdc:	20c50513          	addi	a0,a0,524 # 5100020c <__devconfig_end+0x1b8>

	while (1) {
		BT_DBG("rx.buf %p", rx.buf);
50000be0:	b8040413          	addi	s0,s0,-1152 # 51001b80 <rx>

	ARG_UNUSED(p1);
	ARG_UNUSED(p2);
	ARG_UNUSED(p3);

	BT_DBG("started");
50000be4:	340010ef          	jal	50001f24 <printk>

	while (1) {
		BT_DBG("rx.buf %p", rx.buf);
50000be8:	000a0b93          	mv	s7,s4
50000bec:	00098c13          	mv	s8,s3
50000bf0:	51000cb7          	lui	s9,0x51000
		}

		/* Let the ISR continue receiving new packets */
		uart_irq_rx_enable(h4_dev);

		buf = net_buf_get(&rx.fifo, K_FOREVER);
50000bf4:	00440d13          	addi	s10,s0,4
	ARG_UNUSED(p3);

	BT_DBG("started");

	while (1) {
		BT_DBG("rx.buf %p", rx.buf);
50000bf8:	299050ef          	jal	50006690 <k_current_get>
50000bfc:	00042803          	lw	a6,0(s0)
50000c00:	00050793          	mv	a5,a0
50000c04:	99448893          	addi	a7,s1,-1644
50000c08:	99448713          	addi	a4,s1,-1644
50000c0c:	69c90693          	addi	a3,s2,1692
50000c10:	1d0a0613          	addi	a2,s4,464
50000c14:	1d898593          	addi	a1,s3,472
50000c18:	22cc8513          	addi	a0,s9,556 # 5100022c <__devconfig_end+0x1d8>
50000c1c:	308010ef          	jal	50001f24 <printk>

		/* We can only do the allocation if we know the initial
		 * header, since Command Complete/Status events must use the
		 * original command buffer (if available).
		 */
		if (rx.have_hdr && !rx.buf) {
50000c20:	01c44783          	lbu	a5,28(s0)
50000c24:	0a078263          	beqz	a5,50000cc8 <rx_thread+0x158>
50000c28:	00042783          	lw	a5,0(s0)
50000c2c:	08079e63          	bnez	a5,50000cc8 <rx_thread+0x158>
			rx.buf = get_rx(K_FOREVER);
50000c30:	fff00513          	li	a0,-1
50000c34:	e7dff0ef          	jal	50000ab0 <get_rx>
50000c38:	00a42023          	sw	a0,0(s0)
			BT_DBG("Got rx.buf %p", rx.buf);
50000c3c:	255050ef          	jal	50006690 <k_current_get>
50000c40:	51002637          	lui	a2,0x51002
50000c44:	99460893          	addi	a7,a2,-1644 # 51001994 <_default_esf+0x288>
50000c48:	00050793          	mv	a5,a0
50000c4c:	51000637          	lui	a2,0x51000
50000c50:	00042803          	lw	a6,0(s0)
50000c54:	51000537          	lui	a0,0x51000
50000c58:	69c60693          	addi	a3,a2,1692 # 5100069c <__func__.3477>
50000c5c:	99448713          	addi	a4,s1,-1644
50000c60:	1d0b8613          	addi	a2,s7,464
50000c64:	1d8c0593          	addi	a1,s8,472
50000c68:	24c50513          	addi	a0,a0,588 # 5100024c <__devconfig_end+0x1f8>
50000c6c:	2b8010ef          	jal	50001f24 <printk>
			if (rx.remaining > net_buf_tailroom(rx.buf)) {
50000c70:	00042503          	lw	a0,0(s0)
50000c74:	01845a83          	lhu	s5,24(s0)
50000c78:	00850513          	addi	a0,a0,8
50000c7c:	6c0040ef          	jal	5000533c <net_buf_simple_tailroom>
50000c80:	05557063          	bleu	s5,a0,50000cc0 <rx_thread+0x150>
				BT_ERR("Not enough space in buffer");
50000c84:	510007b7          	lui	a5,0x51000
50000c88:	51000737          	lui	a4,0x51000
50000c8c:	51000637          	lui	a2,0x51000
50000c90:	51000537          	lui	a0,0x51000
50000c94:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50000c98:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50000c9c:	69c90693          	addi	a3,s2,1692
50000ca0:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50000ca4:	1d898593          	addi	a1,s3,472
50000ca8:	28850513          	addi	a0,a0,648 # 51000288 <__devconfig_end+0x234>
50000cac:	278010ef          	jal	50001f24 <printk>
				rx.discard = rx.remaining;
50000cb0:	01845783          	lhu	a5,24(s0)
50000cb4:	00f41d23          	sh	a5,26(s0)
				reset_rx();
50000cb8:	d7dff0ef          	jal	50000a34 <reset_rx>
50000cbc:	00c0006f          	j	50000cc8 <rx_thread+0x158>
			} else {
				copy_hdr(rx.buf);
50000cc0:	00042503          	lw	a0,0(s0)
50000cc4:	dd5ff0ef          	jal	50000a98 <copy_hdr>
			}
		}

		/* Let the ISR continue receiving new packets */
		uart_irq_rx_enable(h4_dev);
50000cc8:	51002ab7          	lui	s5,0x51002
50000ccc:	d08aa503          	lw	a0,-760(s5) # 51001d08 <h4_dev>

		buf = net_buf_get(&rx.fifo, K_FOREVER);
		do {
			uart_irq_rx_enable(h4_dev);

			BT_DBG("Calling bt_recv(%p)", buf);
50000cd0:	51000db7          	lui	s11,0x51000
				copy_hdr(rx.buf);
			}
		}

		/* Let the ISR continue receiving new packets */
		uart_irq_rx_enable(h4_dev);
50000cd4:	d39ff0ef          	jal	50000a0c <uart_irq_rx_enable>

		buf = net_buf_get(&rx.fifo, K_FOREVER);
50000cd8:	fff00593          	li	a1,-1
50000cdc:	000d0513          	mv	a0,s10
50000ce0:	480040ef          	jal	50005160 <net_buf_get>
50000ce4:	00050b13          	mv	s6,a0
50000ce8:	d08a8a93          	addi	s5,s5,-760
		do {
			uart_irq_rx_enable(h4_dev);
50000cec:	000aa503          	lw	a0,0(s5)
50000cf0:	d1dff0ef          	jal	50000a0c <uart_irq_rx_enable>

			BT_DBG("Calling bt_recv(%p)", buf);
50000cf4:	19d050ef          	jal	50006690 <k_current_get>
50000cf8:	00050793          	mv	a5,a0
50000cfc:	000b0813          	mv	a6,s6
50000d00:	99448893          	addi	a7,s1,-1644
50000d04:	99448713          	addi	a4,s1,-1644
50000d08:	69c90693          	addi	a3,s2,1692
50000d0c:	1d0a0613          	addi	a2,s4,464
50000d10:	1d898593          	addi	a1,s3,472
50000d14:	2b4d8513          	addi	a0,s11,692 # 510002b4 <__devconfig_end+0x260>
50000d18:	20c010ef          	jal	50001f24 <printk>
			bt_recv(buf);
50000d1c:	000b0513          	mv	a0,s6
50000d20:	5a8030ef          	jal	500042c8 <bt_recv>

			/* Give other threads a chance to run if the ISR
			 * is receiving data so fast that rx.fifo never
			 * or very rarely goes empty.
			 */
			k_yield();
50000d24:	0fd050ef          	jal	50006620 <k_yield>

			uart_irq_rx_disable(h4_dev);
50000d28:	000aa503          	lw	a0,0(s5)
50000d2c:	cf5ff0ef          	jal	50000a20 <uart_irq_rx_disable>
			buf = net_buf_get(&rx.fifo, K_NO_WAIT);
50000d30:	51002537          	lui	a0,0x51002
50000d34:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000d38:	b8450513          	addi	a0,a0,-1148 # 51001b84 <rx+0x4>
50000d3c:	424040ef          	jal	50005160 <net_buf_get>
50000d40:	00050b13          	mv	s6,a0
		} while (buf);
50000d44:	fa0514e3          	bnez	a0,50000cec <rx_thread+0x17c>
50000d48:	eb1ff06f          	j	50000bf8 <rx_thread+0x88>

50000d4c <h4_send>:
		}
	}
}

static int h4_send(struct net_buf *buf)
{
50000d4c:	fe010113          	addi	sp,sp,-32
50000d50:	00812c23          	sw	s0,24(sp)
50000d54:	00050413          	mv	s0,a0
50000d58:	00112e23          	sw	ra,28(sp)
	BT_DBG("buf %p type %u len %u", buf, bt_buf_get_type(buf), buf->len);
50000d5c:	135050ef          	jal	50006690 <k_current_get>
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return *(u8_t *)net_buf_user_data(buf);
50000d60:	00e45783          	lhu	a5,14(s0)
50000d64:	51002737          	lui	a4,0x51002
50000d68:	00f407b3          	add	a5,s0,a5
50000d6c:	01378793          	addi	a5,a5,19
50000d70:	c207b7b3          	p.bclr	a5,a5,1,0
50000d74:	0007c883          	lbu	a7,0(a5)
50000d78:	99470793          	addi	a5,a4,-1644 # 51001994 <_default_esf+0x288>
50000d7c:	00f12223          	sw	a5,4(sp)
50000d80:	00c45783          	lhu	a5,12(s0)
50000d84:	510026b7          	lui	a3,0x51002
50000d88:	00f12023          	sw	a5,0(sp)
50000d8c:	51000637          	lui	a2,0x51000
50000d90:	00050793          	mv	a5,a0
50000d94:	510005b7          	lui	a1,0x51000
50000d98:	51000537          	lui	a0,0x51000
50000d9c:	00040813          	mv	a6,s0
50000da0:	99470713          	addi	a4,a4,-1644
50000da4:	cb068693          	addi	a3,a3,-848 # 51001cb0 <__func__.3525>
50000da8:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50000dac:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50000db0:	2e050513          	addi	a0,a0,736 # 510002e0 <__devconfig_end+0x28c>
50000db4:	170010ef          	jal	50001f24 <printk>

	net_buf_put(&tx.fifo, buf);
50000db8:	51002537          	lui	a0,0x51002
50000dbc:	bac50513          	addi	a0,a0,-1108 # 51001bac <tx+0x8>
50000dc0:	00040593          	mv	a1,s0
50000dc4:	42c040ef          	jal	500051f0 <net_buf_put>
	uart_irq_tx_enable(h4_dev);
50000dc8:	510027b7          	lui	a5,0x51002
50000dcc:	d087a503          	lw	a0,-760(a5) # 51001d08 <h4_dev>
 */
static inline void uart_irq_tx_enable(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_tx_enable) {
50000dd0:	00452783          	lw	a5,4(a0)
50000dd4:	0147a783          	lw	a5,20(a5)
50000dd8:	00078463          	beqz	a5,50000de0 <h4_send+0x94>
		api->irq_tx_enable(dev);
50000ddc:	000780e7          	jalr	a5

	return 0;
}
50000de0:	01c12083          	lw	ra,28(sp)
50000de4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000de8:	01812403          	lw	s0,24(sp)
50000dec:	02010113          	addi	sp,sp,32
50000df0:	00008067          	ret

50000df4 <h4_open>:

static int h4_open(void)
{
50000df4:	fb010113          	addi	sp,sp,-80
50000df8:	04112623          	sw	ra,76(sp)
50000dfc:	04812423          	sw	s0,72(sp)
	BT_DBG("");
50000e00:	091050ef          	jal	50006690 <k_current_get>
50000e04:	00050793          	mv	a5,a0
50000e08:	51002737          	lui	a4,0x51002
50000e0c:	510026b7          	lui	a3,0x51002
50000e10:	51000637          	lui	a2,0x51000
50000e14:	510005b7          	lui	a1,0x51000
50000e18:	51000537          	lui	a0,0x51000

	uart_irq_rx_disable(h4_dev);
50000e1c:	51002437          	lui	s0,0x51002
	return 0;
}

static int h4_open(void)
{
	BT_DBG("");
50000e20:	99470813          	addi	a6,a4,-1644 # 51001994 <_default_esf+0x288>
50000e24:	ca868693          	addi	a3,a3,-856 # 51001ca8 <__func__.3529>
50000e28:	99470713          	addi	a4,a4,-1644
50000e2c:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50000e30:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>

	uart_irq_rx_disable(h4_dev);
50000e34:	d0840413          	addi	s0,s0,-760 # 51001d08 <h4_dev>
	return 0;
}

static int h4_open(void)
{
	BT_DBG("");
50000e38:	30c50513          	addi	a0,a0,780 # 5100030c <__devconfig_end+0x2b8>
50000e3c:	0e8010ef          	jal	50001f24 <printk>

	uart_irq_rx_disable(h4_dev);
50000e40:	00042503          	lw	a0,0(s0)
50000e44:	bddff0ef          	jal	50000a20 <uart_irq_rx_disable>
	uart_irq_tx_disable(h4_dev);
50000e48:	00042503          	lw	a0,0(s0)
50000e4c:	badff0ef          	jal	500009f8 <uart_irq_tx_disable>

static size_t h4_discard(struct device *uart, size_t len)
{
	u8_t buf[33];

	return uart_fifo_read(uart, buf, min(len, sizeof(buf)));
50000e50:	00042503          	lw	a0,0(s0)
50000e54:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50000e58:	01c10593          	addi	a1,sp,28
50000e5c:	b85ff0ef          	jal	500009e0 <uart_fifo_read>
	}
#else
	h4_discard(h4_dev, 32);
#endif

	uart_irq_callback_set(h4_dev, bt_uart_isr);
50000e60:	00042503          	lw	a0,0(s0)
 * @return N/A
 */
static inline void uart_irq_callback_set(struct device *dev,
					 uart_irq_callback_t cb)
{
	const struct uart_driver_api *api = dev->driver_api;
50000e64:	00452783          	lw	a5,4(a0)

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
50000e68:	00078c63          	beqz	a5,50000e80 <h4_open+0x8c>
50000e6c:	0407a783          	lw	a5,64(a5)
50000e70:	00078863          	beqz	a5,50000e80 <h4_open+0x8c>
		api->irq_callback_set(dev, cb);
50000e74:	500015b7          	lui	a1,0x50001
50000e78:	ecc58593          	addi	a1,a1,-308 # 50000ecc <bt_uart_isr>
50000e7c:	000780e7          	jalr	a5

	k_thread_create(&rx_thread_data, rx_thread_stack,
50000e80:	500016b7          	lui	a3,0x50001
50000e84:	510025b7          	lui	a1,0x51002
50000e88:	51002537          	lui	a0,0x51002
50000e8c:	00012223          	sw	zero,4(sp)
50000e90:	00012023          	sw	zero,0(sp)
50000e94:	ff800893          	li	a7,-8 # fffffff8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff9>
50000e98:	00000813          	li	a6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000e9c:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000ea0:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000ea4:	b7068693          	addi	a3,a3,-1168 # 50000b70 <rx_thread>
50000ea8:	52c00613          	li	a2,1324 # 52c <CONFIG_BLUETOOTH_RX_STACK_SIZE+0x12c>
50000eac:	48058593          	addi	a1,a1,1152 # 51002480 <rx_thread_stack>
50000eb0:	d3450513          	addi	a0,a0,-716 # 51001d34 <rx_thread_data>
50000eb4:	7ad050ef          	jal	50006e60 <k_thread_create>
			rx_thread, NULL, NULL, NULL,
			K_PRIO_COOP(CONFIG_BLUETOOTH_RX_PRIO),
			0, K_NO_WAIT);

	return 0;
}
50000eb8:	04c12083          	lw	ra,76(sp)
50000ebc:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000ec0:	04812403          	lw	s0,72(sp)
50000ec4:	05010113          	addi	sp,sp,80
50000ec8:	00008067          	ret

50000ecc <bt_uart_isr>:
		read_header();
	}
}

static void bt_uart_isr(struct device *unused)
{
50000ecc:	f8010113          	addi	sp,sp,-128
50000ed0:	06812c23          	sw	s0,120(sp)
	}
}

static inline void process_rx(void)
{
	BT_DBG("remaining %u discard %u have_hdr %u rx.buf %p len %u",
50000ed4:	51002437          	lui	s0,0x51002
		read_header();
	}
}

static void bt_uart_isr(struct device *unused)
{
50000ed8:	06912a23          	sw	s1,116(sp)
50000edc:	510027b7          	lui	a5,0x51002
	}
}

static inline void process_rx(void)
{
	BT_DBG("remaining %u discard %u have_hdr %u rx.buf %p len %u",
50000ee0:	b8040493          	addi	s1,s0,-1152 # 51001b80 <rx>
		read_header();
	}
}

static void bt_uart_isr(struct device *unused)
{
50000ee4:	07312623          	sw	s3,108(sp)
50000ee8:	05b12623          	sw	s11,76(sp)
50000eec:	06112e23          	sw	ra,124(sp)
50000ef0:	07212823          	sw	s2,112(sp)
50000ef4:	07412423          	sw	s4,104(sp)
50000ef8:	07512223          	sw	s5,100(sp)
50000efc:	07612023          	sw	s6,96(sp)
50000f00:	05712e23          	sw	s7,92(sp)
50000f04:	05812c23          	sw	s8,88(sp)
50000f08:	05912a23          	sw	s9,84(sp)
50000f0c:	05a12823          	sw	s10,80(sp)
50000f10:	ba478993          	addi	s3,a5,-1116 # 51001ba4 <tx>
{
	BT_DBG("remaining %u discard %u have_hdr %u rx.buf %p len %u",
	       rx.remaining, rx.discard, rx.have_hdr, rx.buf,
	       rx.buf ? rx.buf->len : 0);

	if (rx.discard) {
50000f14:	b8040413          	addi	s0,s0,-1152
static inline void get_acl_hdr(void)
{
	struct bt_hci_acl_hdr *hdr = &rx.acl;
	int to_read = sizeof(*hdr) - rx.remaining;

	rx.remaining -= uart_fifo_read(h4_dev, (u8_t *)hdr + to_read,
50000f18:	02048d93          	addi	s11,s1,32

static void bt_uart_isr(struct device *unused)
{
	ARG_UNUSED(unused);

	while (uart_irq_update(h4_dev) && uart_irq_is_pending(h4_dev)) {
50000f1c:	51002b37          	lui	s6,0x51002
			goto done;
		}

		bytes = uart_fifo_fill(h4_dev, &tx.type, 1);
		if (bytes != 1) {
			BT_WARN("Unable to send H:4 type");
50000f20:	51000a37          	lui	s4,0x51000
50000f24:	51000bb7          	lui	s7,0x51000
50000f28:	51000ab7          	lui	s5,0x51000

static void bt_uart_isr(struct device *unused)
{
	ARG_UNUSED(unused);

	while (uart_irq_update(h4_dev) && uart_irq_is_pending(h4_dev)) {
50000f2c:	d08b2503          	lw	a0,-760(s6) # 51001d08 <h4_dev>
50000f30:	d08b0913          	addi	s2,s6,-760
 */
static inline int uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_update) {
50000f34:	00452783          	lw	a5,4(a0)
50000f38:	03c7a783          	lw	a5,60(a5)
50000f3c:	74078e63          	beqz	a5,50001698 <bt_uart_isr+0x7cc>
		return api->irq_update(dev);
50000f40:	000780e7          	jalr	a5
50000f44:	74050a63          	beqz	a0,50001698 <bt_uart_isr+0x7cc>
50000f48:	00092503          	lw	a0,0(s2)

static inline int uart_irq_is_pending(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_is_pending)	{
50000f4c:	00452783          	lw	a5,4(a0)
50000f50:	0387a783          	lw	a5,56(a5)
50000f54:	74078263          	beqz	a5,50001698 <bt_uart_isr+0x7cc>
		return api->irq_is_pending(dev);
50000f58:	000780e7          	jalr	a5
50000f5c:	72050e63          	beqz	a0,50001698 <bt_uart_isr+0x7cc>
		if (uart_irq_tx_ready(h4_dev)) {
50000f60:	00092503          	lw	a0,0(s2)
 */
static inline int uart_irq_tx_ready(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_tx_ready) {
50000f64:	00452783          	lw	a5,4(a0)
50000f68:	01c7a783          	lw	a5,28(a5)
50000f6c:	18078263          	beqz	a5,500010f0 <bt_uart_isr+0x224>
		return api->irq_tx_ready(dev);
50000f70:	000780e7          	jalr	a5
50000f74:	16050e63          	beqz	a0,500010f0 <bt_uart_isr+0x224>

static inline void process_tx(void)
{
	int bytes;

	if (!tx.buf) {
50000f78:	510027b7          	lui	a5,0x51002
50000f7c:	ba478c13          	addi	s8,a5,-1116 # 51001ba4 <tx>
50000f80:	004c2783          	lw	a5,4(s8)
50000f84:	04079463          	bnez	a5,50000fcc <bt_uart_isr+0x100>
		tx.buf = net_buf_get(&tx.fifo, K_NO_WAIT);
50000f88:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50000f8c:	008c0513          	addi	a0,s8,8
50000f90:	1d0040ef          	jal	50005160 <net_buf_get>
50000f94:	00ac2223          	sw	a0,4(s8)
		if (!tx.buf) {
50000f98:	02051a63          	bnez	a0,50000fcc <bt_uart_isr+0x100>
			BT_ERR("TX interrupt but no pending buffer!");
50000f9c:	51000737          	lui	a4,0x51000
50000fa0:	51000637          	lui	a2,0x51000
50000fa4:	510005b7          	lui	a1,0x51000
50000fa8:	51000537          	lui	a0,0x51000
50000fac:	270a0793          	addi	a5,s4,624 # 51000270 <__devconfig_end+0x21c>
50000fb0:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50000fb4:	6dca8693          	addi	a3,s5,1756 # 510006dc <__func__.3506>
50000fb8:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50000fbc:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50000fc0:	32450513          	addi	a0,a0,804 # 51000324 <__devconfig_end+0x2d0>
50000fc4:	761000ef          	jal	50001f24 <printk>
50000fc8:	1200006f          	j	500010e8 <bt_uart_isr+0x21c>
			uart_irq_tx_disable(h4_dev);
			return;
		}
	}

	if (!tx.type) {
50000fcc:	0009c783          	lbu	a5,0(s3)
50000fd0:	0a079a63          	bnez	a5,50001084 <bt_uart_isr+0x1b8>
		switch (bt_buf_get_type(tx.buf)) {
50000fd4:	0049a783          	lw	a5,4(s3)
50000fd8:	00e7d703          	lhu	a4,14(a5)
50000fdc:	00e787b3          	add	a5,a5,a4
50000fe0:	01378793          	addi	a5,a5,19
50000fe4:	c207b7b3          	p.bclr	a5,a5,1,0
50000fe8:	0007c783          	lbu	a5,0(a5)
50000fec:	00078663          	beqz	a5,50000ff8 <bt_uart_isr+0x12c>
50000ff0:	0227b263          	p.bneimm	a5,2,50001014 <bt_uart_isr+0x148>
50000ff4:	0080006f          	j	50000ffc <bt_uart_isr+0x130>
		case BT_BUF_ACL_OUT:
			tx.type = H4_ACL;
			break;
		case BT_BUF_CMD:
			tx.type = H4_CMD;
50000ff8:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
		default:
			BT_ERR("Unknown buffer type");
			goto done;
		}

		bytes = uart_fifo_fill(h4_dev, &tx.type, 1);
50000ffc:	00092503          	lw	a0,0(s2)
		switch (bt_buf_get_type(tx.buf)) {
		case BT_BUF_ACL_OUT:
			tx.type = H4_ACL;
			break;
		case BT_BUF_CMD:
			tx.type = H4_CMD;
50001000:	00f98023          	sb	a5,0(s3)
static inline int uart_fifo_fill(struct device *dev, const u8_t *tx_data,
				 int size)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->fifo_fill) {
50001004:	00452783          	lw	a5,4(a0)
50001008:	00c7a783          	lw	a5,12(a5)
5000100c:	02079c63          	bnez	a5,50001044 <bt_uart_isr+0x178>
50001010:	0440006f          	j	50001054 <bt_uart_isr+0x188>
			break;
		default:
			BT_ERR("Unknown buffer type");
50001014:	51000737          	lui	a4,0x51000
50001018:	51000637          	lui	a2,0x51000
5000101c:	510005b7          	lui	a1,0x51000
50001020:	51000537          	lui	a0,0x51000
50001024:	270a0793          	addi	a5,s4,624
50001028:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
5000102c:	6dca8693          	addi	a3,s5,1756
50001030:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50001034:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50001038:	35850513          	addi	a0,a0,856 # 51000358 <__devconfig_end+0x304>
5000103c:	6e9000ef          	jal	50001f24 <printk>
50001040:	0840006f          	j	500010c4 <bt_uart_isr+0x1f8>
		return api->fifo_fill(dev, tx_data, size);
50001044:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
50001048:	00098593          	mv	a1,s3
5000104c:	000780e7          	jalr	a5
			goto done;
		}

		bytes = uart_fifo_fill(h4_dev, &tx.type, 1);
		if (bytes != 1) {
50001050:	02152a63          	p.beqimm	a0,1,50001084 <bt_uart_isr+0x1b8>
			BT_WARN("Unable to send H:4 type");
50001054:	51000637          	lui	a2,0x51000
50001058:	510005b7          	lui	a1,0x51000
5000105c:	51000537          	lui	a0,0x51000
50001060:	270a0793          	addi	a5,s4,624
50001064:	37cb8713          	addi	a4,s7,892 # 5100037c <__devconfig_end+0x328>
50001068:	6dca8693          	addi	a3,s5,1756
5000106c:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50001070:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50001074:	38c50513          	addi	a0,a0,908 # 5100038c <__devconfig_end+0x338>
50001078:	6ad000ef          	jal	50001f24 <printk>
			tx.type = H4_NONE;
5000107c:	00098023          	sb	zero,0(s3)
50001080:	0700006f          	j	500010f0 <bt_uart_isr+0x224>
			return;
		}
	}

	bytes = uart_fifo_fill(h4_dev, tx.buf->data, tx.buf->len);
50001084:	00092503          	lw	a0,0(s2)
50001088:	0049a703          	lw	a4,4(s3)
static inline int uart_fifo_fill(struct device *dev, const u8_t *tx_data,
				 int size)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->fifo_fill) {
5000108c:	00452783          	lw	a5,4(a0)
50001090:	00c7a783          	lw	a5,12(a5)
50001094:	00c75603          	lhu	a2,12(a4)
		return api->fifo_fill(dev, tx_data, size);
	}

	return 0;
50001098:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
static inline int uart_fifo_fill(struct device *dev, const u8_t *tx_data,
				 int size)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->fifo_fill) {
5000109c:	00078863          	beqz	a5,500010ac <bt_uart_isr+0x1e0>
		return api->fifo_fill(dev, tx_data, size);
500010a0:	00872583          	lw	a1,8(a4)
500010a4:	000780e7          	jalr	a5
500010a8:	00050593          	mv	a1,a0
	net_buf_pull(tx.buf, bytes);
500010ac:	0049a503          	lw	a0,4(s3)
500010b0:	00850513          	addi	a0,a0,8
500010b4:	228040ef          	jal	500052dc <net_buf_simple_pull>

	if (tx.buf->len) {
500010b8:	0049a783          	lw	a5,4(s3)
500010bc:	00c7d783          	lhu	a5,12(a5)
500010c0:	02079863          	bnez	a5,500010f0 <bt_uart_isr+0x224>
		return;
	}

done:
	tx.type = H4_NONE;
	net_buf_unref(tx.buf);
500010c4:	0049a503          	lw	a0,4(s3)
	if (tx.buf->len) {
		return;
	}

done:
	tx.type = H4_NONE;
500010c8:	00098023          	sb	zero,0(s3)
	net_buf_unref(tx.buf);
500010cc:	148040ef          	jal	50005214 <net_buf_unref>
	tx.buf = net_buf_get(&tx.fifo, K_NO_WAIT);
500010d0:	51002537          	lui	a0,0x51002
500010d4:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500010d8:	bac50513          	addi	a0,a0,-1108 # 51001bac <tx+0x8>
500010dc:	084040ef          	jal	50005160 <net_buf_get>
500010e0:	00a9a223          	sw	a0,4(s3)
	if (!tx.buf) {
500010e4:	00051663          	bnez	a0,500010f0 <bt_uart_isr+0x224>
		uart_irq_tx_disable(h4_dev);
500010e8:	00092503          	lw	a0,0(s2)
500010ec:	90dff0ef          	jal	500009f8 <uart_irq_tx_disable>
	while (uart_irq_update(h4_dev) && uart_irq_is_pending(h4_dev)) {
		if (uart_irq_tx_ready(h4_dev)) {
			process_tx();
		}

		if (uart_irq_rx_ready(h4_dev)) {
500010f0:	00092503          	lw	a0,0(s2)
 */
static inline int uart_irq_rx_ready(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_rx_ready) {
500010f4:	00452783          	lw	a5,4(a0)
500010f8:	02c7a783          	lw	a5,44(a5)
500010fc:	e20788e3          	beqz	a5,50000f2c <bt_uart_isr+0x60>
		return api->irq_rx_ready(dev);
50001100:	000780e7          	jalr	a5
50001104:	e20504e3          	beqz	a0,50000f2c <bt_uart_isr+0x60>
	}
}

static inline void process_rx(void)
{
	BT_DBG("remaining %u discard %u have_hdr %u rx.buf %p len %u",
50001108:	588050ef          	jal	50006690 <k_current_get>
5000110c:	0004a703          	lw	a4,0(s1)
50001110:	00050793          	mv	a5,a0
50001114:	0184d803          	lhu	a6,24(s1)
50001118:	01a4d883          	lhu	a7,26(s1)
5000111c:	01c4c603          	lbu	a2,28(s1)
50001120:	00000693          	li	a3,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50001124:	00070463          	beqz	a4,5000112c <bt_uart_isr+0x260>
50001128:	00c75683          	lhu	a3,12(a4)
5000112c:	51002c37          	lui	s8,0x51002
50001130:	994c0593          	addi	a1,s8,-1644 # 51001994 <_default_esf+0x288>
50001134:	51000d37          	lui	s10,0x51000
50001138:	51000b37          	lui	s6,0x51000
5000113c:	00d12423          	sw	a3,8(sp)
50001140:	51000537          	lui	a0,0x51000
50001144:	510006b7          	lui	a3,0x51000
50001148:	00b12623          	sw	a1,12(sp)
5000114c:	00e12223          	sw	a4,4(sp)
50001150:	00c12023          	sw	a2,0(sp)
50001154:	994c0713          	addi	a4,s8,-1644
50001158:	6f468693          	addi	a3,a3,1780 # 510006f4 <__func__.3515>
5000115c:	1d0d0613          	addi	a2,s10,464 # 510001d0 <__devconfig_end+0x17c>
50001160:	1d8b0593          	addi	a1,s6,472 # 510001d8 <__devconfig_end+0x184>
50001164:	3b450513          	addi	a0,a0,948 # 510003b4 <__devconfig_end+0x360>
50001168:	5bd000ef          	jal	50001f24 <printk>
	       rx.remaining, rx.discard, rx.have_hdr, rx.buf,
	       rx.buf ? rx.buf->len : 0);

	if (rx.discard) {
5000116c:	01a4d783          	lhu	a5,26(s1)
50001170:	000b0a93          	mv	s5,s6
50001174:	000c0a13          	mv	s4,s8
50001178:	000d0c93          	mv	s9,s10
5000117c:	02078463          	beqz	a5,500011a4 <bt_uart_isr+0x2d8>

static size_t h4_discard(struct device *uart, size_t len)
{
	u8_t buf[33];

	return uart_fifo_read(uart, buf, min(len, sizeof(buf)));
50001180:	02100613          	li	a2,33 # 21 <CONFIG_NUM_IRQS+0x1>
50001184:	00092503          	lw	a0,0(s2)
50001188:	04c7d633          	p.minu	a2,a5,a2
5000118c:	01c10593          	addi	a1,sp,28
50001190:	851ff0ef          	jal	500009e0 <uart_fifo_read>
	BT_DBG("remaining %u discard %u have_hdr %u rx.buf %p len %u",
	       rx.remaining, rx.discard, rx.have_hdr, rx.buf,
	       rx.buf ? rx.buf->len : 0);

	if (rx.discard) {
		rx.discard -= h4_discard(h4_dev, rx.discard);
50001194:	01a45783          	lhu	a5,26(s0)
50001198:	40a78533          	sub	a0,a5,a0
5000119c:	00a41d23          	sh	a0,26(s0)
500011a0:	d7dff06f          	j	50000f1c <bt_uart_isr+0x50>
		return;
	}

	if (rx.have_hdr) {
500011a4:	01c44783          	lbu	a5,28(s0)
500011a8:	28078663          	beqz	a5,50001434 <bt_uart_isr+0x568>
{
	struct net_buf *buf;
	bool prio;
	int read;

	if (!rx.buf) {
500011ac:	00042783          	lw	a5,0(s0)
500011b0:	51000bb7          	lui	s7,0x51000
500011b4:	10079063          	bnez	a5,500012b4 <bt_uart_isr+0x3e8>
		rx.buf = get_rx(K_NO_WAIT);
500011b8:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500011bc:	8f5ff0ef          	jal	50000ab0 <get_rx>
500011c0:	00a42023          	sw	a0,0(s0)
		if (!rx.buf) {
500011c4:	06051663          	bnez	a0,50001230 <bt_uart_isr+0x364>
			if (rx.discardable) {
500011c8:	01d44683          	lbu	a3,29(s0)
500011cc:	510007b7          	lui	a5,0x51000
500011d0:	51000737          	lui	a4,0x51000
500011d4:	51000637          	lui	a2,0x51000
500011d8:	02068663          	beqz	a3,50001204 <bt_uart_isr+0x338>
				BT_WARN("Discarding event 0x%02x", rx.evt.evt);
500011dc:	27078813          	addi	a6,a5,624 # 51000270 <__devconfig_end+0x21c>
500011e0:	51000537          	lui	a0,0x51000
500011e4:	02044783          	lbu	a5,32(s0)
500011e8:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
500011ec:	700b8693          	addi	a3,s7,1792 # 51000700 <__func__.3492>
500011f0:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
500011f4:	1d8b0593          	addi	a1,s6,472
500011f8:	40050513          	addi	a0,a0,1024 # 51000400 <__devconfig_end+0x3ac>
500011fc:	529000ef          	jal	50001f24 <printk>
50001200:	09c0006f          	j	5000129c <bt_uart_isr+0x3d0>
				rx.discard = rx.remaining;
				reset_rx();
				return;
			}

			BT_WARN("Failed to allocate, deferring to rx_thread");
50001204:	51000537          	lui	a0,0x51000
50001208:	27078793          	addi	a5,a5,624
5000120c:	37c70713          	addi	a4,a4,892
50001210:	700b8693          	addi	a3,s7,1792
50001214:	38460613          	addi	a2,a2,900
50001218:	1d8b0593          	addi	a1,s6,472
5000121c:	42850513          	addi	a0,a0,1064 # 51000428 <__devconfig_end+0x3d4>
50001220:	505000ef          	jal	50001f24 <printk>
			uart_irq_rx_disable(h4_dev);
50001224:	00092503          	lw	a0,0(s2)
50001228:	ff8ff0ef          	jal	50000a20 <uart_irq_rx_disable>
5000122c:	cf1ff06f          	j	50000f1c <bt_uart_isr+0x50>
			return;
		}

		BT_DBG("Allocated rx.buf %p", rx.buf);
50001230:	460050ef          	jal	50006690 <k_current_get>
50001234:	00050793          	mv	a5,a0
50001238:	00042803          	lw	a6,0(s0)
5000123c:	51000537          	lui	a0,0x51000
50001240:	994c0893          	addi	a7,s8,-1644
50001244:	994c0713          	addi	a4,s8,-1644
50001248:	700b8693          	addi	a3,s7,1792
5000124c:	1d0d0613          	addi	a2,s10,464
50001250:	1d8b0593          	addi	a1,s6,472
50001254:	46450513          	addi	a0,a0,1124 # 51000464 <__devconfig_end+0x410>
50001258:	4cd000ef          	jal	50001f24 <printk>

		if (rx.remaining > net_buf_tailroom(rx.buf)) {
5000125c:	00042503          	lw	a0,0(s0)
50001260:	01845c03          	lhu	s8,24(s0)
50001264:	00850513          	addi	a0,a0,8
50001268:	0d4040ef          	jal	5000533c <net_buf_simple_tailroom>
5000126c:	05857063          	bleu	s8,a0,500012ac <bt_uart_isr+0x3e0>
			BT_ERR("Not enough space in buffer");
50001270:	510007b7          	lui	a5,0x51000
50001274:	51000737          	lui	a4,0x51000
50001278:	51000637          	lui	a2,0x51000
5000127c:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50001280:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50001284:	700b8693          	addi	a3,s7,1792
50001288:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
5000128c:	1d8b0593          	addi	a1,s6,472
50001290:	51000537          	lui	a0,0x51000
50001294:	28850513          	addi	a0,a0,648 # 51000288 <__devconfig_end+0x234>
50001298:	48d000ef          	jal	50001f24 <printk>
			rx.discard = rx.remaining;
5000129c:	01845783          	lhu	a5,24(s0)
500012a0:	00f41d23          	sh	a5,26(s0)
			reset_rx();
500012a4:	f90ff0ef          	jal	50000a34 <reset_rx>
500012a8:	c75ff06f          	j	50000f1c <bt_uart_isr+0x50>
			return;
		}

		copy_hdr(rx.buf);
500012ac:	00042503          	lw	a0,0(s0)
500012b0:	fe8ff0ef          	jal	50000a98 <copy_hdr>
	}

	read = uart_fifo_read(h4_dev, net_buf_tail(rx.buf), rx.remaining);
500012b4:	0004a783          	lw	a5,0(s1)
500012b8:	0184d603          	lhu	a2,24(s1)
500012bc:	00c7d583          	lhu	a1,12(a5)
500012c0:	00092503          	lw	a0,0(s2)
500012c4:	0087a783          	lw	a5,8(a5)
500012c8:	00b785b3          	add	a1,a5,a1
500012cc:	f14ff0ef          	jal	500009e0 <uart_fifo_read>
500012d0:	00050913          	mv	s2,a0
	net_buf_add(rx.buf, read);
500012d4:	0004a503          	lw	a0,0(s1)
500012d8:	00090593          	mv	a1,s2
500012dc:	00850513          	addi	a0,a0,8
500012e0:	7cd030ef          	jal	500052ac <net_buf_simple_add>
	rx.remaining -= read;
500012e4:	0184d783          	lhu	a5,24(s1)

	BT_DBG("got %d bytes, remaining %u", read, rx.remaining);
500012e8:	994a0b13          	addi	s6,s4,-1644
		copy_hdr(rx.buf);
	}

	read = uart_fifo_read(h4_dev, net_buf_tail(rx.buf), rx.remaining);
	net_buf_add(rx.buf, read);
	rx.remaining -= read;
500012ec:	412787b3          	sub	a5,a5,s2
500012f0:	00f49c23          	sh	a5,24(s1)

	BT_DBG("got %d bytes, remaining %u", read, rx.remaining);
500012f4:	39c050ef          	jal	50006690 <k_current_get>
500012f8:	00050793          	mv	a5,a0
500012fc:	0184d883          	lhu	a7,24(s1)
50001300:	51000537          	lui	a0,0x51000
50001304:	00090813          	mv	a6,s2
50001308:	994a0713          	addi	a4,s4,-1644
5000130c:	700b8693          	addi	a3,s7,1792
50001310:	1d0c8613          	addi	a2,s9,464
50001314:	1d8a8593          	addi	a1,s5,472
50001318:	01612023          	sw	s6,0(sp)
5000131c:	49050513          	addi	a0,a0,1168 # 51000490 <__devconfig_end+0x43c>
50001320:	405000ef          	jal	50001f24 <printk>
	BT_DBG("Payload (len %u): %s", rx.buf->len,
50001324:	36c050ef          	jal	50006690 <k_current_get>
50001328:	00050c13          	mv	s8,a0
5000132c:	0004a503          	lw	a0,0(s1)
50001330:	00c55903          	lhu	s2,12(a0)
50001334:	00852503          	lw	a0,8(a0)
50001338:	00090593          	mv	a1,s2
5000133c:	109010ef          	jal	50002c44 <bt_hex>
50001340:	00050893          	mv	a7,a0
50001344:	51000537          	lui	a0,0x51000
50001348:	000c0793          	mv	a5,s8
5000134c:	01612023          	sw	s6,0(sp)
50001350:	00090813          	mv	a6,s2
50001354:	994a0713          	addi	a4,s4,-1644
50001358:	700b8693          	addi	a3,s7,1792
5000135c:	1d0c8613          	addi	a2,s9,464
50001360:	1d8a8593          	addi	a1,s5,472
50001364:	4c050513          	addi	a0,a0,1216 # 510004c0 <__devconfig_end+0x46c>
50001368:	3bd000ef          	jal	50001f24 <printk>
	       bt_hex(rx.buf->data, rx.buf->len));

	if (rx.remaining) {
5000136c:	0184d783          	lhu	a5,24(s1)
50001370:	ba0796e3          	bnez	a5,50000f1c <bt_uart_isr+0x50>
		return;
	}

	prio = (rx.type == H4_EVT && bt_hci_evt_is_prio(rx.evt.evt));
50001374:	01f44683          	lbu	a3,31(s0)
50001378:	00000b13          	li	s6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000137c:	0046b863          	p.bneimm	a3,4,5000138c <bt_uart_isr+0x4c0>
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
50001380:	02044b03          	lbu	s6,32(s0)
50001384:	ff2b0b13          	addi	s6,s6,-14
50001388:	002b3b13          	sltiu	s6,s6,2

	buf = rx.buf;
5000138c:	0004a903          	lw	s2,0(s1)
	rx.buf = NULL;
50001390:	0004a023          	sw	zero,0(s1)
50001394:	00e95703          	lhu	a4,14(s2)
50001398:	01090793          	addi	a5,s2,16
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	*(u8_t *)net_buf_user_data(buf) = type;
5000139c:	00e787b3          	add	a5,a5,a4
500013a0:	00378793          	addi	a5,a5,3
500013a4:	c207b7b3          	p.bclr	a5,a5,1,0
500013a8:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>

	if (rx.type == H4_EVT) {
500013ac:	0046a463          	p.beqimm	a3,4,500013b4 <bt_uart_isr+0x4e8>
500013b0:	00300713          	li	a4,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
500013b4:	00e78023          	sb	a4,0(a5)
		bt_buf_set_type(buf, BT_BUF_EVT);
	} else {
		bt_buf_set_type(buf, BT_BUF_ACL_IN);
	}

	reset_rx();
500013b8:	e7cff0ef          	jal	50000a34 <reset_rx>

	if (prio) {
500013bc:	020b0e63          	beqz	s6,500013f8 <bt_uart_isr+0x52c>
		BT_DBG("Calling bt_recv_prio(%p)", buf);
500013c0:	2d0050ef          	jal	50006690 <k_current_get>
500013c4:	00050793          	mv	a5,a0
500013c8:	51000537          	lui	a0,0x51000
500013cc:	994a0893          	addi	a7,s4,-1644
500013d0:	00090813          	mv	a6,s2
500013d4:	994a0713          	addi	a4,s4,-1644
500013d8:	700b8693          	addi	a3,s7,1792
500013dc:	1d0c8613          	addi	a2,s9,464
500013e0:	1d8a8593          	addi	a1,s5,472
500013e4:	4ec50513          	addi	a0,a0,1260 # 510004ec <__devconfig_end+0x498>
500013e8:	33d000ef          	jal	50001f24 <printk>
		bt_recv_prio(buf);
500013ec:	00090513          	mv	a0,s2
500013f0:	408030ef          	jal	500047f8 <bt_recv_prio>
500013f4:	b29ff06f          	j	50000f1c <bt_uart_isr+0x50>
	} else {
		BT_DBG("Putting buf %p to rx fifo", buf);
500013f8:	298050ef          	jal	50006690 <k_current_get>
500013fc:	00050793          	mv	a5,a0
50001400:	51000537          	lui	a0,0x51000
50001404:	1d8a8593          	addi	a1,s5,472
50001408:	994a0893          	addi	a7,s4,-1644
5000140c:	00090813          	mv	a6,s2
50001410:	994a0713          	addi	a4,s4,-1644
50001414:	700b8693          	addi	a3,s7,1792
50001418:	1d0c8613          	addi	a2,s9,464
5000141c:	51c50513          	addi	a0,a0,1308 # 5100051c <__devconfig_end+0x4c8>
50001420:	305000ef          	jal	50001f24 <printk>
		net_buf_put(&rx.fifo, buf);
50001424:	00090593          	mv	a1,s2
50001428:	00448513          	addi	a0,s1,4
5000142c:	5c5030ef          	jal	500051f0 <net_buf_put>
50001430:	aedff06f          	j	50000f1c <bt_uart_isr+0x50>
	}
}

static inline void read_header(void)
{
	switch (rx.type) {
50001434:	01f44783          	lbu	a5,31(s0)
50001438:	1a27a263          	p.beqimm	a5,2,500015dc <bt_uart_isr+0x710>
5000143c:	0a47a463          	p.beqimm	a5,4,500014e4 <bt_uart_isr+0x618>
static struct device *h4_dev;

static inline void h4_get_type(void)
{
	/* Get packet type */
	if (uart_fifo_read(h4_dev, &rx.type, 1) != 1) {
50001440:	00092503          	lw	a0,0(s2)
50001444:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
50001448:	01f40593          	addi	a1,s0,31
5000144c:	d94ff0ef          	jal	500009e0 <uart_fifo_read>
50001450:	02152c63          	p.beqimm	a0,1,50001488 <bt_uart_isr+0x5bc>
		BT_WARN("Unable to read H:4 packet type");
50001454:	510007b7          	lui	a5,0x51000
50001458:	51000737          	lui	a4,0x51000
5000145c:	510006b7          	lui	a3,0x51000
50001460:	51000637          	lui	a2,0x51000
50001464:	51000537          	lui	a0,0x51000
50001468:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
5000146c:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
50001470:	6d068693          	addi	a3,a3,1744 # 510006d0 <__func__.3442>
50001474:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50001478:	1d8b0593          	addi	a1,s6,472
5000147c:	54c50513          	addi	a0,a0,1356 # 5100054c <__devconfig_end+0x4f8>
50001480:	2a5000ef          	jal	50001f24 <printk>
50001484:	0580006f          	j	500014dc <bt_uart_isr+0x610>
		rx.type = H4_NONE;
		return;
	}

	switch (rx.type) {
50001488:	01f44783          	lbu	a5,31(s0)
5000148c:	0027a863          	p.beqimm	a5,2,5000149c <bt_uart_isr+0x5d0>
50001490:	0047be63          	p.bneimm	a5,4,500014ac <bt_uart_isr+0x5e0>
	case H4_EVT:
		rx.remaining = sizeof(rx.evt);
50001494:	00200793          	li	a5,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50001498:	0080006f          	j	500014a0 <bt_uart_isr+0x5d4>
		rx.hdr_len = rx.remaining;
		break;
	case H4_ACL:
		rx.remaining = sizeof(rx.acl);
5000149c:	00400793          	li	a5,4 # 4 <__NANO_ESF_gp_OFFSET>
500014a0:	00f41c23          	sh	a5,24(s0)
		rx.hdr_len = rx.remaining;
500014a4:	00f40f23          	sb	a5,30(s0)
500014a8:	a75ff06f          	j	50000f1c <bt_uart_isr+0x50>
		break;
	default:
		BT_ERR("Unknown H:4 type 0x%02x", rx.type);
500014ac:	51000837          	lui	a6,0x51000
500014b0:	51000737          	lui	a4,0x51000
500014b4:	510006b7          	lui	a3,0x51000
500014b8:	51000637          	lui	a2,0x51000
500014bc:	51000537          	lui	a0,0x51000
500014c0:	27080813          	addi	a6,a6,624 # 51000270 <__devconfig_end+0x21c>
500014c4:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
500014c8:	6d068693          	addi	a3,a3,1744 # 510006d0 <__func__.3442>
500014cc:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
500014d0:	1d8b0593          	addi	a1,s6,472
500014d4:	57c50513          	addi	a0,a0,1404 # 5100057c <__devconfig_end+0x528>
500014d8:	24d000ef          	jal	50001f24 <printk>
		rx.type = H4_NONE;
500014dc:	00040fa3          	sb	zero,31(s0)
500014e0:	a3dff06f          	j	50000f1c <bt_uart_isr+0x50>
}

static inline void get_evt_hdr(void)
{
	struct bt_hci_evt_hdr *hdr = &rx.evt;
	int to_read = rx.hdr_len - rx.remaining;
500014e4:	01845603          	lhu	a2,24(s0)

	rx.remaining -= uart_fifo_read(h4_dev, (u8_t *)hdr + to_read,
500014e8:	01e44583          	lbu	a1,30(s0)
500014ec:	00092503          	lw	a0,0(s2)
500014f0:	40c585b3          	sub	a1,a1,a2
500014f4:	00bd85b3          	add	a1,s11,a1
500014f8:	ce8ff0ef          	jal	500009e0 <uart_fifo_read>
500014fc:	01845783          	lhu	a5,24(s0)
50001500:	40a78533          	sub	a0,a5,a0
				       rx.remaining);
	if (rx.hdr_len == sizeof(*hdr) && rx.remaining < sizeof(*hdr)) {
50001504:	01e44783          	lbu	a5,30(s0)
static inline void get_evt_hdr(void)
{
	struct bt_hci_evt_hdr *hdr = &rx.evt;
	int to_read = rx.hdr_len - rx.remaining;

	rx.remaining -= uart_fifo_read(h4_dev, (u8_t *)hdr + to_read,
50001508:	10055533          	p.exthz	a0,a0
5000150c:	00a41c23          	sh	a0,24(s0)
				       rx.remaining);
	if (rx.hdr_len == sizeof(*hdr) && rx.remaining < sizeof(*hdr)) {
50001510:	0227b463          	p.bneimm	a5,2,50001538 <bt_uart_isr+0x66c>
50001514:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001518:	02a7e063          	bltu	a5,a0,50001538 <bt_uart_isr+0x66c>
		switch (rx.evt.evt) {
5000151c:	02044703          	lbu	a4,32(s0)
50001520:	03e00793          	li	a5,62 # 3e <CONFIG_UART_CONSOLE_INIT_PRIORITY+0x2>
50001524:	00f71a63          	bne	a4,a5,50001538 <bt_uart_isr+0x66c>
		case BT_HCI_EVT_LE_META_EVENT:
			rx.remaining++;
50001528:	00150513          	addi	a0,a0,1
			rx.hdr_len++;
5000152c:	00300793          	li	a5,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
	rx.remaining -= uart_fifo_read(h4_dev, (u8_t *)hdr + to_read,
				       rx.remaining);
	if (rx.hdr_len == sizeof(*hdr) && rx.remaining < sizeof(*hdr)) {
		switch (rx.evt.evt) {
		case BT_HCI_EVT_LE_META_EVENT:
			rx.remaining++;
50001530:	00a41c23          	sh	a0,24(s0)
			rx.hdr_len++;
50001534:	00f40f23          	sb	a5,30(s0)
			break;
#endif
		}
	}

	if (!rx.remaining) {
50001538:	0184d783          	lhu	a5,24(s1)
5000153c:	10079463          	bnez	a5,50001644 <bt_uart_isr+0x778>
		if (rx.evt.evt == BT_HCI_EVT_LE_META_EVENT &&
50001540:	00ff07b7          	lui	a5,0xff0
50001544:	02042703          	lw	a4,32(s0)
50001548:	0ff78793          	addi	a5,a5,255 # ff00ff <CONFIG_DTCM_SIZE+0x7f00ff>
5000154c:	00f777b3          	and	a5,a4,a5
50001550:	00020737          	lui	a4,0x20
50001554:	03e70713          	addi	a4,a4,62 # 2003e <CONFIG_UART_NS16550_PORT_1_BAUD_RATE+0x3e3e>
50001558:	51000937          	lui	s2,0x51000
5000155c:	02e79a63          	bne	a5,a4,50001590 <bt_uart_isr+0x6c4>
		    rx.hdr[sizeof(*hdr)] == BT_HCI_EVT_LE_ADVERTISING_REPORT) {
			BT_DBG("Marking adv report as discardable");
50001560:	130050ef          	jal	50006690 <k_current_get>
50001564:	00050793          	mv	a5,a0
50001568:	51000537          	lui	a0,0x51000
5000156c:	994a0813          	addi	a6,s4,-1644
50001570:	994a0713          	addi	a4,s4,-1644
50001574:	6a890693          	addi	a3,s2,1704 # 510006a8 <__func__.3460>
50001578:	1d0c8613          	addi	a2,s9,464
5000157c:	1d8a8593          	addi	a1,s5,472
50001580:	5a450513          	addi	a0,a0,1444 # 510005a4 <__devconfig_end+0x550>
50001584:	1a1000ef          	jal	50001f24 <printk>
			rx.discardable = true;
50001588:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
5000158c:	00f40ea3          	sb	a5,29(s0)
		}

		rx.remaining = hdr->len - (rx.hdr_len - sizeof(*hdr));
50001590:	0214c783          	lbu	a5,33(s1)
50001594:	01e4c703          	lbu	a4,30(s1)
50001598:	00278793          	addi	a5,a5,2
5000159c:	40e787b3          	sub	a5,a5,a4
500015a0:	00f49c23          	sh	a5,24(s1)
		BT_DBG("Got event header. Payload %u bytes", hdr->len);
500015a4:	0ec050ef          	jal	50006690 <k_current_get>
500015a8:	00050793          	mv	a5,a0
500015ac:	0214c803          	lbu	a6,33(s1)
500015b0:	51000537          	lui	a0,0x51000
500015b4:	994a0893          	addi	a7,s4,-1644
500015b8:	994a0713          	addi	a4,s4,-1644
500015bc:	6a890693          	addi	a3,s2,1704
500015c0:	1d0c8613          	addi	a2,s9,464
500015c4:	1d8a8593          	addi	a1,s5,472
500015c8:	5dc50513          	addi	a0,a0,1500 # 510005dc <__devconfig_end+0x588>
500015cc:	159000ef          	jal	50001f24 <printk>
		rx.have_hdr = true;
500015d0:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500015d4:	00f48e23          	sb	a5,28(s1)
500015d8:	06c0006f          	j	50001644 <bt_uart_isr+0x778>
}

static inline void get_acl_hdr(void)
{
	struct bt_hci_acl_hdr *hdr = &rx.acl;
	int to_read = sizeof(*hdr) - rx.remaining;
500015dc:	01845603          	lhu	a2,24(s0)

	rx.remaining -= uart_fifo_read(h4_dev, (u8_t *)hdr + to_read,
500015e0:	00092503          	lw	a0,0(s2)
500015e4:	40cd85b3          	sub	a1,s11,a2
500015e8:	00458593          	addi	a1,a1,4
500015ec:	bf4ff0ef          	jal	500009e0 <uart_fifo_read>
500015f0:	01845783          	lhu	a5,24(s0)
500015f4:	40a78533          	sub	a0,a5,a0
500015f8:	10055533          	p.exthz	a0,a0
500015fc:	00a41c23          	sh	a0,24(s0)
				       rx.remaining);
	if (!rx.remaining) {
50001600:	04051263          	bnez	a0,50001644 <bt_uart_isr+0x778>
		rx.remaining = sys_le16_to_cpu(hdr->len);
50001604:	02245783          	lhu	a5,34(s0)
50001608:	00f41c23          	sh	a5,24(s0)
		BT_DBG("Got ACL header. Payload %u bytes", rx.remaining);
5000160c:	084050ef          	jal	50006690 <k_current_get>
50001610:	00050793          	mv	a5,a0
50001614:	01845803          	lhu	a6,24(s0)
50001618:	510006b7          	lui	a3,0x51000
5000161c:	51000537          	lui	a0,0x51000
50001620:	994c0893          	addi	a7,s8,-1644
50001624:	994c0713          	addi	a4,s8,-1644
50001628:	6c468693          	addi	a3,a3,1732 # 510006c4 <__func__.3452>
5000162c:	1d0d0613          	addi	a2,s10,464
50001630:	1d8b0593          	addi	a1,s6,472
50001634:	61450513          	addi	a0,a0,1556 # 51000614 <__devconfig_end+0x5c0>
50001638:	0ed000ef          	jal	50001f24 <printk>
		rx.have_hdr = true;
5000163c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001640:	00f40e23          	sb	a5,28(s0)
	default:
		CODE_UNREACHABLE;
		return;
	}

	if (rx.have_hdr && rx.buf) {
50001644:	01c44783          	lbu	a5,28(s0)
50001648:	8c078ae3          	beqz	a5,50000f1c <bt_uart_isr+0x50>
5000164c:	00042503          	lw	a0,0(s0)
50001650:	8c0506e3          	beqz	a0,50000f1c <bt_uart_isr+0x50>
		if (rx.remaining > net_buf_tailroom(rx.buf)) {
50001654:	01845903          	lhu	s2,24(s0)
50001658:	00850513          	addi	a0,a0,8
5000165c:	4e1030ef          	jal	5000533c <net_buf_simple_tailroom>
50001660:	03257663          	bleu	s2,a0,5000168c <bt_uart_isr+0x7c0>
			BT_ERR("Not enough space in buffer");
50001664:	510007b7          	lui	a5,0x51000
50001668:	51000737          	lui	a4,0x51000
5000166c:	510006b7          	lui	a3,0x51000
50001670:	51000637          	lui	a2,0x51000
50001674:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50001678:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
5000167c:	6e868693          	addi	a3,a3,1768 # 510006e8 <__func__.3501>
50001680:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50001684:	1d8a8593          	addi	a1,s5,472
50001688:	c09ff06f          	j	50001290 <bt_uart_isr+0x3c4>
			rx.discard = rx.remaining;
			reset_rx();
		} else {
			copy_hdr(rx.buf);
5000168c:	00042503          	lw	a0,0(s0)
50001690:	c08ff0ef          	jal	50000a98 <copy_hdr>
50001694:	889ff06f          	j	50000f1c <bt_uart_isr+0x50>

		if (uart_irq_rx_ready(h4_dev)) {
			process_rx();
		}
	}
}
50001698:	07c12083          	lw	ra,124(sp)
5000169c:	07812403          	lw	s0,120(sp)
500016a0:	07412483          	lw	s1,116(sp)
500016a4:	07012903          	lw	s2,112(sp)
500016a8:	06c12983          	lw	s3,108(sp)
500016ac:	06812a03          	lw	s4,104(sp)
500016b0:	06412a83          	lw	s5,100(sp)
500016b4:	06012b03          	lw	s6,96(sp)
500016b8:	05c12b83          	lw	s7,92(sp)
500016bc:	05812c03          	lw	s8,88(sp)
500016c0:	05412c83          	lw	s9,84(sp)
500016c4:	05012d03          	lw	s10,80(sp)
500016c8:	04c12d83          	lw	s11,76(sp)
500016cc:	08010113          	addi	sp,sp,128
500016d0:	00008067          	ret

500016d4 <gpio_ppu_irq_handler>:

static void gpio_ppu_irq_handler(void *arg)
{
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
500016d4:	00052783          	lw	a5,0(a0)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
500016d8:	ff010113          	addi	sp,sp,-16
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
500016dc:	0087a783          	lw	a5,8(a5)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
500016e0:	00912223          	sw	s1,4(sp)
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
500016e4:	0007a483          	lw	s1,0(a5)
500016e8:	00852783          	lw	a5,8(a0)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
500016ec:	00812423          	sw	s0,8(sp)
500016f0:	0007a403          	lw	s0,0(a5)
500016f4:	00112623          	sw	ra,12(sp)
500016f8:	01212023          	sw	s2,0(sp)
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	_gpio_fire_callbacks(&data->cb, dev, gpio->intstatus);
500016fc:	0184a483          	lw	s1,24(s1)
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
50001700:	02040863          	beqz	s0,50001730 <gpio_ppu_irq_handler+0x5c>
50001704:	00050913          	mv	s2,a0
		if (cb->pin_mask & pins) {
50001708:	00842783          	lw	a5,8(s0)
5000170c:	00f4f7b3          	and	a5,s1,a5
50001710:	00078c63          	beqz	a5,50001728 <gpio_ppu_irq_handler+0x54>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
50001714:	00442783          	lw	a5,4(s0)
50001718:	00048613          	mv	a2,s1
5000171c:	00040593          	mv	a1,s0
50001720:	00090513          	mv	a0,s2
50001724:	000780e7          	jalr	a5
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
50001728:	00042403          	lw	s0,0(s0)
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
5000172c:	fc041ee3          	bnez	s0,50001708 <gpio_ppu_irq_handler+0x34>
}
50001730:	00c12083          	lw	ra,12(sp)
50001734:	00812403          	lw	s0,8(sp)
50001738:	00412483          	lw	s1,4(sp)
5000173c:	00012903          	lw	s2,0(sp)
50001740:	01010113          	addi	sp,sp,16
50001744:	00008067          	ret

50001748 <gpio_ppu_config>:
static int gpio_ppu_config(struct device *dev,
			       int access_op,
			       u32_t pin,
			       int flags)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50001748:	00052783          	lw	a5,0(a0)
5000174c:	0087a783          	lw	a5,8(a5)
50001750:	0007a783          	lw	a5,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001754:	00058663          	beqz	a1,50001760 <gpio_ppu_config+0x18>
		return -ENOTSUP;
50001758:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
5000175c:	00008067          	ret

	if (pin > 31)
50001760:	01f00713          	li	a4,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
50001764:	00c77663          	bleu	a2,a4,50001770 <gpio_ppu_config+0x28>
		return -EINVAL;
50001768:	fea00513          	li	a0,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
5000176c:	00008067          	ret
50001770:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>

	/* Configure pin as gpio */
//	PPU_PADMUX |= (PPU_PAD_GPIO << pin);

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
50001774:	fc16b833          	p.bclr	a6,a3,30,1
		gpio->paddir |= BIT(pin);
50001778:	0007a703          	lw	a4,0(a5)
5000177c:	00c595b3          	sll	a1,a1,a2

	/* Configure pin as gpio */
//	PPU_PADMUX |= (PPU_PAD_GPIO << pin);

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
50001780:	00080663          	beqz	a6,5000178c <gpio_ppu_config+0x44>
		gpio->paddir |= BIT(pin);
50001784:	00e5e5b3          	or	a1,a1,a4
50001788:	00c0006f          	j	50001794 <gpio_ppu_config+0x4c>
	else
		gpio->paddir &= ~BIT(pin);
5000178c:	fff5c593          	not	a1,a1
50001790:	00e5f5b3          	and	a1,a1,a4
	 * gpio.
	 * Interrupt for a gpio is:
	 * 1) enabled only via a call to gpio_ppu_enable_callback.
	 * 2) disabled only via a call to gpio_ppu_disabled_callback.
	 */
	if (!(flags & GPIO_INT))
50001794:	0026f513          	andi	a0,a3,2

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
		gpio->paddir |= BIT(pin);
	else
		gpio->paddir &= ~BIT(pin);
50001798:	00b7a023          	sw	a1,0(a5)
	 * gpio.
	 * Interrupt for a gpio is:
	 * 1) enabled only via a call to gpio_ppu_enable_callback.
	 * 2) disabled only via a call to gpio_ppu_disabled_callback.
	 */
	if (!(flags & GPIO_INT))
5000179c:	06050c63          	beqz	a0,50001814 <gpio_ppu_config+0xcc>
		return 0;

	/*
	 * Interrupt cannot be set for GPIO_DIR_OUT
	 */
	if (flags & GPIO_DIR_OUT)
500017a0:	fc0814e3          	bnez	a6,50001768 <gpio_ppu_config+0x20>
		return -EINVAL;

	/* Double edge trigger not supported */
	if (flags & GPIO_INT_DOUBLE_EDGE)
500017a4:	0406f513          	andi	a0,a3,64
500017a8:	fa0518e3          	bnez	a0,50001758 <gpio_ppu_config+0x10>
		return -ENOTSUP;

	/* Edge or Level triggered ? */
	if (flags & GPIO_INT_EDGE)
500017ac:	0206f713          	andi	a4,a3,32
500017b0:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
500017b4:	00070a63          	beqz	a4,500017c8 <gpio_ppu_config+0x80>
		gpio->inttype1 |= BIT(pin);
500017b8:	0147a703          	lw	a4,20(a5)
500017bc:	00c595b3          	sll	a1,a1,a2
500017c0:	00e5e5b3          	or	a1,a1,a4
500017c4:	0140006f          	j	500017d8 <gpio_ppu_config+0x90>
	else
		gpio->inttype1 &= ~BIT(pin);
500017c8:	00c595b3          	sll	a1,a1,a2
500017cc:	0147a703          	lw	a4,20(a5)
500017d0:	fff5c593          	not	a1,a1
500017d4:	00e5f5b3          	and	a1,a1,a4

	/* Level High/Rising Edge ? */
	if (flags & GPIO_INT_ACTIVE_HIGH)
500017d8:	0046f693          	andi	a3,a3,4

	/* Edge or Level triggered ? */
	if (flags & GPIO_INT_EDGE)
		gpio->inttype1 |= BIT(pin);
	else
		gpio->inttype1 &= ~BIT(pin);
500017dc:	00b7aa23          	sw	a1,20(a5)
500017e0:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>

	/* Level High/Rising Edge ? */
	if (flags & GPIO_INT_ACTIVE_HIGH)
500017e4:	00068e63          	beqz	a3,50001800 <gpio_ppu_config+0xb8>
		gpio->inttype0 &= ~BIT(pin);
500017e8:	00c71733          	sll	a4,a4,a2
500017ec:	0107a683          	lw	a3,16(a5)
500017f0:	fff74713          	not	a4,a4
500017f4:	00d77733          	and	a4,a4,a3
500017f8:	00e7a823          	sw	a4,16(a5)
500017fc:	00008067          	ret
	else
		gpio->inttype0 |= BIT(pin);
50001800:	0107a683          	lw	a3,16(a5)
50001804:	00c71733          	sll	a4,a4,a2
50001808:	00d76733          	or	a4,a4,a3
5000180c:	00e7a823          	sw	a4,16(a5)

	return 0;
50001810:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
}
50001814:	00008067          	ret

50001818 <gpio_ppu_write>:
static int gpio_ppu_write(struct device *dev,
			      int access_op,
			      u32_t pin,
			      u32_t value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50001818:	00052703          	lw	a4,0(a0)
5000181c:	00872703          	lw	a4,8(a4)
50001820:	00072703          	lw	a4,0(a4)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001824:	02059c63          	bnez	a1,5000185c <gpio_ppu_write+0x44>
50001828:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
		return -ENOTSUP;

	if (value)
5000182c:	00068a63          	beqz	a3,50001840 <gpio_ppu_write+0x28>
		gpio->padout |= BIT(pin);
50001830:	00872683          	lw	a3,8(a4)
50001834:	00c797b3          	sll	a5,a5,a2
50001838:	00d7e7b3          	or	a5,a5,a3
5000183c:	0140006f          	j	50001850 <gpio_ppu_write+0x38>
	else
		gpio->padout &= ~BIT(pin);
50001840:	00c797b3          	sll	a5,a5,a2
50001844:	00872683          	lw	a3,8(a4)
50001848:	fff7c793          	not	a5,a5
5000184c:	00d7f7b3          	and	a5,a5,a3
50001850:	00f72423          	sw	a5,8(a4)

	return 0;
50001854:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50001858:	00008067          	ret
			      u32_t value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
5000185c:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
		gpio->padout |= BIT(pin);
	else
		gpio->padout &= ~BIT(pin);

	return 0;
}
50001860:	00008067          	ret

50001864 <gpio_ppu_read>:
static int gpio_ppu_read(struct device *dev,
			     int access_op,
			     u32_t pin,
			     u32_t *value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50001864:	00052783          	lw	a5,0(a0)
50001868:	0087a783          	lw	a5,8(a5)
5000186c:	0007a783          	lw	a5,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001870:	02059a63          	bnez	a1,500018a4 <gpio_ppu_read+0x40>
	/*
	 * If gpio is configured as output,
	 * read gpio value from padout register,
	 * otherwise read gpio value from padin register
	 */
	if (gpio->paddir & BIT(pin))
50001874:	0007a703          	lw	a4,0(a5)
50001878:	00c75733          	srl	a4,a4,a2
5000187c:	fc173733          	p.bclr	a4,a4,30,1
50001880:	00070663          	beqz	a4,5000188c <gpio_ppu_read+0x28>
		*value = !!(gpio->padout & BIT(pin));
50001884:	0087a783          	lw	a5,8(a5)
50001888:	0080006f          	j	50001890 <gpio_ppu_read+0x2c>
	else
		*value = !!(gpio->padin & BIT(pin));
5000188c:	0047a783          	lw	a5,4(a5)
50001890:	00c7d633          	srl	a2,a5,a2
50001894:	fc163633          	p.bclr	a2,a2,30,1
50001898:	00c6a023          	sw	a2,0(a3)

	return 0;
5000189c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500018a0:	00008067          	ret
			     u32_t *value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
500018a4:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
		*value = !!(gpio->padout & BIT(pin));
	else
		*value = !!(gpio->padin & BIT(pin));

	return 0;
}
500018a8:	00008067          	ret

500018ac <gpio_ppu_manage_callback>:

static int gpio_ppu_manage_callback(struct device *dev,
					struct gpio_callback *callback,
					bool set)
{
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
500018ac:	00852503          	lw	a0,8(a0)
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
500018b0:	00052783          	lw	a5,0(a0)
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
500018b4:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
500018b8:	02060463          	beqz	a2,500018e0 <gpio_ppu_manage_callback+0x34>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
500018bc:	00f5a023          	sw	a5,0(a1)
	list->head = node;

	if (!list->tail) {
500018c0:	00452783          	lw	a5,4(a0)
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
	list->head = node;
500018c4:	00b52023          	sw	a1,0(a0)

	if (!list->tail) {
500018c8:	04079663          	bnez	a5,50001914 <gpio_ppu_manage_callback+0x68>
		list->tail = list->head;
500018cc:	00b52223          	sw	a1,4(a0)
500018d0:	0440006f          	j	50001914 <gpio_ppu_manage_callback+0x68>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
500018d4:	00f58a63          	beq	a1,a5,500018e8 <gpio_ppu_manage_callback+0x3c>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
500018d8:	00078713          	mv	a4,a5
500018dc:	0007a783          	lw	a5,0(a5)
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
500018e0:	fe079ae3          	bnez	a5,500018d4 <gpio_ppu_manage_callback+0x28>
500018e4:	0300006f          	j	50001914 <gpio_ppu_manage_callback+0x68>
500018e8:	00452683          	lw	a3,4(a0)
500018ec:	0005a783          	lw	a5,0(a1)
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
500018f0:	00071a63          	bnez	a4,50001904 <gpio_ppu_manage_callback+0x58>
		list->head = node->next;
500018f4:	00f52023          	sw	a5,0(a0)

		/* Was node also the tail? */
		if (list->tail == node) {
500018f8:	00d59c63          	bne	a1,a3,50001910 <gpio_ppu_manage_callback+0x64>
			list->tail = list->head;
500018fc:	00f52223          	sw	a5,4(a0)
50001900:	0100006f          	j	50001910 <gpio_ppu_manage_callback+0x64>
		}
	} else {
		prev_node->next = node->next;
50001904:	00f72023          	sw	a5,0(a4)

		/* Was node the tail? */
		if (list->tail == node) {
50001908:	00d59463          	bne	a1,a3,50001910 <gpio_ppu_manage_callback+0x64>
			list->tail = prev_node;
5000190c:	00e52223          	sw	a4,4(a0)
		}
	}

	node->next = NULL;
50001910:	0005a023          	sw	zero,0(a1)

	_gpio_manage_callback(&data->cb, callback, set);

	return 0;
}
50001914:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50001918:	00008067          	ret

5000191c <gpio_ppu_enable_callback>:

static int gpio_ppu_enable_callback(struct device *dev,
					int access_op,
					u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
5000191c:	00052783          	lw	a5,0(a0)
50001920:	0087a783          	lw	a5,8(a5)
50001924:	0007a683          	lw	a3,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001928:	02059063          	bnez	a1,50001948 <gpio_ppu_enable_callback+0x2c>
		return -ENOTSUP;

	/* Enable interrupt for pin */
	gpio->inten |= BIT(pin);
5000192c:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50001930:	00c6a783          	lw	a5,12(a3)
50001934:	00c71633          	sll	a2,a4,a2
50001938:	00f66633          	or	a2,a2,a5
5000193c:	00c6a623          	sw	a2,12(a3)

	return 0;
50001940:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50001944:	00008067          	ret
					u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
50001948:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>

	/* Enable interrupt for pin */
	gpio->inten |= BIT(pin);

	return 0;
}
5000194c:	00008067          	ret

50001950 <gpio_ppu_disable_callback>:

static int gpio_ppu_disable_callback(struct device *dev,
					 int access_op,
					 u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50001950:	00052783          	lw	a5,0(a0)
50001954:	0087a783          	lw	a5,8(a5)
50001958:	0007a683          	lw	a3,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
5000195c:	02059263          	bnez	a1,50001980 <gpio_ppu_disable_callback+0x30>
		return -ENOTSUP;

	/* Disable interrupt for pin */
	gpio->inten &= ~BIT(pin);
50001960:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001964:	00c79633          	sll	a2,a5,a2
50001968:	00c6a703          	lw	a4,12(a3)
5000196c:	fff64613          	not	a2,a2
50001970:	00e67633          	and	a2,a2,a4
50001974:	00c6a623          	sw	a2,12(a3)

	return 0;
50001978:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000197c:	00008067          	ret
					 u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
50001980:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>

	/* Disable interrupt for pin */
	gpio->inten &= ~BIT(pin);

	return 0;
}
50001984:	00008067          	ret

50001988 <gpio_ppu_init>:
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);
50001988:	00052783          	lw	a5,0(a0)
 * @param dev GPIO device struct
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
5000198c:	ff010113          	addi	sp,sp,-16
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);

	cfg->gpio_cfg_func();
50001990:	0087a783          	lw	a5,8(a5)
 * @param dev GPIO device struct
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
50001994:	00112623          	sw	ra,12(sp)
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);

	cfg->gpio_cfg_func();
50001998:	0047a783          	lw	a5,4(a5)
5000199c:	000780e7          	jalr	a5

	return 0;
}
500019a0:	00c12083          	lw	ra,12(sp)
500019a4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500019a8:	01010113          	addi	sp,sp,16
500019ac:	00008067          	ret

500019b0 <gpio_ppu_cfg_0>:
	IRQ_CONNECT(PPU_GPIO_0_IRQ,
		    0,
		    gpio_ppu_irq_handler,
		    DEVICE_GET(gpio_ppu_0),
		    0);
	irq_enable(PPU_GPIO_0_IRQ);
500019b0:	01900513          	li	a0,25 # 19 <__NANO_ESF_t3_OFFSET+0x1>
500019b4:	1a90306f          	j	5000535c <_arch_irq_enable>

500019b8 <_nop_char_out>:
 * @return a function pointer or NULL if no hook is set
 */
void *__printk_get_hook(void)
{
	return _char_out;
}
500019b8:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500019bc:	00008067          	ret

500019c0 <char_out>:
500019c0:	0005a783          	lw	a5,0(a1)
500019c4:	00178793          	addi	a5,a5,1
500019c8:	00f5a023          	sw	a5,0(a1)
500019cc:	510027b7          	lui	a5,0x51002
500019d0:	cc87a303          	lw	t1,-824(a5) # 51001cc8 <_char_out>
500019d4:	00030067          	jr	t1

500019d8 <_printk_dec_ulong>:
500019d8:	fc010113          	addi	sp,sp,-64
500019dc:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500019e0:	03212823          	sw	s2,48(sp)
500019e4:	03512223          	sw	s5,36(sp)
500019e8:	03612023          	sw	s6,32(sp)
500019ec:	01712e23          	sw	s7,28(sp)
500019f0:	01812c23          	sw	s8,24(sp)
500019f4:	02112e23          	sw	ra,60(sp)
500019f8:	02812c23          	sw	s0,56(sp)
500019fc:	02912a23          	sw	s1,52(sp)
50001a00:	03312623          	sw	s3,44(sp)
50001a04:	03412423          	sw	s4,40(sp)
50001a08:	01912a23          	sw	s9,20(sp)
50001a0c:	01a12823          	sw	s10,16(sp)
50001a10:	01b12623          	sw	s11,12(sp)
50001a14:	00050a93          	mv	s5,a0
50001a18:	00058b13          	mv	s6,a1
50001a1c:	00068b93          	mv	s7,a3
50001a20:	04f76933          	p.max	s2,a4,a5
50001a24:	03000c13          	li	s8,48 # 30 <__NANO_ESF_a2_OFFSET>
50001a28:	00f68463          	beq	a3,a5,50001a30 <_printk_dec_ulong+0x58>
50001a2c:	02000c13          	li	s8,32 # 20 <CONFIG_NUM_IRQS>
50001a30:	00a00a13          	li	s4,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50001a34:	3b9ad4b7          	lui	s1,0x3b9ad
50001a38:	00060413          	mv	s0,a2
50001a3c:	00100993          	li	s3,1 # 1 <CONFIG_ARCH>
50001a40:	00000d93          	li	s11,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50001a44:	9ff48493          	addi	s1,s1,-1537 # 3b9ac9ff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x389fd97f>
50001a48:	00200d13          	li	s10,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50001a4c:	000a0c93          	mv	s9,s4
50001a50:	000d9463          	bnez	s11,50001a58 <_printk_dec_ulong+0x80>
50001a54:	0284f263          	bleu	s0,s1,50001a78 <_printk_dec_ulong+0xa0>
50001a58:	00148513          	addi	a0,s1,1
50001a5c:	02a45533          	divu	a0,s0,a0
50001a60:	000b0593          	mv	a1,s6
50001a64:	00198993          	addi	s3,s3,1
50001a68:	00100d93          	li	s11,1 # 1 <CONFIG_ARCH>
50001a6c:	03050513          	addi	a0,a0,48
50001a70:	000a80e7          	jalr	s5
50001a74:	01c0006f          	j	50001a90 <_printk_dec_ulong+0xb8>
50001a78:	01494c63          	blt	s2,s4,50001a90 <_printk_dec_ulong+0xb8>
50001a7c:	017d6a63          	bltu	s10,s7,50001a90 <_printk_dec_ulong+0xb8>
50001a80:	000b0593          	mv	a1,s6
50001a84:	000c0513          	mv	a0,s8
50001a88:	000a80e7          	jalr	s5
50001a8c:	00198993          	addi	s3,s3,1
50001a90:	00148793          	addi	a5,s1,1
50001a94:	02f45733          	divu	a4,s0,a5
50001a98:	fffa0a13          	addi	s4,s4,-1
50001a9c:	42f71433          	p.msu	s0,a4,a5
50001aa0:	0394d4b3          	divu	s1,s1,s9
50001aa4:	fa1a36e3          	p.bneimm	s4,1,50001a50 <_printk_dec_ulong+0x78>
50001aa8:	03040513          	addi	a0,s0,48
50001aac:	000b0593          	mv	a1,s6
50001ab0:	000a80e7          	jalr	s5
50001ab4:	41390433          	sub	s0,s2,s3
50001ab8:	003bbe63          	p.bneimm	s7,3,50001ad4 <_printk_dec_ulong+0xfc>
50001abc:	00805c63          	blez	s0,50001ad4 <_printk_dec_ulong+0xfc>
50001ac0:	000b0593          	mv	a1,s6
50001ac4:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
50001ac8:	000a80e7          	jalr	s5
50001acc:	fff40413          	addi	s0,s0,-1
50001ad0:	fedff06f          	j	50001abc <_printk_dec_ulong+0xe4>
50001ad4:	03c12083          	lw	ra,60(sp)
50001ad8:	03812403          	lw	s0,56(sp)
50001adc:	03412483          	lw	s1,52(sp)
50001ae0:	03012903          	lw	s2,48(sp)
50001ae4:	02c12983          	lw	s3,44(sp)
50001ae8:	02812a03          	lw	s4,40(sp)
50001aec:	02412a83          	lw	s5,36(sp)
50001af0:	02012b03          	lw	s6,32(sp)
50001af4:	01c12b83          	lw	s7,28(sp)
50001af8:	01812c03          	lw	s8,24(sp)
50001afc:	01412c83          	lw	s9,20(sp)
50001b00:	01012d03          	lw	s10,16(sp)
50001b04:	00c12d83          	lw	s11,12(sp)
50001b08:	04010113          	addi	sp,sp,64
50001b0c:	00008067          	ret

50001b10 <str_out>:
50001b10:	0005a703          	lw	a4,0(a1)
50001b14:	0085a783          	lw	a5,8(a1)
50001b18:	00070663          	beqz	a4,50001b24 <str_out+0x14>
50001b1c:	0045a683          	lw	a3,4(a1)
50001b20:	00d7c863          	blt	a5,a3,50001b30 <str_out+0x20>
50001b24:	00178793          	addi	a5,a5,1
50001b28:	00f5a423          	sw	a5,8(a1)
50001b2c:	00008067          	ret
50001b30:	fff68613          	addi	a2,a3,-1
50001b34:	00c79863          	bne	a5,a2,50001b44 <str_out+0x34>
50001b38:	00d5a423          	sw	a3,8(a1)
50001b3c:	000747a3          	p.sb	zero,a5(a4)
50001b40:	00008067          	ret
50001b44:	00178693          	addi	a3,a5,1
50001b48:	00d5a423          	sw	a3,8(a1)
50001b4c:	00a747a3          	p.sb	a0,a5(a4)
50001b50:	00008067          	ret

50001b54 <__printk_hook_install>:
50001b54:	510027b7          	lui	a5,0x51002
50001b58:	cca7a423          	sw	a0,-824(a5) # 51001cc8 <_char_out>
50001b5c:	00008067          	ret

50001b60 <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
50001b60:	fb010113          	addi	sp,sp,-80
50001b64:	04812423          	sw	s0,72(sp)
50001b68:	04912223          	sw	s1,68(sp)
50001b6c:	05212023          	sw	s2,64(sp)
50001b70:	03312e23          	sw	s3,60(sp)
50001b74:	03412c23          	sw	s4,56(sp)
50001b78:	03512a23          	sw	s5,52(sp)
50001b7c:	03612823          	sw	s6,48(sp)
50001b80:	03812423          	sw	s8,40(sp)
50001b84:	03912223          	sw	s9,36(sp)
50001b88:	04112623          	sw	ra,76(sp)
50001b8c:	03712623          	sw	s7,44(sp)
50001b90:	03a12023          	sw	s10,32(sp)
50001b94:	01b12e23          	sw	s11,28(sp)
50001b98:	00050413          	mv	s0,a0
50001b9c:	00058493          	mv	s1,a1
50001ba0:	00068c13          	mv	s8,a3
50001ba4:	00060a93          	mv	s5,a2
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
	int min_width = -1;
	int long_ctr = 0;
50001ba8:	00000a13          	li	s4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
	int min_width = -1;
50001bac:	fff00993          	li	s3,-1
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
50001bb0:	00000913          	li	s2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
50001bb4:	00000c93          	li	s9,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d;
				if (long_ctr < 2) {
50001bb8:	00100b13          	li	s6,1 # 1 <CONFIG_ARCH>
	int min_width = -1;
	int long_ctr = 0;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
50001bbc:	001ac50b          	p.lbu	a0,1(s5!)
50001bc0:	2e050a63          	beqz	a0,50001eb4 <_vprintk+0x354>
		if (!might_format) {
50001bc4:	000c9c63          	bnez	s9,50001bdc <_vprintk+0x7c>
			if (*fmt != '%') {
50001bc8:	02500793          	li	a5,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
50001bcc:	2cf50463          	beq	a0,a5,50001e94 <_vprintk+0x334>
				out((int)*fmt, ctx);
50001bd0:	00048593          	mv	a1,s1
50001bd4:	000400e7          	jalr	s0
50001bd8:	fe5ff06f          	j	50001bbc <_vprintk+0x5c>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001bdc:	06400713          	li	a4,100 # 64 <CONFIG_SYS_CLOCK_TICKS_PER_SEC>
50001be0:	0ee50a63          	beq	a0,a4,50001cd4 <_vprintk+0x174>
50001be4:	04a76e63          	bltu	a4,a0,50001c40 <_vprintk+0xe0>
50001be8:	03900793          	li	a5,57 # 39 <__NANO_ESF_a4_OFFSET+0x1>
50001bec:	02a7e663          	bltu	a5,a0,50001c18 <_vprintk+0xb8>
50001bf0:	03100793          	li	a5,49 # 31 <__NANO_ESF_a2_OFFSET+0x1>
50001bf4:	0af57c63          	bleu	a5,a0,50001cac <_vprintk+0x14c>
50001bf8:	02d00793          	li	a5,45 # 2d <__NANO_ESF_a1_OFFSET+0x1>
50001bfc:	08f50e63          	beq	a0,a5,50001c98 <_vprintk+0x138>
50001c00:	03000793          	li	a5,48 # 30 <__NANO_ESF_a2_OFFSET>
50001c04:	08f50e63          	beq	a0,a5,50001ca0 <_vprintk+0x140>
50001c08:	02500793          	li	a5,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
50001c0c:	26f51463          	bne	a0,a5,50001e74 <_vprintk+0x314>

				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
50001c10:	00048593          	mv	a1,s1
50001c14:	2740006f          	j	50001e88 <_vprintk+0x328>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001c18:	05800793          	li	a5,88 # 58 <__NANO_ESF_lpcount0_OFFSET>
50001c1c:	14f50c63          	beq	a0,a5,50001d74 <_vprintk+0x214>
50001c20:	06300793          	li	a5,99 # 63 <__NANO_ESF_lpend1_OFFSET+0x3>
50001c24:	24f51863          	bne	a0,a5,50001e74 <_vprintk+0x314>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
50001c28:	000c2503          	lw	a0,0(s8)
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
50001c2c:	004c0b93          	addi	s7,s8,4

				out(c, ctx);
50001c30:	00048593          	mv	a1,s1
50001c34:	000400e7          	jalr	s0
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
50001c38:	000b8c13          	mv	s8,s7
50001c3c:	2500006f          	j	50001e8c <_vprintk+0x32c>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001c40:	07000793          	li	a5,112 # 70 <_K_THREAD_NO_FLOAT_SIZEOF>
50001c44:	10f50863          	beq	a0,a5,50001d54 <_vprintk+0x1f4>
50001c48:	00a7ee63          	bltu	a5,a0,50001c64 <_vprintk+0x104>
50001c4c:	06900793          	li	a5,105 # 69 <___thread_t_arch_OFFSET+0x1>
50001c50:	08f50263          	beq	a0,a5,50001cd4 <_vprintk+0x174>
50001c54:	06c00793          	li	a5,108 # 6c <K_THREAD_SIZEOF>
50001c58:	06f50a63          	beq	a0,a5,50001ccc <_vprintk+0x16c>
50001c5c:	06800793          	li	a5,104 # 68 <___thread_t_arch_OFFSET>
50001c60:	0300006f          	j	50001c90 <_vprintk+0x130>
50001c64:	07500713          	li	a4,117 # 75 <_K_THREAD_NO_FLOAT_SIZEOF+0x5>
50001c68:	0ae50a63          	beq	a0,a4,50001d1c <_vprintk+0x1bc>
50001c6c:	00a76c63          	bltu	a4,a0,50001c84 <_vprintk+0x124>
50001c70:	07300793          	li	a5,115 # 73 <_K_THREAD_NO_FLOAT_SIZEOF+0x3>
50001c74:	20f51063          	bne	a0,a5,50001e74 <_vprintk+0x314>
				_printk_hex_ulong(out, ctx, x, padding,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
50001c78:	004c0c93          	addi	s9,s8,4
50001c7c:	000c2b83          	lw	s7,0(s8)

				while (*s)
50001c80:	1d80006f          	j	50001e58 <_vprintk+0x2f8>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001c84:	07800793          	li	a5,120 # 78 <_K_THREAD_NO_FLOAT_SIZEOF+0x8>
50001c88:	0ef50663          	beq	a0,a5,50001d74 <_vprintk+0x214>
50001c8c:	07a00793          	li	a5,122 # 7a <_K_THREAD_NO_FLOAT_SIZEOF+0xa>
50001c90:	20f50863          	beq	a0,a5,50001ea0 <_vprintk+0x340>
50001c94:	1e00006f          	j	50001e74 <_vprintk+0x314>
			case '-':
				padding = PAD_SPACE_AFTER;
50001c98:	00300913          	li	s2,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
50001c9c:	2040006f          	j	50001ea0 <_vprintk+0x340>
				goto still_might_format;
			case '0':
				if (min_width < 0 && padding == PAD_NONE) {
50001ca0:	0009d863          	bgez	s3,50001cb0 <_vprintk+0x150>
50001ca4:	20090263          	beqz	s2,50001ea8 <_vprintk+0x348>
50001ca8:	0100006f          	j	50001cb8 <_vprintk+0x158>
					padding = PAD_ZERO_BEFORE;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
50001cac:	0009c663          	bltz	s3,50001cb8 <_vprintk+0x158>
					min_width = *fmt - '0';
				} else {
					min_width = 10 * min_width + *fmt - '0';
50001cb0:	00a00793          	li	a5,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50001cb4:	42f98533          	p.mac	a0,s3,a5
50001cb8:	fd050993          	addi	s3,a0,-48
50001cbc:	00100c93          	li	s9,1 # 1 <CONFIG_ARCH>
				}

				if (padding == PAD_NONE) {
50001cc0:	ee091ee3          	bnez	s2,50001bbc <_vprintk+0x5c>
					padding = PAD_SPACE_BEFORE;
50001cc4:	00200913          	li	s2,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50001cc8:	ef5ff06f          	j	50001bbc <_vprintk+0x5c>
				}
				goto still_might_format;
			case 'l':
				long_ctr++;
50001ccc:	001a0a13          	addi	s4,s4,1
50001cd0:	1d00006f          	j	50001ea0 <_vprintk+0x340>
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d;
				if (long_ctr < 2) {
50001cd4:	014b4863          	blt	s6,s4,50001ce4 <_vprintk+0x184>
					d = va_arg(ap, long);
50001cd8:	000c2b83          	lw	s7,0(s8)
50001cdc:	004c0c13          	addi	s8,s8,4
50001ce0:	0140006f          	j	50001cf4 <_vprintk+0x194>
				} else {
					d = (long)va_arg(ap, long long);
50001ce4:	007c0793          	addi	a5,s8,7
50001ce8:	c407b7b3          	p.bclr	a5,a5,2,0
50001cec:	0007ab83          	lw	s7,0(a5)
50001cf0:	00878c13          	addi	s8,a5,8
				}

				if (d < 0) {
50001cf4:	000bdc63          	bgez	s7,50001d0c <_vprintk+0x1ac>
					out((int)'-', ctx);
50001cf8:	00048593          	mv	a1,s1
50001cfc:	02d00513          	li	a0,45 # 2d <__NANO_ESF_a1_OFFSET+0x1>
50001d00:	000400e7          	jalr	s0
					d = -d;
50001d04:	41700bb3          	neg	s7,s7
					min_width--;
50001d08:	fff98993          	addi	s3,s3,-1
				}
				_printk_dec_ulong(out, ctx, d, padding,
50001d0c:	00098713          	mv	a4,s3
50001d10:	00090693          	mv	a3,s2
50001d14:	000b8613          	mv	a2,s7
50001d18:	02c0006f          	j	50001d44 <_vprintk+0x1e4>
				break;
			}
			case 'u': {
				unsigned long u;

				if (long_ctr < 2) {
50001d1c:	014b4863          	blt	s6,s4,50001d2c <_vprintk+0x1cc>
					u = va_arg(ap, unsigned long);
50001d20:	000c2603          	lw	a2,0(s8)
50001d24:	004c0c13          	addi	s8,s8,4
50001d28:	0140006f          	j	50001d3c <_vprintk+0x1dc>
				} else {
					u = (unsigned long)va_arg(ap,
50001d2c:	007c0793          	addi	a5,s8,7
50001d30:	c407b7b3          	p.bclr	a5,a5,2,0
50001d34:	0007a603          	lw	a2,0(a5)
50001d38:	00878c13          	addi	s8,a5,8
							unsigned long long);
				}
				_printk_dec_ulong(out, ctx, u, padding,
50001d3c:	00098713          	mv	a4,s3
50001d40:	00090693          	mv	a3,s2
50001d44:	00048593          	mv	a1,s1
50001d48:	00040513          	mv	a0,s0
50001d4c:	c8dff0ef          	jal	500019d8 <_printk_dec_ulong>
50001d50:	13c0006f          	j	50001e8c <_vprintk+0x32c>
						  min_width);
				break;
			}
			case 'p':
				  out('0', ctx);
50001d54:	00048593          	mv	a1,s1
50001d58:	03000513          	li	a0,48 # 30 <__NANO_ESF_a2_OFFSET>
50001d5c:	000400e7          	jalr	s0
				  out('x', ctx);
50001d60:	00048593          	mv	a1,s1
50001d64:	07800513          	li	a0,120 # 78 <_K_THREAD_NO_FLOAT_SIZEOF+0x8>
50001d68:	000400e7          	jalr	s0
				  /* left-pad pointers with zeros */
				  padding = PAD_ZERO_BEFORE;
				  min_width = 8;
50001d6c:	00800993          	li	s3,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  padding = PAD_ZERO_BEFORE;
50001d70:	00100913          	li	s2,1 # 1 <CONFIG_ARCH>
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x;

				if (long_ctr < 2) {
50001d74:	014b4a63          	blt	s6,s4,50001d88 <_vprintk+0x228>
					x = va_arg(ap, unsigned long);
50001d78:	000c2703          	lw	a4,0(s8)
50001d7c:	004c0c13          	addi	s8,s8,4
50001d80:	00e12423          	sw	a4,8(sp)
50001d84:	0180006f          	j	50001d9c <_vprintk+0x23c>
				} else {
					x = (unsigned long)va_arg(ap,
50001d88:	007c0793          	addi	a5,s8,7
50001d8c:	c407b7b3          	p.bclr	a5,a5,2,0
50001d90:	00878c13          	addi	s8,a5,8
50001d94:	0007a783          	lw	a5,0(a5)
50001d98:	00f12423          	sw	a5,8(sp)
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
50001d9c:	00800d13          	li	s10,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
	int digits = 0;
50001da0:	00000b93          	li	s7,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
50001da4:	00000d93          	li	s11,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
50001da8:	000d0c93          	mv	s9,s10
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
	int digits = 0;

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
50001dac:	fffc8c93          	addi	s9,s9,-1
50001db0:	002c9513          	slli	a0,s9,0x2
50001db4:	00812783          	lw	a5,8(sp)
50001db8:	00a7d533          	srl	a0,a5,a0
50001dbc:	f6453533          	p.bclr	a0,a0,27,4

		if (nibble || found_largest_digit || size == 1) {
50001dc0:	00051863          	bnez	a0,50001dd0 <_vprintk+0x270>
50001dc4:	000d9c63          	bnez	s11,50001ddc <_vprintk+0x27c>
50001dc8:	020c9a63          	bnez	s9,50001dfc <_vprintk+0x29c>
50001dcc:	0100006f          	j	50001ddc <_vprintk+0x27c>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
50001dd0:	00900713          	li	a4,9 # 9 <___thread_base_t_thread_state_OFFSET>
50001dd4:	05700793          	li	a5,87 # 57 <__NANO_ESF_lpend0_OFFSET+0x3>
50001dd8:	00a76463          	bltu	a4,a0,50001de0 <_vprintk+0x280>
50001ddc:	03000793          	li	a5,48 # 30 <__NANO_ESF_a2_OFFSET>
			out((int)nibble, ctx);
50001de0:	00048593          	mv	a1,s1
50001de4:	00f50533          	add	a0,a0,a5
50001de8:	000400e7          	jalr	s0
			digits++;
50001dec:	001b8b93          	addi	s7,s7,1
50001df0:	01a12623          	sw	s10,12(sp)

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
50001df4:	00100d93          	li	s11,1 # 1 <CONFIG_ARCH>
50001df8:	0300006f          	j	50001e28 <_vprintk+0x2c8>
			out((int)nibble, ctx);
			digits++;
			continue;
		}

		if (remaining-- <= min_width) {
50001dfc:	fffd0793          	addi	a5,s10,-1
50001e00:	00f12623          	sw	a5,12(sp)
50001e04:	03a9c263          	blt	s3,s10,50001e28 <_vprintk+0x2c8>
			if (padding == PAD_ZERO_BEFORE) {
50001e08:	00193863          	p.bneimm	s2,1,50001e18 <_vprintk+0x2b8>
				out('0', ctx);
50001e0c:	00048593          	mv	a1,s1
50001e10:	03000513          	li	a0,48 # 30 <__NANO_ESF_a2_OFFSET>
50001e14:	0100006f          	j	50001e24 <_vprintk+0x2c4>
			} else if (padding == PAD_SPACE_BEFORE) {
50001e18:	00293863          	p.bneimm	s2,2,50001e28 <_vprintk+0x2c8>
				out(' ', ctx);
50001e1c:	00048593          	mv	a1,s1
50001e20:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
50001e24:	000400e7          	jalr	s0
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
	int digits = 0;

	for (; size; size--) {
50001e28:	000c8663          	beqz	s9,50001e34 <_vprintk+0x2d4>
50001e2c:	00c12d03          	lw	s10,12(sp)
50001e30:	f7dff06f          	j	50001dac <_vprintk+0x24c>
				out(' ', ctx);
			}
		}
	}

	if (padding == PAD_SPACE_AFTER) {
50001e34:	d83934e3          	p.bneimm	s2,3,50001bbc <_vprintk+0x5c>
50001e38:	00199793          	slli	a5,s3,0x1
50001e3c:	41778bb3          	sub	s7,a5,s7
		remaining = min_width * 2 - digits;
		while (remaining-- > 0) {
50001e40:	05705663          	blez	s7,50001e8c <_vprintk+0x32c>
			out(' ', ctx);
50001e44:	00048593          	mv	a1,s1
50001e48:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
50001e4c:	000400e7          	jalr	s0
50001e50:	fffb8b93          	addi	s7,s7,-1
50001e54:	fedff06f          	j	50001e40 <_vprintk+0x2e0>
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
50001e58:	001bc50b          	p.lbu	a0,1(s7!)
50001e5c:	00050863          	beqz	a0,50001e6c <_vprintk+0x30c>
					out((int)(*s++), ctx);
50001e60:	00048593          	mv	a1,s1
50001e64:	000400e7          	jalr	s0
50001e68:	ff1ff06f          	j	50001e58 <_vprintk+0x2f8>
				_printk_hex_ulong(out, ctx, x, padding,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
50001e6c:	000c8c13          	mv	s8,s9
50001e70:	01c0006f          	j	50001e8c <_vprintk+0x32c>
			case '%': {
				out((int)'%', ctx);
				break;
			}
			default:
				out((int)'%', ctx);
50001e74:	00048593          	mv	a1,s1
50001e78:	02500513          	li	a0,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
50001e7c:	000400e7          	jalr	s0
				out((int)*fmt, ctx);
50001e80:	fffac503          	lbu	a0,-1(s5)
50001e84:	00048593          	mv	a1,s1
50001e88:	000400e7          	jalr	s0
				break;
			}
			might_format = 0;
50001e8c:	00000c93          	li	s9,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
50001e90:	d2dff06f          	j	50001bbc <_vprintk+0x5c>
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
50001e94:	00000a13          	li	s4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
50001e98:	fff00993          	li	s3,-1
				padding = PAD_NONE;
50001e9c:	00000913          	li	s2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001ea0:	00100c93          	li	s9,1 # 1 <CONFIG_ARCH>
50001ea4:	d19ff06f          	j	50001bbc <_vprintk+0x5c>
			case '-':
				padding = PAD_SPACE_AFTER;
				goto still_might_format;
			case '0':
				if (min_width < 0 && padding == PAD_NONE) {
					padding = PAD_ZERO_BEFORE;
50001ea8:	00100913          	li	s2,1 # 1 <CONFIG_ARCH>
50001eac:	00090c93          	mv	s9,s2
50001eb0:	d0dff06f          	j	50001bbc <_vprintk+0x5c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
50001eb4:	04c12083          	lw	ra,76(sp)
50001eb8:	04812403          	lw	s0,72(sp)
50001ebc:	04412483          	lw	s1,68(sp)
50001ec0:	04012903          	lw	s2,64(sp)
50001ec4:	03c12983          	lw	s3,60(sp)
50001ec8:	03812a03          	lw	s4,56(sp)
50001ecc:	03412a83          	lw	s5,52(sp)
50001ed0:	03012b03          	lw	s6,48(sp)
50001ed4:	02c12b83          	lw	s7,44(sp)
50001ed8:	02812c03          	lw	s8,40(sp)
50001edc:	02412c83          	lw	s9,36(sp)
50001ee0:	02012d03          	lw	s10,32(sp)
50001ee4:	01c12d83          	lw	s11,28(sp)
50001ee8:	05010113          	addi	sp,sp,80
50001eec:	00008067          	ret

50001ef0 <vprintk>:
	ctx->count++;
	return _char_out(c);
}

int vprintk(const char *fmt, va_list ap)
{
50001ef0:	fe010113          	addi	sp,sp,-32
	struct out_context ctx = { 0 };

	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
50001ef4:	00050613          	mv	a2,a0
50001ef8:	50002537          	lui	a0,0x50002
50001efc:	00058693          	mv	a3,a1
50001f00:	9c050513          	addi	a0,a0,-1600 # 500019c0 <char_out>
50001f04:	00c10593          	addi	a1,sp,12
	ctx->count++;
	return _char_out(c);
}

int vprintk(const char *fmt, va_list ap)
{
50001f08:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
50001f0c:	00012623          	sw	zero,12(sp)

	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
50001f10:	c51ff0ef          	jal	50001b60 <_vprintk>
	return ctx.count;
}
50001f14:	01c12083          	lw	ra,28(sp)
50001f18:	00c12503          	lw	a0,12(sp)
50001f1c:	02010113          	addi	sp,sp,32
50001f20:	00008067          	ret

50001f24 <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
50001f24:	fc010113          	addi	sp,sp,-64
50001f28:	02b12223          	sw	a1,36(sp)
	int ret;
	va_list ap;

	va_start(ap, fmt);
50001f2c:	02410593          	addi	a1,sp,36
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
50001f30:	00112e23          	sw	ra,28(sp)
50001f34:	02c12423          	sw	a2,40(sp)
50001f38:	02d12623          	sw	a3,44(sp)
50001f3c:	02e12823          	sw	a4,48(sp)
50001f40:	02f12a23          	sw	a5,52(sp)
50001f44:	03012c23          	sw	a6,56(sp)
50001f48:	03112e23          	sw	a7,60(sp)
	int ret;
	va_list ap;

	va_start(ap, fmt);
50001f4c:	00b12623          	sw	a1,12(sp)
	ret = vprintk(fmt, ap);
50001f50:	fa1ff0ef          	jal	50001ef0 <vprintk>
	va_end(ap);

	return ret;
}
50001f54:	01c12083          	lw	ra,28(sp)
50001f58:	04010113          	addi	sp,sp,64
50001f5c:	00008067          	ret

50001f60 <snprintk>:

	return c;
}

int snprintk(char *str, size_t size, const char *fmt, ...)
{
50001f60:	fc010113          	addi	sp,sp,-64
50001f64:	00812c23          	sw	s0,24(sp)
	struct str_context ctx = { str, size, 0 };
50001f68:	00a12223          	sw	a0,4(sp)

	return c;
}

int snprintk(char *str, size_t size, const char *fmt, ...)
{
50001f6c:	00050413          	mv	s0,a0
	struct str_context ctx = { str, size, 0 };
	va_list ap;

	va_start(ap, fmt);
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
50001f70:	50002537          	lui	a0,0x50002

	return c;
}

int snprintk(char *str, size_t size, const char *fmt, ...)
{
50001f74:	02d12623          	sw	a3,44(sp)
	struct str_context ctx = { str, size, 0 };
50001f78:	00b12423          	sw	a1,8(sp)
	va_list ap;

	va_start(ap, fmt);
50001f7c:	02c10693          	addi	a3,sp,44
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
50001f80:	b1050513          	addi	a0,a0,-1264 # 50001b10 <str_out>
50001f84:	00410593          	addi	a1,sp,4

	return c;
}

int snprintk(char *str, size_t size, const char *fmt, ...)
{
50001f88:	02f12a23          	sw	a5,52(sp)
50001f8c:	00112e23          	sw	ra,28(sp)
50001f90:	02e12823          	sw	a4,48(sp)
50001f94:	03012c23          	sw	a6,56(sp)
50001f98:	03112e23          	sw	a7,60(sp)
	struct str_context ctx = { str, size, 0 };
50001f9c:	00012623          	sw	zero,12(sp)
	va_list ap;

	va_start(ap, fmt);
50001fa0:	00d12023          	sw	a3,0(sp)
	_vprintk((out_func_t)str_out, &ctx, fmt, ap);
50001fa4:	bbdff0ef          	jal	50001b60 <_vprintk>
	va_end(ap);

	if (ctx.count < ctx.max) {
50001fa8:	00c12503          	lw	a0,12(sp)
50001fac:	00812783          	lw	a5,8(sp)
50001fb0:	00f55463          	ble	a5,a0,50001fb8 <snprintk+0x58>
		str[ctx.count] = '\0';
50001fb4:	00044523          	p.sb	zero,a0(s0)
	}

	return ctx.count;
}
50001fb8:	01c12083          	lw	ra,28(sp)
50001fbc:	01812403          	lw	s0,24(sp)
50001fc0:	04010113          	addi	sp,sp,64
50001fc4:	00008067          	ret

50001fc8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_UART_NS16550_PORT_1_OPTIONS, 0);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BLUETOOTH_DEVICE_APPEARANCE, 0);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_SHOW_TAGS, 1);
50001fc8:	00008067          	ret

50001fcc <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

uint32_t _copy(uint8_t *to, uint32_t to_len,
	       const uint8_t *from, uint32_t from_len)
{
	if (from_len <= to_len) {
50001fcc:	02d5ea63          	bltu	a1,a3,50002000 <_copy+0x34>
#define MASK_MOST_SIG_BIT 0x80
#define MASK_TWENTY_SEVEN 0x1b

uint32_t _copy(uint8_t *to, uint32_t to_len,
	       const uint8_t *from, uint32_t from_len)
{
50001fd0:	ff010113          	addi	sp,sp,-16
50001fd4:	00060593          	mv	a1,a2
	if (from_len <= to_len) {
		(void)memcpy(to, from, from_len);
50001fd8:	00068613          	mv	a2,a3
#define MASK_MOST_SIG_BIT 0x80
#define MASK_TWENTY_SEVEN 0x1b

uint32_t _copy(uint8_t *to, uint32_t to_len,
	       const uint8_t *from, uint32_t from_len)
{
50001fdc:	00112623          	sw	ra,12(sp)
50001fe0:	00812423          	sw	s0,8(sp)
50001fe4:	00068413          	mv	s0,a3
	if (from_len <= to_len) {
		(void)memcpy(to, from, from_len);
50001fe8:	c58fe0ef          	jal	50000440 <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
50001fec:	00c12083          	lw	ra,12(sp)
uint32_t _copy(uint8_t *to, uint32_t to_len,
	       const uint8_t *from, uint32_t from_len)
{
	if (from_len <= to_len) {
		(void)memcpy(to, from, from_len);
		return from_len;
50001ff0:	00040513          	mv	a0,s0
	} else {
		return TC_CRYPTO_FAIL;
	}
}
50001ff4:	00812403          	lw	s0,8(sp)
50001ff8:	01010113          	addi	sp,sp,16
50001ffc:	00008067          	ret
{
	if (from_len <= to_len) {
		(void)memcpy(to, from, from_len);
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
50002000:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002004:	00008067          	ret

50002008 <_set>:
	}
}

void _set(void *to, uint8_t val, uint32_t len)
{
	(void)memset(to, val, len);
50002008:	cd0fe06f          	j	500004d8 <memset>

5000200c <compress>:
	uint32_t t1, t2;
	uint32_t work_space[16];
	uint32_t n;
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
5000200c:	00052783          	lw	a5,0(a0)
	n |= ((uint32_t)(*((*c)++)));
	return n;
}

static void compress(uint32_t *iv, const uint8_t *data)
{
50002010:	f7010113          	addi	sp,sp,-144
50002014:	07812623          	sw	s8,108(sp)
	uint32_t t1, t2;
	uint32_t work_space[16];
	uint32_t n;
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
50002018:	00f12023          	sw	a5,0(sp)
5000201c:	00452c03          	lw	s8,4(a0)
50002020:	00852783          	lw	a5,8(a0)
50002024:	01812223          	sw	s8,4(sp)
50002028:	00f12423          	sw	a5,8(sp)
5000202c:	00c52c03          	lw	s8,12(a0)
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
50002030:	01052783          	lw	a5,16(a0)
	uint32_t t1, t2;
	uint32_t work_space[16];
	uint32_t n;
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
50002034:	01812623          	sw	s8,12(sp)
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
50002038:	00f12823          	sw	a5,16(sp)
5000203c:	01452c03          	lw	s8,20(a0)
50002040:	01852783          	lw	a5,24(a0)
50002044:	01812a23          	sw	s8,20(sp)
50002048:	00f12c23          	sw	a5,24(sp)
5000204c:	01c52c03          	lw	s8,28(a0)
	n |= ((uint32_t)(*((*c)++)));
	return n;
}

static void compress(uint32_t *iv, const uint8_t *data)
{
50002050:	08812623          	sw	s0,140(sp)
50002054:	08912423          	sw	s1,136(sp)
50002058:	09212223          	sw	s2,132(sp)
5000205c:	09312023          	sw	s3,128(sp)
50002060:	07412e23          	sw	s4,124(sp)
50002064:	07512c23          	sw	s5,120(sp)
50002068:	07612a23          	sw	s6,116(sp)
5000206c:	07712823          	sw	s7,112(sp)
50002070:	07912423          	sw	s9,104(sp)
50002074:	07a12223          	sw	s10,100(sp)
50002078:	07b12023          	sw	s11,96(sp)
	uint32_t work_space[16];
	uint32_t n;
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
5000207c:	01812e23          	sw	s8,28(sp)
50002080:	510007b7          	lui	a5,0x51000
50002084:	01812e03          	lw	t3,24(sp)
50002088:	01412803          	lw	a6,20(sp)
5000208c:	01012703          	lw	a4,16(sp)
	uint32_t t1, t2;
	uint32_t work_space[16];
	uint32_t n;
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
50002090:	00c12383          	lw	t2,12(sp)
50002094:	00812883          	lw	a7,8(sp)
50002098:	00412603          	lw	a2,4(sp)
5000209c:	00012683          	lw	a3,0(sp)
500020a0:	00158a13          	addi	s4,a1,1
500020a4:	00258913          	addi	s2,a1,2
500020a8:	00358993          	addi	s3,a1,3
500020ac:	02010493          	addi	s1,sp,32
500020b0:	72c78413          	addi	s0,a5,1836 # 5100072c <k256>
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
500020b4:	000c0293          	mv	t0,s8

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
500020b8:	00600d93          	li	s11,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
500020bc:	00b00d13          	li	s10,11 # b <___thread_base_t_sched_locked_OFFSET>
500020c0:	01900c93          	li	s9,25 # 19 <__NANO_ESF_t3_OFFSET+0x1>
		t2 = Sigma0(a) + Maj(a, b, c);
500020c4:	00200b93          	li	s7,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
500020c8:	00d00b13          	li	s6,13 # d <_DEVICE_STRUCT_SIZE+0x1>
500020cc:	01600a93          	li	s5,22 # 16 <__NANO_ESF_t2_OFFSET+0x2>
500020d0:	01000e93          	li	t4,16 # 10 <CONFIG_NUM_COOP_PRIORITIES>

static inline uint32_t BigEndian(const uint8_t **c)
{
	uint32_t n = 0;

	n = (((uint32_t)(*((*c)++))) << 24);
500020d4:	0045cf0b          	p.lbu	t5,4(a1!)
	n |= ((uint32_t)(*((*c)++)) << 16);
	n |= ((uint32_t)(*((*c)++)) << 8);
	n |= ((uint32_t)(*((*c)++)));
500020d8:	004a478b          	p.lbu	a5,4(s4!)
500020dc:	0049c30b          	p.lbu	t1,4(s3!)

static inline uint32_t BigEndian(const uint8_t **c)
{
	uint32_t n = 0;

	n = (((uint32_t)(*((*c)++))) << 24);
500020e0:	018f1f13          	slli	t5,t5,0x18
	n |= ((uint32_t)(*((*c)++)) << 16);
	n |= ((uint32_t)(*((*c)++)) << 8);
	n |= ((uint32_t)(*((*c)++)));
500020e4:	01e36333          	or	t1,t1,t5
500020e8:	01079793          	slli	a5,a5,0x10
500020ec:	0067e7b3          	or	a5,a5,t1
500020f0:	0049430b          	p.lbu	t1,4(s2!)
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
500020f4:	09a75f33          	p.ror	t5,a4,s10
	uint32_t n = 0;

	n = (((uint32_t)(*((*c)++))) << 24);
	n |= ((uint32_t)(*((*c)++)) << 16);
	n |= ((uint32_t)(*((*c)++)) << 8);
	n |= ((uint32_t)(*((*c)++)));
500020f8:	00831313          	slli	t1,t1,0x8
500020fc:	0067e333          	or	t1,a5,t1
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
50002100:	09b757b3          	p.ror	a5,a4,s11
50002104:	01e7c7b3          	xor	a5,a5,t5
50002108:	fff74f93          	not	t6,a4
5000210c:	09975f33          	p.ror	t5,a4,s9
50002110:	01e7c7b3          	xor	a5,a5,t5
50002114:	01cfffb3          	and	t6,t6,t3
50002118:	01077f33          	and	t5,a4,a6
5000211c:	01efcf33          	xor	t5,t6,t5
50002120:	00442c0b          	p.lw	s8,4(s0!)
50002124:	01e78f33          	add	t5,a5,t5
50002128:	018f0f33          	add	t5,t5,s8
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
5000212c:	0064a22b          	p.sw	t1,4(s1!)
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
		t2 = Sigma0(a) + Maj(a, b, c);
50002130:	0966dfb3          	p.ror	t6,a3,s6
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
50002134:	006f0333          	add	t1,t5,t1
		t2 = Sigma0(a) + Maj(a, b, c);
50002138:	0976df33          	p.ror	t5,a3,s7
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
5000213c:	005302b3          	add	t0,t1,t0
		t2 = Sigma0(a) + Maj(a, b, c);
50002140:	01ff4f33          	xor	t5,t5,t6
50002144:	0956d333          	p.ror	t1,a3,s5
50002148:	006f4f33          	xor	t5,t5,t1
5000214c:	00c8c333          	xor	t1,a7,a2
50002150:	00d37333          	and	t1,t1,a3
50002154:	011677b3          	and	a5,a2,a7
50002158:	00f34333          	xor	t1,t1,a5
5000215c:	006f0333          	add	t1,t5,t1
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
50002160:	00628333          	add	t1,t0,t1
	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
50002164:	00728f33          	add	t5,t0,t2
50002168:	00088393          	mv	t2,a7
5000216c:	000e0293          	mv	t0,t3
50002170:	fffe8e93          	addi	t4,t4,-1
50002174:	020e9e63          	bnez	t4,500021b0 <compress+0x1a4>
50002178:	510005b7          	lui	a1,0x51000
5000217c:	72c58593          	addi	a1,a1,1836 # 5100072c <k256>
50002180:	04058293          	addi	t0,a1,64
	uint32_t i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];

	for (i = 0; i < 16; ++i) {
50002184:	01000c13          	li	s8,16 # 10 <CONFIG_NUM_COOP_PRIORITIES>
		d = c; c = b; b = a; a = t1 + t2;
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
		s0 = sigma0(s0);
50002188:	01200d93          	li	s11,18 # 12 <CONFIG_NUM_COOP_PRIORITIES+0x2>
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);
5000218c:	01100d13          	li	s10,17 # 11 <CONFIG_NUM_COOP_PRIORITIES+0x1>
50002190:	01300c93          	li	s9,19 # 13 <CONFIG_NUM_COOP_PRIORITIES+0x3>

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
50002194:	00600b93          	li	s7,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50002198:	00b00b13          	li	s6,11 # b <___thread_base_t_sched_locked_OFFSET>
5000219c:	01900a93          	li	s5,25 # 19 <__NANO_ESF_t3_OFFSET+0x1>
		t2 = Sigma0(a) + Maj(a, b, c);
500021a0:	00d00a13          	li	s4,13 # d <_DEVICE_STRUCT_SIZE+0x1>
500021a4:	01600993          	li	s3,22 # 16 <__NANO_ESF_t2_OFFSET+0x2>
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	for ( ; i < 64; ++i) {
500021a8:	03000393          	li	t2,48 # 30 <__NANO_ESF_a2_OFFSET>
500021ac:	0380006f          	j	500021e4 <compress+0x1d8>
500021b0:	00080e13          	mv	t3,a6
500021b4:	00060893          	mv	a7,a2
500021b8:	00070813          	mv	a6,a4
500021bc:	00068613          	mv	a2,a3
	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
500021c0:	000f0713          	mv	a4,t5
		d = c; c = b; b = a; a = t1 + t2;
500021c4:	00030693          	mv	a3,t1
500021c8:	f0dff06f          	j	500020d4 <compress+0xc8>
500021cc:	00070813          	mv	a6,a4
500021d0:	00068613          	mv	a2,a3
500021d4:	000f0713          	mv	a4,t5
500021d8:	00030693          	mv	a3,t1
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
500021dc:	00048f13          	mv	t5,s1
		d = c; c = b; b = a; a = t1 + t2;
500021e0:	00058313          	mv	t1,a1
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
500021e4:	001c0913          	addi	s2,s8,1
500021e8:	f6493eb3          	p.bclr	t4,s2,27,4
500021ec:	06010793          	addi	a5,sp,96
500021f0:	002e9e93          	slli	t4,t4,0x2
500021f4:	01d78eb3          	add	t4,a5,t4
500021f8:	fc0eae83          	lw	t4,-64(t4)
		s0 = sigma0(s0);
500021fc:	00700593          	li	a1,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50002200:	08bed4b3          	p.ror	s1,t4,a1
50002204:	09bed7b3          	p.ror	a5,t4,s11
50002208:	00f4c4b3          	xor	s1,s1,a5
		s1 = work_space[(i+14)&0x0f];
5000220c:	00ec0793          	addi	a5,s8,14
50002210:	f647b7b3          	p.bclr	a5,a5,27,4
50002214:	06010593          	addi	a1,sp,96
50002218:	00279793          	slli	a5,a5,0x2
5000221c:	00f587b3          	add	a5,a1,a5
50002220:	fc07a783          	lw	a5,-64(a5)
		s1 = sigma1(s1);
50002224:	0997d5b3          	p.ror	a1,a5,s9
50002228:	09a7d433          	p.ror	s0,a5,s10
5000222c:	00b44433          	xor	s0,s0,a1

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
50002230:	009c0593          	addi	a1,s8,9
50002234:	f64c3fb3          	p.bclr	t6,s8,27,4
50002238:	f645b5b3          	p.bclr	a1,a1,27,4
5000223c:	06010c13          	addi	s8,sp,96
50002240:	00259593          	slli	a1,a1,0x2
50002244:	002f9f93          	slli	t6,t6,0x2
50002248:	01fc0fb3          	add	t6,s8,t6
5000224c:	00bc05b3          	add	a1,s8,a1
50002250:	fc05a583          	lw	a1,-64(a1)
50002254:	fc0fac03          	lw	s8,-64(t6)
		d = c; c = b; b = a; a = t1 + t2;
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
		s0 = sigma0(s0);
50002258:	003ede93          	srli	t4,t4,0x3
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
5000225c:	01d4ceb3          	xor	t4,s1,t4
50002260:	018585b3          	add	a1,a1,s8

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);
50002264:	00a7d793          	srli	a5,a5,0xa

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
50002268:	01d585b3          	add	a1,a1,t4
5000226c:	00f447b3          	xor	a5,s0,a5
50002270:	00f585b3          	add	a1,a1,a5
50002274:	fcbfa023          	sw	a1,-64(t6)
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
50002278:	096f5eb3          	p.ror	t4,t5,s6
5000227c:	097f5fb3          	p.ror	t6,t5,s7
50002280:	01dfcfb3          	xor	t6,t6,t4
50002284:	ffff4493          	not	s1,t5
50002288:	095f5eb3          	p.ror	t4,t5,s5
5000228c:	01dfcfb3          	xor	t6,t6,t4
50002290:	0104f4b3          	and	s1,s1,a6
50002294:	00ef7eb3          	and	t4,t5,a4
50002298:	0042a78b          	p.lw	a5,4(t0!)
5000229c:	01d4ceb3          	xor	t4,s1,t4
500022a0:	01df8eb3          	add	t4,t6,t4
500022a4:	00fe8eb3          	add	t4,t4,a5
500022a8:	00be8eb3          	add	t4,t4,a1
		t2 = Sigma0(a) + Maj(a, b, c);
500022ac:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
500022b0:	01ce8e33          	add	t3,t4,t3
		t2 = Sigma0(a) + Maj(a, b, c);
500022b4:	09435fb3          	p.ror	t6,t1,s4
500022b8:	08b35eb3          	p.ror	t4,t1,a1
500022bc:	01feceb3          	xor	t4,t4,t6
500022c0:	093355b3          	p.ror	a1,t1,s3
500022c4:	00beceb3          	xor	t4,t4,a1
500022c8:	00d645b3          	xor	a1,a2,a3
500022cc:	0065f5b3          	and	a1,a1,t1
500022d0:	00c6f7b3          	and	a5,a3,a2
500022d4:	00f5c5b3          	xor	a1,a1,a5
500022d8:	00be85b3          	add	a1,t4,a1
		h = g; g = f; f = e; e = d + t1;
500022dc:	011e04b3          	add	s1,t3,a7
		d = c; c = b; b = a; a = t1 + t2;
500022e0:	00be05b3          	add	a1,t3,a1
500022e4:	00060893          	mv	a7,a2
500022e8:	00080e13          	mv	t3,a6
500022ec:	00090c13          	mv	s8,s2
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	for ( ; i < 64; ++i) {
500022f0:	fff38393          	addi	t2,t2,-1
500022f4:	ec039ce3          	bnez	t2,500021cc <compress+0x1c0>
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
500022f8:	00012783          	lw	a5,0(sp)
500022fc:	00412c03          	lw	s8,4(sp)
50002300:	00b78e33          	add	t3,a5,a1
50002304:	006c0333          	add	t1,s8,t1
50002308:	00812583          	lw	a1,8(sp)
5000230c:	00c12783          	lw	a5,12(sp)
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
50002310:	01012c03          	lw	s8,16(sp)
50002314:	009c04b3          	add	s1,s8,s1
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
50002318:	00d586b3          	add	a3,a1,a3
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
5000231c:	01c12c03          	lw	s8,28(sp)
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
50002320:	00c78633          	add	a2,a5,a2
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
50002324:	01412583          	lw	a1,20(sp)
50002328:	01812783          	lw	a5,24(sp)
5000232c:	010c0833          	add	a6,s8,a6
50002330:	01e58f33          	add	t5,a1,t5
50002334:	00e78733          	add	a4,a5,a4
50002338:	00952823          	sw	s1,16(a0)
}
5000233c:	08c12403          	lw	s0,140(sp)
50002340:	08812483          	lw	s1,136(sp)
50002344:	08412903          	lw	s2,132(sp)
50002348:	08012983          	lw	s3,128(sp)
5000234c:	07c12a03          	lw	s4,124(sp)
50002350:	07812a83          	lw	s5,120(sp)
50002354:	07412b03          	lw	s6,116(sp)
50002358:	07012b83          	lw	s7,112(sp)
5000235c:	06c12c03          	lw	s8,108(sp)
50002360:	06812c83          	lw	s9,104(sp)
50002364:	06412d03          	lw	s10,100(sp)
50002368:	06012d83          	lw	s11,96(sp)
		t2 = Sigma0(a) + Maj(a, b, c);
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
5000236c:	01c52023          	sw	t3,0(a0)
50002370:	00652223          	sw	t1,4(a0)
50002374:	00d52423          	sw	a3,8(a0)
50002378:	00c52623          	sw	a2,12(a0)
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
5000237c:	01e52a23          	sw	t5,20(a0)
50002380:	00e52c23          	sw	a4,24(a0)
50002384:	01052e23          	sw	a6,28(a0)
}
50002388:	09010113          	addi	sp,sp,144
5000238c:	00008067          	ret

50002390 <tc_sha256_init>:
static void compress(uint32_t *iv, const uint8_t *data);

int32_t tc_sha256_init(TCSha256State_t s)
{
	/* input sanity check: */
	if (s == (TCSha256State_t) 0) {
50002390:	08050a63          	beqz	a0,50002424 <tc_sha256_init+0x94>
#include <tinycrypt/utils.h>

static void compress(uint32_t *iv, const uint8_t *data);

int32_t tc_sha256_init(TCSha256State_t s)
{
50002394:	ff010113          	addi	sp,sp,-16
	 * Setting the initial state values.
	 * These values correspond to the first 32 bits of the fractional parts
	 * of the square roots of the first 8 primes: 2, 3, 5, 7, 11, 13, 17
	 * and 19.
	 */
	_set((uint8_t *) s, 0x00, sizeof(*s));
50002398:	07000613          	li	a2,112 # 70 <_K_THREAD_NO_FLOAT_SIZEOF>
5000239c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
#include <tinycrypt/utils.h>

static void compress(uint32_t *iv, const uint8_t *data);

int32_t tc_sha256_init(TCSha256State_t s)
{
500023a0:	00112623          	sw	ra,12(sp)
500023a4:	00812423          	sw	s0,8(sp)
500023a8:	00050413          	mv	s0,a0
	 * Setting the initial state values.
	 * These values correspond to the first 32 bits of the fractional parts
	 * of the square roots of the first 8 primes: 2, 3, 5, 7, 11, 13, 17
	 * and 19.
	 */
	_set((uint8_t *) s, 0x00, sizeof(*s));
500023ac:	c5dff0ef          	jal	50002008 <_set>
	s->iv[0] = 0x6a09e667;
500023b0:	6a09e7b7          	lui	a5,0x6a09e
500023b4:	66778793          	addi	a5,a5,1639 # 6a09e667 <_end+0x1909a697>
500023b8:	00f42023          	sw	a5,0(s0)
	s->iv[1] = 0xbb67ae85;
500023bc:	bb67b7b7          	lui	a5,0xbb67b
500023c0:	e8578793          	addi	a5,a5,-379 # bb67ae85 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xbb67ae86>
500023c4:	00f42223          	sw	a5,4(s0)
	s->iv[2] = 0x3c6ef372;
500023c8:	3c6ef7b7          	lui	a5,0x3c6ef
500023cc:	37278793          	addi	a5,a5,882 # 3c6ef372 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x397402f2>
500023d0:	00f42423          	sw	a5,8(s0)
	s->iv[3] = 0xa54ff53a;
500023d4:	a54ff7b7          	lui	a5,0xa54ff
500023d8:	53a78793          	addi	a5,a5,1338 # a54ff53a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xa54ff53b>
500023dc:	00f42623          	sw	a5,12(s0)
	s->iv[4] = 0x510e527f;
500023e0:	510e57b7          	lui	a5,0x510e5
500023e4:	27f78793          	addi	a5,a5,639 # 510e527f <_end+0xe12af>
500023e8:	00f42823          	sw	a5,16(s0)
	s->iv[5] = 0x9b05688c;
500023ec:	9b0577b7          	lui	a5,0x9b057
500023f0:	88c78793          	addi	a5,a5,-1908 # 9b05688c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x9b05688d>
500023f4:	00f42a23          	sw	a5,20(s0)
	s->iv[6] = 0x1f83d9ab;
500023f8:	1f83e7b7          	lui	a5,0x1f83e
500023fc:	9ab78793          	addi	a5,a5,-1621 # 1f83d9ab <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1c88e92b>
50002400:	00f42c23          	sw	a5,24(s0)
	s->iv[7] = 0x5be0cd19;
50002404:	5be0d7b7          	lui	a5,0x5be0d
50002408:	d1978793          	addi	a5,a5,-743 # 5be0cd19 <_end+0xae08d49>

	return TC_CRYPTO_SUCCESS;
}
5000240c:	00c12083          	lw	ra,12(sp)
	s->iv[2] = 0x3c6ef372;
	s->iv[3] = 0xa54ff53a;
	s->iv[4] = 0x510e527f;
	s->iv[5] = 0x9b05688c;
	s->iv[6] = 0x1f83d9ab;
	s->iv[7] = 0x5be0cd19;
50002410:	00f42e23          	sw	a5,28(s0)

	return TC_CRYPTO_SUCCESS;
50002414:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
}
50002418:	00812403          	lw	s0,8(sp)
5000241c:	01010113          	addi	sp,sp,16
50002420:	00008067          	ret

int32_t tc_sha256_init(TCSha256State_t s)
{
	/* input sanity check: */
	if (s == (TCSha256State_t) 0) {
		return TC_CRYPTO_FAIL;
50002424:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002428:	00008067          	ret

5000242c <tc_sha256_update>:
}

int32_t tc_sha256_update(TCSha256State_t s, const uint8_t *data, size_t datalen)
{
	/* input sanity check: */
	if (s == (TCSha256State_t) 0 ||
5000242c:	08050c63          	beqz	a0,500024c4 <tc_sha256_update+0x98>

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_sha256_update(TCSha256State_t s, const uint8_t *data, size_t datalen)
{
50002430:	fe010113          	addi	sp,sp,-32
50002434:	00812c23          	sw	s0,24(sp)
50002438:	00912a23          	sw	s1,20(sp)
5000243c:	00050413          	mv	s0,a0
50002440:	00112e23          	sw	ra,28(sp)
50002444:	01212823          	sw	s2,16(sp)
50002448:	01312623          	sw	s3,12(sp)
5000244c:	01412423          	sw	s4,8(sp)
50002450:	00058493          	mv	s1,a1
	/* input sanity check: */
	if (s == (TCSha256State_t) 0 ||
	    data == (void *) 0) {
		return TC_CRYPTO_FAIL;
50002454:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
}

int32_t tc_sha256_update(TCSha256State_t s, const uint8_t *data, size_t datalen)
{
	/* input sanity check: */
	if (s == (TCSha256State_t) 0 ||
50002458:	06058a63          	beqz	a1,500024cc <tc_sha256_update+0xa0>
	    data == (void *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (datalen == 0) {
5000245c:	06060063          	beqz	a2,500024bc <tc_sha256_update+0x90>
50002460:	00c58933          	add	s2,a1,a2
		return TC_CRYPTO_SUCCESS;
	}

	while (datalen-- > 0) {
		s->leftover[s->leftover_offset++] = *(data++);
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
50002464:	03f00993          	li	s3,63 # 3f <CONFIG_UART_CONSOLE_INIT_PRIORITY+0x3>
			compress(s->iv, s->leftover);
50002468:	02840a13          	addi	s4,s0,40
5000246c:	04c0006f          	j	500024b8 <tc_sha256_update+0x8c>
	} else if (datalen == 0) {
		return TC_CRYPTO_SUCCESS;
	}

	while (datalen-- > 0) {
		s->leftover[s->leftover_offset++] = *(data++);
50002470:	06842783          	lw	a5,104(s0)
50002474:	00178713          	addi	a4,a5,1
50002478:	06e42423          	sw	a4,104(s0)
5000247c:	0014c68b          	p.lbu	a3,1(s1!)
50002480:	00f407b3          	add	a5,s0,a5
50002484:	02d78423          	sb	a3,40(a5)
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
50002488:	02e9f863          	bleu	a4,s3,500024b8 <tc_sha256_update+0x8c>
			compress(s->iv, s->leftover);
5000248c:	000a0593          	mv	a1,s4
50002490:	00040513          	mv	a0,s0
50002494:	b79ff0ef          	jal	5000200c <compress>
			s->leftover_offset = 0;
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
50002498:	02042783          	lw	a5,32(s0)
5000249c:	20078713          	addi	a4,a5,512
500024a0:	02442683          	lw	a3,36(s0)
500024a4:	00f737b3          	sltu	a5,a4,a5
500024a8:	00d787b3          	add	a5,a5,a3

	while (datalen-- > 0) {
		s->leftover[s->leftover_offset++] = *(data++);
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
			compress(s->iv, s->leftover);
			s->leftover_offset = 0;
500024ac:	06042423          	sw	zero,104(s0)
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
500024b0:	02e42023          	sw	a4,32(s0)
500024b4:	02f42223          	sw	a5,36(s0)
		return TC_CRYPTO_FAIL;
	} else if (datalen == 0) {
		return TC_CRYPTO_SUCCESS;
	}

	while (datalen-- > 0) {
500024b8:	fb249ce3          	bne	s1,s2,50002470 <tc_sha256_update+0x44>
	/* input sanity check: */
	if (s == (TCSha256State_t) 0 ||
	    data == (void *) 0) {
		return TC_CRYPTO_FAIL;
	} else if (datalen == 0) {
		return TC_CRYPTO_SUCCESS;
500024bc:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
500024c0:	00c0006f          	j	500024cc <tc_sha256_update+0xa0>
int32_t tc_sha256_update(TCSha256State_t s, const uint8_t *data, size_t datalen)
{
	/* input sanity check: */
	if (s == (TCSha256State_t) 0 ||
	    data == (void *) 0) {
		return TC_CRYPTO_FAIL;
500024c4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500024c8:	00008067          	ret
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
		}
	}

	return TC_CRYPTO_SUCCESS;
}
500024cc:	01c12083          	lw	ra,28(sp)
500024d0:	01812403          	lw	s0,24(sp)
500024d4:	01412483          	lw	s1,20(sp)
500024d8:	01012903          	lw	s2,16(sp)
500024dc:	00c12983          	lw	s3,12(sp)
500024e0:	00812a03          	lw	s4,8(sp)
500024e4:	02010113          	addi	sp,sp,32
500024e8:	00008067          	ret

500024ec <tc_sha256_final>:
int32_t tc_sha256_final(uint8_t *digest, TCSha256State_t s)
{
	uint32_t i;

	/* input sanity check: */
	if (digest == (uint8_t *) 0 ||
500024ec:	14050263          	beqz	a0,50002630 <tc_sha256_final+0x144>

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_sha256_final(uint8_t *digest, TCSha256State_t s)
{
500024f0:	ff010113          	addi	sp,sp,-16
500024f4:	00812423          	sw	s0,8(sp)
500024f8:	00912223          	sw	s1,4(sp)
500024fc:	00112623          	sw	ra,12(sp)
50002500:	00050493          	mv	s1,a0
50002504:	01212023          	sw	s2,0(sp)
50002508:	00058413          	mv	s0,a1
	uint32_t i;

	/* input sanity check: */
	if (digest == (uint8_t *) 0 ||
	    s == (TCSha256State_t) 0) {
		return TC_CRYPTO_FAIL;
5000250c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
int32_t tc_sha256_final(uint8_t *digest, TCSha256State_t s)
{
	uint32_t i;

	/* input sanity check: */
	if (digest == (uint8_t *) 0 ||
50002510:	12058463          	beqz	a1,50002638 <tc_sha256_final+0x14c>
	    s == (TCSha256State_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	s->bits_hashed += (s->leftover_offset << 3);
50002514:	0685a703          	lw	a4,104(a1)
50002518:	0205a783          	lw	a5,32(a1)
5000251c:	00371693          	slli	a3,a4,0x3
50002520:	00d786b3          	add	a3,a5,a3
50002524:	0245a603          	lw	a2,36(a1)
50002528:	00f6b7b3          	sltu	a5,a3,a5
5000252c:	00c787b3          	add	a5,a5,a2
50002530:	02f5a223          	sw	a5,36(a1)

	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
50002534:	00170513          	addi	a0,a4,1
50002538:	f8000793          	li	a5,-128 # ffffff80 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffff81>
5000253c:	00e58733          	add	a4,a1,a4
	if (digest == (uint8_t *) 0 ||
	    s == (TCSha256State_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	s->bits_hashed += (s->leftover_offset << 3);
50002540:	02d5a023          	sw	a3,32(a1)

	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
50002544:	06a5a423          	sw	a0,104(a1)
50002548:	02f70423          	sb	a5,40(a4)
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
5000254c:	03800793          	li	a5,56 # 38 <__NANO_ESF_a4_OFFSET>
50002550:	02a7f663          	bleu	a0,a5,5000257c <tc_sha256_final+0x90>
		/* there is not room for all the padding in this block */
		_set(s->leftover + s->leftover_offset, 0x00,
50002554:	02858913          	addi	s2,a1,40
50002558:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
5000255c:	40a60633          	sub	a2,a2,a0
50002560:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002564:	00a90533          	add	a0,s2,a0
50002568:	aa1ff0ef          	jal	50002008 <_set>
		     sizeof(s->leftover) - s->leftover_offset);
		compress(s->iv, s->leftover);
5000256c:	00090593          	mv	a1,s2
50002570:	00040513          	mv	a0,s0
50002574:	a99ff0ef          	jal	5000200c <compress>
		s->leftover_offset = 0;
50002578:	06042423          	sw	zero,104(s0)
	}

	/* add the padding and the length in big-Endian format */
	_set(s->leftover + s->leftover_offset, 0x00,
5000257c:	06842503          	lw	a0,104(s0)
50002580:	02840913          	addi	s2,s0,40
50002584:	03800613          	li	a2,56 # 38 <__NANO_ESF_a4_OFFSET>
50002588:	40a60633          	sub	a2,a2,a0
5000258c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002590:	00a90533          	add	a0,s2,a0
50002594:	a75ff0ef          	jal	50002008 <_set>
	     sizeof(s->leftover) - 8 - s->leftover_offset);
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
50002598:	02042703          	lw	a4,32(s0)
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
5000259c:	00875693          	srli	a3,a4,0x8
	}

	/* add the padding and the length in big-Endian format */
	_set(s->leftover + s->leftover_offset, 0x00,
	     sizeof(s->leftover) - 8 - s->leftover_offset);
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
500025a0:	02442783          	lw	a5,36(s0)
500025a4:	06e403a3          	sb	a4,103(s0)
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
500025a8:	06d40323          	sb	a3,102(s0)
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
500025ac:	01075693          	srli	a3,a4,0x10
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
500025b0:	01875713          	srli	a4,a4,0x18
500025b4:	06e40223          	sb	a4,100(s0)
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
500025b8:	0087d713          	srli	a4,a5,0x8
	     sizeof(s->leftover) - 8 - s->leftover_offset);
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
500025bc:	06f401a3          	sb	a5,99(s0)
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
500025c0:	06e40123          	sb	a4,98(s0)
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
500025c4:	0107d713          	srli	a4,a5,0x10
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
500025c8:	0187d793          	srli	a5,a5,0x18
	/* add the padding and the length in big-Endian format */
	_set(s->leftover + s->leftover_offset, 0x00,
	     sizeof(s->leftover) - 8 - s->leftover_offset);
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
500025cc:	06d402a3          	sb	a3,101(s0)
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
500025d0:	06e400a3          	sb	a4,97(s0)
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);

	/* hash the padding and length */
	compress(s->iv, s->leftover);
500025d4:	00090593          	mv	a1,s2
500025d8:	00040513          	mv	a0,s0
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
500025dc:	06f40023          	sb	a5,96(s0)

	/* hash the padding and length */
	compress(s->iv, s->leftover);
500025e0:	a2dff0ef          	jal	5000200c <compress>
500025e4:	00040513          	mv	a0,s0
500025e8:	00148593          	addi	a1,s1,1
500025ec:	00248613          	addi	a2,s1,2
500025f0:	00348693          	addi	a3,s1,3
500025f4:	008850fb          	lp.setupi	x1,8,50002614 <tc_sha256_final+0x128>

	/* copy the iv out to digest */
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
		uint32_t t = *((uint32_t *) &s->iv[i]);
500025f8:	0045278b          	p.lw	a5,4(a0!)
		*digest++ = (uint8_t)(t >> 24);
500025fc:	0187d813          	srli	a6,a5,0x18
50002600:	0104822b          	p.sb	a6,4(s1!)
		*digest++ = (uint8_t)(t >> 16);
50002604:	0107d813          	srli	a6,a5,0x10
50002608:	0105822b          	p.sb	a6,4(a1!)
		*digest++ = (uint8_t)(t >> 8);
5000260c:	0087d813          	srli	a6,a5,0x8
50002610:	0106022b          	p.sb	a6,4(a2!)
		*digest++ = (uint8_t)(t);
50002614:	00f6822b          	p.sb	a5,4(a3!)
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
50002618:	00040513          	mv	a0,s0
5000261c:	07000613          	li	a2,112 # 70 <_K_THREAD_NO_FLOAT_SIZEOF>
50002620:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002624:	9e5ff0ef          	jal	50002008 <_set>

	return TC_CRYPTO_SUCCESS;
50002628:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
5000262c:	00c0006f          	j	50002638 <tc_sha256_final+0x14c>
	uint32_t i;

	/* input sanity check: */
	if (digest == (uint8_t *) 0 ||
	    s == (TCSha256State_t) 0) {
		return TC_CRYPTO_FAIL;
50002630:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002634:	00008067          	ret

	/* destroy the current state */
	_set(s, 0, sizeof(*s));

	return TC_CRYPTO_SUCCESS;
}
50002638:	00c12083          	lw	ra,12(sp)
5000263c:	00812403          	lw	s0,8(sp)
50002640:	00412483          	lw	s1,4(sp)
50002644:	00012903          	lw	s2,0(sp)
50002648:	01010113          	addi	sp,sp,16
5000264c:	00008067          	ret

50002650 <rekey>:
#include <tinycrypt/hmac.h>
#include <tinycrypt/constants.h>
#include <tinycrypt/utils.h>

static void rekey(uint8_t *key, const uint8_t *new_key, uint32_t key_size)
{
50002650:	04050813          	addi	a6,a0,64
	const uint8_t inner_pad = (uint8_t) 0x36;
	const uint8_t outer_pad = (uint8_t) 0x5c;
	uint32_t i;

	for (i = 0; i < key_size; ++i) {
50002654:	00050693          	mv	a3,a0
50002658:	00160793          	addi	a5,a2,1
5000265c:	fff78793          	addi	a5,a5,-1
50002660:	00079463          	bnez	a5,50002668 <rekey+0x18>
50002664:	0240006f          	j	50002688 <rekey+0x38>
50002668:	00058893          	mv	a7,a1
		key[i] = inner_pad ^ new_key[i];
5000266c:	0015870b          	p.lb	a4,1(a1!)
50002670:	03674713          	xori	a4,a4,54
50002674:	00e680ab          	p.sb	a4,1(a3!)
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
50002678:	0008c703          	lbu	a4,0(a7)
5000267c:	05c74713          	xori	a4,a4,92
50002680:	00e800ab          	p.sb	a4,1(a6!)
50002684:	fd9ff06f          	j	5000265c <rekey+0xc>
50002688:	00c50733          	add	a4,a0,a2
5000268c:	04060793          	addi	a5,a2,64
50002690:	00f507b3          	add	a5,a0,a5
50002694:	04000813          	li	a6,64 # 40 <__NANO_ESF_a6_OFFSET>
	}
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
50002698:	40e50533          	sub	a0,a0,a4
5000269c:	03600693          	li	a3,54 # 36 <__NANO_ESF_a3_OFFSET+0x2>
500026a0:	05c00593          	li	a1,92 # 5c <__NANO_ESF_lpstart1_OFFSET>
500026a4:	04150513          	addi	a0,a0,65
500026a8:	00c87a63          	bleu	a2,a6,500026bc <rekey+0x6c>
500026ac:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
500026b0:	00c0006f          	j	500026bc <rekey+0x6c>
500026b4:	00d700ab          	p.sb	a3,1(a4!)
500026b8:	00b780ab          	p.sb	a1,1(a5!)

	for (i = 0; i < key_size; ++i) {
		key[i] = inner_pad ^ new_key[i];
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
	}
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
500026bc:	fff50513          	addi	a0,a0,-1
500026c0:	fe051ae3          	bnez	a0,500026b4 <rekey+0x64>
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
	}
}
500026c4:	00008067          	ret

500026c8 <tc_hmac_set_key>:
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0 ||
	    key == (const uint8_t *) 0 ||
	    key_size == 0) {
		return TC_CRYPTO_FAIL;
500026c8:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
int32_t tc_hmac_set_key(TCHmacState_t ctx,
			const uint8_t *key,
			uint32_t key_size)
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0 ||
500026cc:	0e050063          	beqz	a0,500027ac <tc_hmac_set_key+0xe4>
500026d0:	0c058e63          	beqz	a1,500027ac <tc_hmac_set_key+0xe4>
	    key == (const uint8_t *) 0 ||
500026d4:	0c060c63          	beqz	a2,500027ac <tc_hmac_set_key+0xe4>
	    key_size == 0) {
		return TC_CRYPTO_FAIL;
	}

	const uint8_t dummy_key[key_size];
500026d8:	00f60793          	addi	a5,a2,15
}

int32_t tc_hmac_set_key(TCHmacState_t ctx,
			const uint8_t *key,
			uint32_t key_size)
{
500026dc:	ef010113          	addi	sp,sp,-272
	    key == (const uint8_t *) 0 ||
	    key_size == 0) {
		return TC_CRYPTO_FAIL;
	}

	const uint8_t dummy_key[key_size];
500026e0:	c607b7b3          	p.bclr	a5,a5,3,0
}

int32_t tc_hmac_set_key(TCHmacState_t ctx,
			const uint8_t *key,
			uint32_t key_size)
{
500026e4:	10812423          	sw	s0,264(sp)
500026e8:	10912223          	sw	s1,260(sp)
500026ec:	11212023          	sw	s2,256(sp)
500026f0:	0f312e23          	sw	s3,252(sp)
500026f4:	0f412c23          	sw	s4,248(sp)
500026f8:	10112623          	sw	ra,268(sp)
500026fc:	11010413          	addi	s0,sp,272
	    key == (const uint8_t *) 0 ||
	    key_size == 0) {
		return TC_CRYPTO_FAIL;
	}

	const uint8_t dummy_key[key_size];
50002700:	40f10133          	sub	sp,sp,a5
	struct tc_hmac_state_struct dummy_state;

	if (key_size <= TC_SHA256_BLOCK_SIZE) {
50002704:	04000793          	li	a5,64 # 40 <__NANO_ESF_a6_OFFSET>
50002708:	00050913          	mv	s2,a0
5000270c:	00060493          	mv	s1,a2
50002710:	00058993          	mv	s3,a1
50002714:	07050a13          	addi	s4,a0,112
50002718:	02c7ea63          	bltu	a5,a2,5000274c <tc_hmac_set_key+0x84>
		 * certain timing attacks. Without these dummy calls,
		 * adversaries would be able to learn whether the key_size is
		 * greater than TC_SHA256_BLOCK_SIZE by measuring the time
		 * consumed in this process.
		 */
		(void)tc_sha256_init(&dummy_state.hash_state);
5000271c:	ef040513          	addi	a0,s0,-272
50002720:	c71ff0ef          	jal	50002390 <tc_sha256_init>
		(void)tc_sha256_update(&dummy_state.hash_state,
50002724:	00048613          	mv	a2,s1
50002728:	00010593          	mv	a1,sp
5000272c:	ef040513          	addi	a0,s0,-272
50002730:	cfdff0ef          	jal	5000242c <tc_sha256_update>
				       dummy_key,
				       key_size);
		(void)tc_sha256_final(&dummy_state.key[TC_SHA256_DIGEST_SIZE],
50002734:	ef040593          	addi	a1,s0,-272
50002738:	f8040513          	addi	a0,s0,-128
5000273c:	db1ff0ef          	jal	500024ec <tc_sha256_final>
				      &dummy_state.hash_state);

		/* Actual code for when key_size <= TC_SHA256_BLOCK_SIZE: */
		rekey(ctx->key, key, key_size);
50002740:	00048613          	mv	a2,s1
50002744:	00098593          	mv	a1,s3
50002748:	0300006f          	j	50002778 <tc_hmac_set_key+0xb0>
	} else {
		(void)tc_sha256_init(&ctx->hash_state);
5000274c:	c45ff0ef          	jal	50002390 <tc_sha256_init>
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
50002750:	00048613          	mv	a2,s1
50002754:	00098593          	mv	a1,s3
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
50002758:	09090493          	addi	s1,s2,144

		/* Actual code for when key_size <= TC_SHA256_BLOCK_SIZE: */
		rekey(ctx->key, key, key_size);
	} else {
		(void)tc_sha256_init(&ctx->hash_state);
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
5000275c:	00090513          	mv	a0,s2
50002760:	ccdff0ef          	jal	5000242c <tc_sha256_update>
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
50002764:	00090593          	mv	a1,s2
50002768:	00048513          	mv	a0,s1
5000276c:	d81ff0ef          	jal	500024ec <tc_sha256_final>
				      &ctx->hash_state);
		rekey(ctx->key,
50002770:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002774:	00048593          	mv	a1,s1
50002778:	000a0513          	mv	a0,s4
5000277c:	ed5ff0ef          	jal	50002650 <rekey>
		      &ctx->key[TC_SHA256_DIGEST_SIZE],
		      TC_SHA256_DIGEST_SIZE);
	}

	return TC_CRYPTO_SUCCESS;
}
50002780:	ef040113          	addi	sp,s0,-272
		rekey(ctx->key,
		      &ctx->key[TC_SHA256_DIGEST_SIZE],
		      TC_SHA256_DIGEST_SIZE);
	}

	return TC_CRYPTO_SUCCESS;
50002784:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
}
50002788:	10c12083          	lw	ra,268(sp)
5000278c:	00078513          	mv	a0,a5
50002790:	10812403          	lw	s0,264(sp)
50002794:	10412483          	lw	s1,260(sp)
50002798:	10012903          	lw	s2,256(sp)
5000279c:	0fc12983          	lw	s3,252(sp)
500027a0:	0f812a03          	lw	s4,248(sp)
500027a4:	11010113          	addi	sp,sp,272
500027a8:	00008067          	ret
500027ac:	00078513          	mv	a0,a5
500027b0:	00008067          	ret

500027b4 <tc_hmac_init>:

int32_t tc_hmac_init(TCHmacState_t ctx)
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
500027b4:	02050e63          	beqz	a0,500027f0 <tc_hmac_init+0x3c>

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_hmac_init(TCHmacState_t ctx)
{
500027b8:	ff010113          	addi	sp,sp,-16
500027bc:	00812423          	sw	s0,8(sp)
500027c0:	00050413          	mv	s0,a0
500027c4:	00112623          	sw	ra,12(sp)
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_init(&ctx->hash_state);
500027c8:	bc9ff0ef          	jal	50002390 <tc_sha256_init>
	(void)tc_sha256_update(&ctx->hash_state,
500027cc:	07040593          	addi	a1,s0,112
500027d0:	00040513          	mv	a0,s0
500027d4:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
500027d8:	c55ff0ef          	jal	5000242c <tc_sha256_update>
			       ctx->key,
			       TC_SHA256_BLOCK_SIZE);

	return TC_CRYPTO_SUCCESS;
}
500027dc:	00c12083          	lw	ra,12(sp)
	(void)tc_sha256_init(&ctx->hash_state);
	(void)tc_sha256_update(&ctx->hash_state,
			       ctx->key,
			       TC_SHA256_BLOCK_SIZE);

	return TC_CRYPTO_SUCCESS;
500027e0:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
}
500027e4:	00812403          	lw	s0,8(sp)
500027e8:	01010113          	addi	sp,sp,16
500027ec:	00008067          	ret

int32_t tc_hmac_init(TCHmacState_t ctx)
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
500027f0:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500027f4:	00008067          	ret

500027f8 <tc_hmac_update>:
int32_t tc_hmac_update(TCHmacState_t ctx,
		       const void *data,
		       uint32_t data_length)
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
500027f8:	02050063          	beqz	a0,50002818 <tc_hmac_update+0x20>
}

int32_t tc_hmac_update(TCHmacState_t ctx,
		       const void *data,
		       uint32_t data_length)
{
500027fc:	ff010113          	addi	sp,sp,-16
50002800:	00112623          	sw	ra,12(sp)
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_update(&ctx->hash_state, data, data_length);
50002804:	c29ff0ef          	jal	5000242c <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
}
50002808:	00c12083          	lw	ra,12(sp)
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_update(&ctx->hash_state, data, data_length);

	return TC_CRYPTO_SUCCESS;
5000280c:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
}
50002810:	01010113          	addi	sp,sp,16
50002814:	00008067          	ret
		       const void *data,
		       uint32_t data_length)
{
	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
50002818:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000281c:	00008067          	ret

50002820 <tc_hmac_final>:
{
	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
	    taglen != TC_SHA256_DIGEST_SIZE ||
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
50002820:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
}

int32_t tc_hmac_final(uint8_t *tag, uint32_t taglen, TCHmacState_t ctx)
{
	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
50002824:	08050e63          	beqz	a0,500028c0 <tc_hmac_final+0xa0>
50002828:	02000713          	li	a4,32 # 20 <CONFIG_NUM_IRQS>
5000282c:	08e59a63          	bne	a1,a4,500028c0 <tc_hmac_final+0xa0>
	    taglen != TC_SHA256_DIGEST_SIZE ||
50002830:	08060863          	beqz	a2,500028c0 <tc_hmac_final+0xa0>

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_hmac_final(uint8_t *tag, uint32_t taglen, TCHmacState_t ctx)
{
50002834:	ff010113          	addi	sp,sp,-16
50002838:	00812423          	sw	s0,8(sp)
5000283c:	01212023          	sw	s2,0(sp)
50002840:	00060413          	mv	s0,a2
50002844:	00058913          	mv	s2,a1
	    taglen != TC_SHA256_DIGEST_SIZE ||
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void) tc_sha256_final(tag, &ctx->hash_state);
50002848:	00060593          	mv	a1,a2

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_hmac_final(uint8_t *tag, uint32_t taglen, TCHmacState_t ctx)
{
5000284c:	00112623          	sw	ra,12(sp)
50002850:	00912223          	sw	s1,4(sp)
50002854:	00050493          	mv	s1,a0
	    taglen != TC_SHA256_DIGEST_SIZE ||
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void) tc_sha256_final(tag, &ctx->hash_state);
50002858:	c95ff0ef          	jal	500024ec <tc_sha256_final>

	(void)tc_sha256_init(&ctx->hash_state);
5000285c:	00040513          	mv	a0,s0
50002860:	b31ff0ef          	jal	50002390 <tc_sha256_init>
	(void)tc_sha256_update(&ctx->hash_state,
50002864:	0b040593          	addi	a1,s0,176
50002868:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
5000286c:	00040513          	mv	a0,s0
50002870:	bbdff0ef          	jal	5000242c <tc_sha256_update>
			       &ctx->key[TC_SHA256_BLOCK_SIZE],
				TC_SHA256_BLOCK_SIZE);
	(void)tc_sha256_update(&ctx->hash_state, tag, TC_SHA256_DIGEST_SIZE);
50002874:	00090613          	mv	a2,s2
50002878:	00048593          	mv	a1,s1
5000287c:	00040513          	mv	a0,s0
50002880:	badff0ef          	jal	5000242c <tc_sha256_update>
	(void)tc_sha256_final(tag, &ctx->hash_state);
50002884:	00040593          	mv	a1,s0
50002888:	00048513          	mv	a0,s1
5000288c:	c61ff0ef          	jal	500024ec <tc_sha256_final>

	/* destroy the current state */
	_set(ctx, 0, sizeof(*ctx));
50002890:	00040513          	mv	a0,s0
50002894:	0f000613          	li	a2,240 # f0 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x70>
50002898:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000289c:	f6cff0ef          	jal	50002008 <_set>

	return TC_CRYPTO_SUCCESS;
500028a0:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
}
500028a4:	00c12083          	lw	ra,12(sp)
500028a8:	00078513          	mv	a0,a5
500028ac:	00812403          	lw	s0,8(sp)
500028b0:	00412483          	lw	s1,4(sp)
500028b4:	00012903          	lw	s2,0(sp)
500028b8:	01010113          	addi	sp,sp,16
500028bc:	00008067          	ret
500028c0:	00078513          	mv	a0,a5
500028c4:	00008067          	ret

500028c8 <update>:

/*
 * Assumes: prng != NULL, e != NULL, len >= 0.
 */
static void update(TCHmacPrng_t prng, const uint8_t *e, uint32_t len)
{
500028c8:	fd010113          	addi	sp,sp,-48
500028cc:	02812423          	sw	s0,40(sp)
500028d0:	00050413          	mv	s0,a0
	const uint8_t separator0 = 0x00;
	const uint8_t separator1 = 0x01;
500028d4:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>

/*
 * Assumes: prng != NULL, e != NULL, len >= 0.
 */
static void update(TCHmacPrng_t prng, const uint8_t *e, uint32_t len)
{
500028d8:	02912223          	sw	s1,36(sp)
	const uint8_t separator0 = 0x00;
	const uint8_t separator1 = 0x01;

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
500028dc:	11040493          	addi	s1,s0,272

/*
 * Assumes: prng != NULL, e != NULL, len >= 0.
 */
static void update(TCHmacPrng_t prng, const uint8_t *e, uint32_t len)
{
500028e0:	02112623          	sw	ra,44(sp)
	const uint8_t separator0 = 0x00;
	const uint8_t separator1 = 0x01;
500028e4:	00f107a3          	sb	a5,15(sp)

/*
 * Assumes: prng != NULL, e != NULL, len >= 0.
 */
static void update(TCHmacPrng_t prng, const uint8_t *e, uint32_t len)
{
500028e8:	03212023          	sw	s2,32(sp)
500028ec:	01312e23          	sw	s3,28(sp)
500028f0:	01412c23          	sw	s4,24(sp)
500028f4:	00058993          	mv	s3,a1
500028f8:	00060a13          	mv	s4,a2
	const uint8_t separator0 = 0x00;
500028fc:	00010723          	sb	zero,14(sp)
	const uint8_t separator1 = 0x01;

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
50002900:	eb5ff0ef          	jal	500027b4 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
50002904:	00048593          	mv	a1,s1
50002908:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
5000290c:	00040513          	mv	a0,s0
50002910:	ee9ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator0, sizeof(separator0));
50002914:	00e10593          	addi	a1,sp,14
50002918:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
5000291c:	00040513          	mv	a0,s0
50002920:	ed9ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, e, len);
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
50002924:	0f040913          	addi	s2,s0,240

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
	(void)tc_hmac_update(&prng->h, &separator0, sizeof(separator0));
	(void)tc_hmac_update(&prng->h, e, len);
50002928:	000a0613          	mv	a2,s4
5000292c:	00098593          	mv	a1,s3
50002930:	00040513          	mv	a0,s0
50002934:	ec5ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
50002938:	00040613          	mv	a2,s0
5000293c:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
50002940:	00090513          	mv	a0,s2
50002944:	eddff0ef          	jal	50002820 <tc_hmac_final>
	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
50002948:	00090593          	mv	a1,s2
5000294c:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002950:	00040513          	mv	a0,s0
50002954:	d75ff0ef          	jal	500026c8 <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
50002958:	00040513          	mv	a0,s0
5000295c:	e59ff0ef          	jal	500027b4 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
50002960:	00048593          	mv	a1,s1
50002964:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002968:	00040513          	mv	a0,s0
5000296c:	e8dff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
50002970:	00040613          	mv	a2,s0
50002974:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
50002978:	00048513          	mv	a0,s1
5000297c:	ea5ff0ef          	jal	50002820 <tc_hmac_final>

	/* use current state, e and separator 1 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
50002980:	00040513          	mv	a0,s0
50002984:	e31ff0ef          	jal	500027b4 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
50002988:	00048593          	mv	a1,s1
5000298c:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002990:	00040513          	mv	a0,s0
50002994:	e65ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator1, sizeof(separator1));
50002998:	00f10593          	addi	a1,sp,15
5000299c:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
500029a0:	00040513          	mv	a0,s0
500029a4:	e55ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, e, len);
500029a8:	000a0613          	mv	a2,s4
500029ac:	00098593          	mv	a1,s3
500029b0:	00040513          	mv	a0,s0
500029b4:	e45ff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
500029b8:	00040613          	mv	a2,s0
500029bc:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
500029c0:	00090513          	mv	a0,s2
500029c4:	e5dff0ef          	jal	50002820 <tc_hmac_final>
	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
500029c8:	00090593          	mv	a1,s2
500029cc:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
500029d0:	00040513          	mv	a0,s0
500029d4:	cf5ff0ef          	jal	500026c8 <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
500029d8:	00040513          	mv	a0,s0
500029dc:	dd9ff0ef          	jal	500027b4 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
500029e0:	00048593          	mv	a1,s1
500029e4:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
500029e8:	00040513          	mv	a0,s0
500029ec:	e0dff0ef          	jal	500027f8 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
500029f0:	00040613          	mv	a2,s0
500029f4:	00048513          	mv	a0,s1
500029f8:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
500029fc:	e25ff0ef          	jal	50002820 <tc_hmac_final>
}
50002a00:	02c12083          	lw	ra,44(sp)
50002a04:	02812403          	lw	s0,40(sp)
50002a08:	02412483          	lw	s1,36(sp)
50002a0c:	02012903          	lw	s2,32(sp)
50002a10:	01c12983          	lw	s3,28(sp)
50002a14:	01812a03          	lw	s4,24(sp)
50002a18:	03010113          	addi	sp,sp,48
50002a1c:	00008067          	ret

50002a20 <tc_hmac_prng_init>:
int32_t tc_hmac_prng_init(TCHmacPrng_t prng,
			  const uint8_t *personalization,
			  uint32_t plen)
{
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
50002a20:	08050063          	beqz	a0,50002aa0 <tc_hmac_prng_init+0x80>
}

int32_t tc_hmac_prng_init(TCHmacPrng_t prng,
			  const uint8_t *personalization,
			  uint32_t plen)
{
50002a24:	fe010113          	addi	sp,sp,-32
50002a28:	00812c23          	sw	s0,24(sp)
50002a2c:	00112e23          	sw	ra,28(sp)
50002a30:	00050413          	mv	s0,a0
50002a34:	00912a23          	sw	s1,20(sp)
50002a38:	01212823          	sw	s2,16(sp)
50002a3c:	01312623          	sw	s3,12(sp)
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
	    personalization == (uint8_t *) 0 ||
	    plen > MAX_PLEN) {
		return TC_CRYPTO_FAIL;
50002a40:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
			  const uint8_t *personalization,
			  uint32_t plen)
{
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
	    personalization == (uint8_t *) 0 ||
50002a44:	06058263          	beqz	a1,50002aa8 <tc_hmac_prng_init+0x88>
	    plen > MAX_PLEN) {
		return TC_CRYPTO_FAIL;
	}

	/* put the generator into a known state: */
	_set(prng->key, 0x00, sizeof(prng->key));
50002a48:	0f040993          	addi	s3,s0,240
50002a4c:	00060913          	mv	s2,a2
50002a50:	00058493          	mv	s1,a1
50002a54:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002a58:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002a5c:	00098513          	mv	a0,s3
50002a60:	da8ff0ef          	jal	50002008 <_set>
	_set(prng->v, 0x01, sizeof(prng->v));
50002a64:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002a68:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50002a6c:	11040513          	addi	a0,s0,272
50002a70:	d98ff0ef          	jal	50002008 <_set>
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
50002a74:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002a78:	00098593          	mv	a1,s3
50002a7c:	00040513          	mv	a0,s0
50002a80:	c49ff0ef          	jal	500026c8 <tc_hmac_set_key>
	/* update assumes SOME key has been configured into HMAC */

	update(prng, personalization, plen);
50002a84:	00040513          	mv	a0,s0
50002a88:	00090613          	mv	a2,s2
50002a8c:	00048593          	mv	a1,s1
50002a90:	e39ff0ef          	jal	500028c8 <update>

	/* force a reseed before allowing tc_hmac_prng_generate to succeed: */
	prng->countdown = 0;
50002a94:	12042823          	sw	zero,304(s0)

	return TC_CRYPTO_SUCCESS;
50002a98:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
50002a9c:	00c0006f          	j	50002aa8 <tc_hmac_prng_init+0x88>
{
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
	    personalization == (uint8_t *) 0 ||
	    plen > MAX_PLEN) {
		return TC_CRYPTO_FAIL;
50002aa0:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002aa4:	00008067          	ret

	/* force a reseed before allowing tc_hmac_prng_generate to succeed: */
	prng->countdown = 0;

	return TC_CRYPTO_SUCCESS;
}
50002aa8:	01c12083          	lw	ra,28(sp)
50002aac:	01812403          	lw	s0,24(sp)
50002ab0:	01412483          	lw	s1,20(sp)
50002ab4:	01012903          	lw	s2,16(sp)
50002ab8:	00c12983          	lw	s3,12(sp)
50002abc:	02010113          	addi	sp,sp,32
50002ac0:	00008067          	ret

50002ac4 <tc_hmac_prng_reseed>:
			    uint32_t seedlen,
			    const uint8_t *additional_input,
			    uint32_t additionallen)
{
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
50002ac4:	06050063          	beqz	a0,50002b24 <tc_hmac_prng_reseed+0x60>
	    seed == (const uint8_t *) 0 ||
	    seedlen < MIN_SLEN ||
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
50002ac8:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
			    uint32_t seedlen,
			    const uint8_t *additional_input,
			    uint32_t additionallen)
{
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
50002acc:	04058e63          	beqz	a1,50002b28 <tc_hmac_prng_reseed+0x64>
	    seed == (const uint8_t *) 0 ||
	    seedlen < MIN_SLEN ||
50002ad0:	01f00813          	li	a6,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
50002ad4:	04c87a63          	bleu	a2,a6,50002b28 <tc_hmac_prng_reseed+0x64>
int32_t tc_hmac_prng_reseed(TCHmacPrng_t prng,
			    const uint8_t *seed,
			    uint32_t seedlen,
			    const uint8_t *additional_input,
			    uint32_t additionallen)
{
50002ad8:	ff010113          	addi	sp,sp,-16
50002adc:	00812423          	sw	s0,8(sp)
50002ae0:	00912223          	sw	s1,4(sp)
50002ae4:	01212023          	sw	s2,0(sp)
50002ae8:	00112623          	sw	ra,12(sp)
50002aec:	00050413          	mv	s0,a0
50002af0:	00070913          	mv	s2,a4
50002af4:	00068493          	mv	s1,a3
	    seedlen < MIN_SLEN ||
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
	}

	if (additional_input != (const uint8_t *) 0) {
50002af8:	00068c63          	beqz	a3,50002b10 <tc_hmac_prng_reseed+0x4c>
		/*
		 * Abort if additional_input is provided but has inappropriate
		 * length
		 */
		if (additionallen == 0 ||
50002afc:	02070a63          	beqz	a4,50002b30 <tc_hmac_prng_reseed+0x6c>
		    additionallen > MAX_ALEN) {
			return TC_CRYPTO_FAIL;
		} else {
		/* call update for the seed and additional_input */
		update(prng, seed, seedlen);
50002b00:	dc9ff0ef          	jal	500028c8 <update>
		update(prng, additional_input, additionallen);
50002b04:	00090613          	mv	a2,s2
50002b08:	00048593          	mv	a1,s1
50002b0c:	00040513          	mv	a0,s0
		}
	} else {
		/* call update only for the seed */
		update(prng, seed, seedlen);
50002b10:	db9ff0ef          	jal	500028c8 <update>
	}

	/* ... and enable hmac_prng_generate */
	prng->countdown = MAX_GENS;
50002b14:	fff00793          	li	a5,-1
50002b18:	12f42823          	sw	a5,304(s0)

	return TC_CRYPTO_SUCCESS;
50002b1c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50002b20:	0100006f          	j	50002b30 <tc_hmac_prng_reseed+0x6c>
	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
	    seed == (const uint8_t *) 0 ||
	    seedlen < MIN_SLEN ||
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
50002b24:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>

	/* ... and enable hmac_prng_generate */
	prng->countdown = MAX_GENS;

	return TC_CRYPTO_SUCCESS;
}
50002b28:	00078513          	mv	a0,a5
50002b2c:	00008067          	ret
50002b30:	00c12083          	lw	ra,12(sp)
50002b34:	00078513          	mv	a0,a5
50002b38:	00812403          	lw	s0,8(sp)
50002b3c:	00412483          	lw	s1,4(sp)
50002b40:	00012903          	lw	s2,0(sp)
50002b44:	01010113          	addi	sp,sp,16
50002b48:	00008067          	ret

50002b4c <tc_hmac_prng_generate>:
int32_t tc_hmac_prng_generate(uint8_t *out, uint32_t outlen, TCHmacPrng_t prng)
{
	uint32_t bufferlen;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
50002b4c:	0c050663          	beqz	a0,50002c18 <tc_hmac_prng_generate+0xcc>

	return TC_CRYPTO_SUCCESS;
}

int32_t tc_hmac_prng_generate(uint8_t *out, uint32_t outlen, TCHmacPrng_t prng)
{
50002b50:	fe010113          	addi	sp,sp,-32
50002b54:	00812c23          	sw	s0,24(sp)
50002b58:	01212823          	sw	s2,16(sp)
50002b5c:	00112e23          	sw	ra,28(sp)
50002b60:	00050913          	mv	s2,a0
50002b64:	00912a23          	sw	s1,20(sp)
50002b68:	01312623          	sw	s3,12(sp)
50002b6c:	01412423          	sw	s4,8(sp)
50002b70:	01512223          	sw	s5,4(sp)
50002b74:	00060413          	mv	s0,a2
	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
	    prng == (TCHmacPrng_t) 0 ||
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
50002b78:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
int32_t tc_hmac_prng_generate(uint8_t *out, uint32_t outlen, TCHmacPrng_t prng)
{
	uint32_t bufferlen;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
50002b7c:	0a060263          	beqz	a2,50002c20 <tc_hmac_prng_generate+0xd4>
	    prng == (TCHmacPrng_t) 0 ||
50002b80:	000807b7          	lui	a5,0x80
50002b84:	fff58713          	addi	a4,a1,-1
50002b88:	fff78793          	addi	a5,a5,-1 # 7ffff <pulp__L2+0x3ffff>
50002b8c:	00058493          	mv	s1,a1
50002b90:	08e7e863          	bltu	a5,a4,50002c20 <tc_hmac_prng_generate+0xd4>
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
	} else if (prng->countdown == 0) {
50002b94:	13062783          	lw	a5,304(a2)
		return TC_HMAC_PRNG_RESEED_REQ;
50002b98:	fff00513          	li	a0,-1
	if (out == (uint8_t *) 0 ||
	    prng == (TCHmacPrng_t) 0 ||
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
	} else if (prng->countdown == 0) {
50002b9c:	08078263          	beqz	a5,50002c20 <tc_hmac_prng_generate+0xd4>
		return TC_HMAC_PRNG_RESEED_REQ;
	}

	prng->countdown--;
50002ba0:	00a787b3          	add	a5,a5,a0
50002ba4:	12f62823          	sw	a5,304(a2)

	while (outlen != 0) {
		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
50002ba8:	11060993          	addi	s3,a2,272
50002bac:	02000a93          	li	s5,32 # 20 <CONFIG_NUM_IRQS>

	prng->countdown--;

	while (outlen != 0) {
		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
50002bb0:	00040513          	mv	a0,s0
50002bb4:	c01ff0ef          	jal	500027b4 <tc_hmac_init>
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
50002bb8:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002bbc:	00098593          	mv	a1,s3
50002bc0:	00040513          	mv	a0,s0
50002bc4:	c35ff0ef          	jal	500027f8 <tc_hmac_update>
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);

		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
50002bc8:	0554da33          	p.minu	s4,s1,s5

	while (outlen != 0) {
		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
50002bcc:	00040613          	mv	a2,s0
50002bd0:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
50002bd4:	00098513          	mv	a0,s3
50002bd8:	c49ff0ef          	jal	50002820 <tc_hmac_final>

		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
			outlen : TC_SHA256_DIGEST_SIZE;
		(void)_copy(out, bufferlen, prng->v, bufferlen);
50002bdc:	00090513          	mv	a0,s2
50002be0:	000a0693          	mv	a3,s4
50002be4:	00098613          	mv	a2,s3
50002be8:	000a0593          	mv	a1,s4
50002bec:	be0ff0ef          	jal	50001fcc <_copy>

		out += bufferlen;
50002bf0:	01490933          	add	s2,s2,s4
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
			(outlen - TC_SHA256_DIGEST_SIZE) : 0;
50002bf4:	009aee63          	bltu	s5,s1,50002c10 <tc_hmac_prng_generate+0xc4>
	}

	/* block future PRNG compromises from revealing past state */
	update(prng, prng->v, TC_SHA256_DIGEST_SIZE);
50002bf8:	00040513          	mv	a0,s0
50002bfc:	02000613          	li	a2,32 # 20 <CONFIG_NUM_IRQS>
50002c00:	00098593          	mv	a1,s3
50002c04:	cc5ff0ef          	jal	500028c8 <update>

	return TC_CRYPTO_SUCCESS;
50002c08:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
50002c0c:	0140006f          	j	50002c20 <tc_hmac_prng_generate+0xd4>
			outlen : TC_SHA256_DIGEST_SIZE;
		(void)_copy(out, bufferlen, prng->v, bufferlen);

		out += bufferlen;
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
			(outlen - TC_SHA256_DIGEST_SIZE) : 0;
50002c10:	fe048493          	addi	s1,s1,-32
50002c14:	f9dff06f          	j	50002bb0 <tc_hmac_prng_generate+0x64>
	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
	    prng == (TCHmacPrng_t) 0 ||
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
50002c18:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50002c1c:	00008067          	ret

	/* block future PRNG compromises from revealing past state */
	update(prng, prng->v, TC_SHA256_DIGEST_SIZE);

	return TC_CRYPTO_SUCCESS;
}
50002c20:	01c12083          	lw	ra,28(sp)
50002c24:	01812403          	lw	s0,24(sp)
50002c28:	01412483          	lw	s1,20(sp)
50002c2c:	01012903          	lw	s2,16(sp)
50002c30:	00c12983          	lw	s3,12(sp)
50002c34:	00812a03          	lw	s4,8(sp)
50002c38:	00412a83          	lw	s5,4(sp)
50002c3c:	02010113          	addi	sp,sp,32
50002c40:	00008067          	ret

50002c44 <bt_hex>:
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002c44:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50002c48:	30073773          	csrrc	a4,mstatus,a4
	unsigned int mask;
	char *str;
	int i;

	mask = irq_lock();
	str = hexbufs[curbuf++];
50002c4c:	51002637          	lui	a2,0x51002
50002c50:	d1460613          	addi	a2,a2,-748 # 51001d14 <curbuf.3152>
50002c54:	00064683          	lbu	a3,0(a2)
50002c58:	510027b7          	lui	a5,0x51002
50002c5c:	08100813          	li	a6,129 # 81 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x1>
50002c60:	dd878793          	addi	a5,a5,-552 # 51001dd8 <hexbufs.3151>
50002c64:	430687b3          	p.mac	a5,a3,a6
	curbuf %= ARRAY_SIZE(hexbufs);
50002c68:	00168693          	addi	a3,a3,1
50002c6c:	fa26b6b3          	p.bclr	a3,a3,29,2
50002c70:	00d60023          	sb	a3,0(a2)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002c74:	fc173733          	p.bclr	a4,a4,30,1
50002c78:	30072773          	csrrs	a4,mstatus,a4
	irq_unlock(mask);

	len = min(len, (sizeof(hexbufs[0]) - 1) / 2);
50002c7c:	04000713          	li	a4,64 # 40 <__NANO_ESF_a6_OFFSET>
50002c80:	04e5d5b3          	p.minu	a1,a1,a4
50002c84:	00078813          	mv	a6,a5
50002c88:	00178893          	addi	a7,a5,1

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
50002c8c:	51001337          	lui	t1,0x51001
50002c90:	00158613          	addi	a2,a1,1
50002c94:	fff60613          	addi	a2,a2,-1
50002c98:	00061a63          	bnez	a2,50002cac <bt_hex+0x68>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
50002c9c:	00159593          	slli	a1,a1,0x1
50002ca0:	0007c5a3          	p.sb	zero,a1(a5)

	return str;
}
50002ca4:	00078513          	mv	a0,a5
50002ca8:	00008067          	ret
50002cac:	00050e13          	mv	t3,a0
	irq_unlock(mask);

	len = min(len, (sizeof(hexbufs[0]) - 1) / 2);

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
50002cb0:	0015470b          	p.lbu	a4,1(a0!)
50002cb4:	49030693          	addi	a3,t1,1168 # 51001490 <hex.3150>
50002cb8:	00475713          	srli	a4,a4,0x4
50002cbc:	00e6f703          	p.lb	a4,a4(a3)
50002cc0:	00e8012b          	p.sb	a4,2(a6!)
		str[i * 2 + 1] = hex[b[i] & 0xf];
50002cc4:	000e4703          	lbu	a4,0(t3)
50002cc8:	f6473733          	p.bclr	a4,a4,27,4
50002ccc:	00e6f683          	p.lb	a3,a4(a3)
50002cd0:	00d8812b          	p.sb	a3,2(a7!)
50002cd4:	fc1ff06f          	j	50002c94 <bt_hex+0x50>

50002cd8 <bt_addr_str>:
	return str;
}

#if defined(CONFIG_BLUETOOTH_DEBUG)
const char *bt_addr_str(const bt_addr_t *addr)
{
50002cd8:	fe010113          	addi	sp,sp,-32
	static char bufs[2][18];
	static u8_t cur;
	char *str;

	str = bufs[cur++];
50002cdc:	51002737          	lui	a4,0x51002
	return str;
}

#if defined(CONFIG_BLUETOOTH_DEBUG)
const char *bt_addr_str(const bt_addr_t *addr)
{
50002ce0:	00112e23          	sw	ra,28(sp)
50002ce4:	00812c23          	sw	s0,24(sp)
	static char bufs[2][18];
	static u8_t cur;
	char *str;

	str = bufs[cur++];
50002ce8:	d1670713          	addi	a4,a4,-746 # 51001d16 <cur.3164>
50002cec:	00074783          	lbu	a5,0(a4)
50002cf0:	51002437          	lui	s0,0x51002
50002cf4:	01200593          	li	a1,18 # 12 <CONFIG_NUM_COOP_PRIORITIES+0x2>
50002cf8:	fdc40413          	addi	s0,s0,-36 # 51001fdc <bufs.3163>
50002cfc:	42b78433          	p.mac	s0,a5,a1
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_to_str(const bt_addr_t *addr, char *str, size_t len)
{
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X",
50002d00:	00054603          	lbu	a2,0(a0)
	cur %= ARRAY_SIZE(bufs);
50002d04:	00178793          	addi	a5,a5,1
50002d08:	fc17b7b3          	p.bclr	a5,a5,30,1
50002d0c:	00f70023          	sb	a5,0(a4)
50002d10:	00154883          	lbu	a7,1(a0)
50002d14:	00254803          	lbu	a6,2(a0)
50002d18:	00354783          	lbu	a5,3(a0)
50002d1c:	00454703          	lbu	a4,4(a0)
50002d20:	00554683          	lbu	a3,5(a0)
50002d24:	00c12023          	sw	a2,0(sp)
50002d28:	51001637          	lui	a2,0x51001
50002d2c:	00040513          	mv	a0,s0
50002d30:	82c60613          	addi	a2,a2,-2004 # 5100082c <k256+0x100>
50002d34:	a2cff0ef          	jal	50001f60 <snprintk>
	bt_addr_to_str(addr, str, sizeof(bufs[cur]));

	return str;
}
50002d38:	01c12083          	lw	ra,28(sp)
50002d3c:	00040513          	mv	a0,s0
50002d40:	01812403          	lw	s0,24(sp)
50002d44:	02010113          	addi	sp,sp,32
50002d48:	00008067          	ret

50002d4c <bt_addr_le_str>:

const char *bt_addr_le_str(const bt_addr_le_t *addr)
{
50002d4c:	fd010113          	addi	sp,sp,-48
	static char bufs[2][27];
	static u8_t cur;
	char *str;

	str = bufs[cur++];
50002d50:	51002737          	lui	a4,0x51002

	return str;
}

const char *bt_addr_le_str(const bt_addr_le_t *addr)
{
50002d54:	02812423          	sw	s0,40(sp)
50002d58:	02912223          	sw	s1,36(sp)
50002d5c:	02112623          	sw	ra,44(sp)
	static char bufs[2][27];
	static u8_t cur;
	char *str;

	str = bufs[cur++];
50002d60:	d1570713          	addi	a4,a4,-747 # 51001d15 <cur.3170>
50002d64:	00074783          	lbu	a5,0(a4)
50002d68:	510024b7          	lui	s1,0x51002
50002d6c:	01b00693          	li	a3,27 # 1b <__NANO_ESF_t3_OFFSET+0x3>
50002d70:	da048493          	addi	s1,s1,-608 # 51001da0 <bufs.3169>
50002d74:	42d784b3          	p.mac	s1,a5,a3
	cur %= ARRAY_SIZE(bufs);
50002d78:	00178793          	addi	a5,a5,1
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[7];

	switch (addr->type) {
50002d7c:	00054683          	lbu	a3,0(a0)
50002d80:	fc17b7b3          	p.bclr	a5,a5,30,1

	return str;
}

const char *bt_addr_le_str(const bt_addr_le_t *addr)
{
50002d84:	00050413          	mv	s0,a0
	static char bufs[2][27];
	static u8_t cur;
	char *str;

	str = bufs[cur++];
	cur %= ARRAY_SIZE(bufs);
50002d88:	00f70023          	sb	a5,0(a4)
50002d8c:	00068a63          	beqz	a3,50002da0 <bt_addr_le_str+0x54>
50002d90:	0216b263          	p.bneimm	a3,1,50002db4 <bt_addr_le_str+0x68>
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
50002d94:	510015b7          	lui	a1,0x51001
50002d98:	85458593          	addi	a1,a1,-1964 # 51000854 <k256+0x128>
50002d9c:	00c0006f          	j	50002da8 <bt_addr_le_str+0x5c>
{
	char type[7];

	switch (addr->type) {
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
50002da0:	510015b7          	lui	a1,0x51001
50002da4:	84c58593          	addi	a1,a1,-1972 # 5100084c <k256+0x120>
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
50002da8:	01810513          	addi	a0,sp,24
50002dac:	e18fd0ef          	jal	500003c4 <strcpy>
50002db0:	0180006f          	j	50002dc8 <bt_addr_le_str+0x7c>
		break;
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
50002db4:	51001637          	lui	a2,0x51001
50002db8:	85c60613          	addi	a2,a2,-1956 # 5100085c <k256+0x130>
50002dbc:	00700593          	li	a1,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50002dc0:	01810513          	addi	a0,sp,24
50002dc4:	99cff0ef          	jal	50001f60 <snprintk>
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
50002dc8:	01810613          	addi	a2,sp,24
50002dcc:	00244883          	lbu	a7,2(s0)
50002dd0:	00344803          	lbu	a6,3(s0)
50002dd4:	00444783          	lbu	a5,4(s0)
50002dd8:	00544703          	lbu	a4,5(s0)
50002ddc:	00644683          	lbu	a3,6(s0)
50002de0:	00c12223          	sw	a2,4(sp)
50002de4:	00144603          	lbu	a2,1(s0)
50002de8:	00048513          	mv	a0,s1
50002dec:	00c12023          	sw	a2,0(sp)
50002df0:	51001637          	lui	a2,0x51001
50002df4:	86460613          	addi	a2,a2,-1948 # 51000864 <k256+0x138>
50002df8:	01b00593          	li	a1,27 # 1b <__NANO_ESF_t3_OFFSET+0x3>
50002dfc:	964ff0ef          	jal	50001f60 <snprintk>
	bt_addr_le_to_str(addr, str, sizeof(bufs[cur]));

	return str;
}
50002e00:	02c12083          	lw	ra,44(sp)
50002e04:	00048513          	mv	a0,s1
50002e08:	02812403          	lw	s0,40(sp)
50002e0c:	02412483          	lw	s1,36(sp)
50002e10:	03010113          	addi	sp,sp,48
50002e14:	00008067          	ret

50002e18 <net_buf_user_data>:
	}

	scan_dev_found_cb = NULL;

	return bt_le_scan_update(false);
}
50002e18:	00e55783          	lhu	a5,14(a0)
50002e1c:	00f50533          	add	a0,a0,a5
50002e20:	01350513          	addi	a0,a0,19
50002e24:	c2053533          	p.bclr	a0,a0,1,0
50002e28:	00008067          	ret

50002e2c <ver_str>:
50002e2c:	fc010113          	addi	sp,sp,-64
50002e30:	510005b7          	lui	a1,0x51000
50002e34:	02812c23          	sw	s0,56(sp)
50002e38:	02800613          	li	a2,40 # 28 <CONFIG_KERNEL_INIT_PRIORITY_DEFAULT>
50002e3c:	00050413          	mv	s0,a0
50002e40:	15458593          	addi	a1,a1,340 # 51000154 <__devconfig_end+0x100>
50002e44:	00810513          	addi	a0,sp,8
50002e48:	02112e23          	sw	ra,60(sp)
50002e4c:	df4fd0ef          	jal	50000440 <memcpy>
50002e50:	00900793          	li	a5,9 # 9 <___thread_base_t_thread_state_OFFSET>
50002e54:	0087ec63          	bltu	a5,s0,50002e6c <ver_str+0x40>
50002e58:	00241513          	slli	a0,s0,0x2
50002e5c:	03010793          	addi	a5,sp,48
50002e60:	00a78533          	add	a0,a5,a0
50002e64:	fd852503          	lw	a0,-40(a0)
50002e68:	00c0006f          	j	50002e74 <ver_str+0x48>
50002e6c:	51001537          	lui	a0,0x51001
50002e70:	8a850513          	addi	a0,a0,-1880 # 510008a8 <k256+0x17c>
50002e74:	03c12083          	lw	ra,60(sp)
50002e78:	03812403          	lw	s0,56(sp)
50002e7c:	04010113          	addi	sp,sp,64
50002e80:	00008067          	ret

50002e84 <hci_cmd_done>:
50002e84:	fd010113          	addi	sp,sp,-48
50002e88:	02112623          	sw	ra,44(sp)
50002e8c:	02812423          	sw	s0,40(sp)
50002e90:	02912223          	sw	s1,36(sp)
50002e94:	00060413          	mv	s0,a2
50002e98:	03212023          	sw	s2,32(sp)
50002e9c:	01312e23          	sw	s3,28(sp)
50002ea0:	01412c23          	sw	s4,24(sp)
50002ea4:	01512a23          	sw	s5,20(sp)
50002ea8:	00058a13          	mv	s4,a1
50002eac:	00050993          	mv	s3,a0
50002eb0:	7e0030ef          	jal	50006690 <k_current_get>
50002eb4:	51002737          	lui	a4,0x51002
50002eb8:	99470793          	addi	a5,a4,-1644 # 51001994 <_default_esf+0x288>
50002ebc:	00f12223          	sw	a5,4(sp)
50002ec0:	51001937          	lui	s2,0x51001
50002ec4:	00050793          	mv	a5,a0
50002ec8:	510004b7          	lui	s1,0x51000
50002ecc:	51000637          	lui	a2,0x51000
50002ed0:	51001537          	lui	a0,0x51001
50002ed4:	000a0893          	mv	a7,s4
50002ed8:	00098813          	mv	a6,s3
50002edc:	99470713          	addi	a4,a4,-1644
50002ee0:	54090693          	addi	a3,s2,1344 # 51001540 <__func__.4119>
50002ee4:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50002ee8:	1d848593          	addi	a1,s1,472 # 510001d8 <__devconfig_end+0x184>
50002eec:	00812023          	sw	s0,0(sp)
50002ef0:	8b050513          	addi	a0,a0,-1872 # 510008b0 <k256+0x184>
50002ef4:	830ff0ef          	jal	50001f24 <printk>
50002ef8:	00644503          	lbu	a0,6(s0)
50002efc:	51002ab7          	lui	s5,0x51002
50002f00:	154020ef          	jal	50005054 <net_buf_pool_get>
50002f04:	b14a8793          	addi	a5,s5,-1260 # 51001b14 <__device_APPLICATION_start>
50002f08:	04a78863          	beq	a5,a0,50002f58 <hci_cmd_done+0xd4>
50002f0c:	00644403          	lbu	s0,6(s0)
50002f10:	00040513          	mv	a0,s0
50002f14:	140020ef          	jal	50005054 <net_buf_pool_get>
50002f18:	51000737          	lui	a4,0x51000
50002f1c:	27070713          	addi	a4,a4,624 # 51000270 <__devconfig_end+0x21c>
50002f20:	00e12023          	sw	a4,0(sp)
50002f24:	00050813          	mv	a6,a0
50002f28:	51000737          	lui	a4,0x51000
50002f2c:	51000637          	lui	a2,0x51000
50002f30:	51001537          	lui	a0,0x51001
50002f34:	b14a8893          	addi	a7,s5,-1260
50002f38:	00040793          	mv	a5,s0
50002f3c:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
50002f40:	54090693          	addi	a3,s2,1344
50002f44:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50002f48:	1d848593          	addi	a1,s1,472
50002f4c:	8e850513          	addi	a0,a0,-1816 # 510008e8 <k256+0x1bc>
50002f50:	fd5fe0ef          	jal	50001f24 <printk>
50002f54:	0880006f          	j	50002fdc <hci_cmd_done+0x158>
50002f58:	00040513          	mv	a0,s0
50002f5c:	ebdff0ef          	jal	50002e18 <net_buf_user_data>
50002f60:	00255803          	lhu	a6,2(a0)
50002f64:	03098a63          	beq	s3,a6,50002f98 <hci_cmd_done+0x114>
50002f68:	510008b7          	lui	a7,0x51000
50002f6c:	51000737          	lui	a4,0x51000
50002f70:	51000637          	lui	a2,0x51000
50002f74:	51001537          	lui	a0,0x51001
50002f78:	27088893          	addi	a7,a7,624 # 51000270 <__devconfig_end+0x21c>
50002f7c:	00098793          	mv	a5,s3
50002f80:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
50002f84:	54090693          	addi	a3,s2,1344
50002f88:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50002f8c:	1d848593          	addi	a1,s1,472
50002f90:	92050513          	addi	a0,a0,-1760 # 51000920 <k256+0x1f4>
50002f94:	f91fe0ef          	jal	50001f24 <printk>
50002f98:	00040513          	mv	a0,s0
50002f9c:	e7dff0ef          	jal	50002e18 <net_buf_user_data>
50002fa0:	00452783          	lw	a5,4(a0)
50002fa4:	02078c63          	beqz	a5,50002fdc <hci_cmd_done+0x158>
50002fa8:	014500a3          	sb	s4,1(a0)
50002fac:	00040513          	mv	a0,s0
50002fb0:	e69ff0ef          	jal	50002e18 <net_buf_user_data>
50002fb4:	00452503          	lw	a0,4(a0)
50002fb8:	02c12083          	lw	ra,44(sp)
50002fbc:	02812403          	lw	s0,40(sp)
50002fc0:	02412483          	lw	s1,36(sp)
50002fc4:	02012903          	lw	s2,32(sp)
50002fc8:	01c12983          	lw	s3,28(sp)
50002fcc:	01812a03          	lw	s4,24(sp)
50002fd0:	01412a83          	lw	s5,20(sp)
50002fd4:	03010113          	addi	sp,sp,48
50002fd8:	0290306f          	j	50006800 <k_sem_give>
50002fdc:	02c12083          	lw	ra,44(sp)
50002fe0:	02812403          	lw	s0,40(sp)
50002fe4:	02412483          	lw	s1,36(sp)
50002fe8:	02012903          	lw	s2,32(sp)
50002fec:	01c12983          	lw	s3,28(sp)
50002ff0:	01812a03          	lw	s4,24(sp)
50002ff4:	01412a83          	lw	s5,20(sp)
50002ff8:	03010113          	addi	sp,sp,48
50002ffc:	00008067          	ret

50003000 <bt_hci_cmd_create>:
50003000:	fd010113          	addi	sp,sp,-48
50003004:	03212023          	sw	s2,32(sp)
50003008:	51002937          	lui	s2,0x51002
5000300c:	02112623          	sw	ra,44(sp)
50003010:	02812423          	sw	s0,40(sp)
50003014:	02912223          	sw	s1,36(sp)
50003018:	01312e23          	sw	s3,28(sp)
5000301c:	00050493          	mv	s1,a0
50003020:	00058993          	mv	s3,a1
50003024:	01412c23          	sw	s4,24(sp)
50003028:	01512a23          	sw	s5,20(sp)
5000302c:	01612823          	sw	s6,16(sp)
50003030:	660030ef          	jal	50006690 <k_current_get>
50003034:	99490793          	addi	a5,s2,-1644 # 51001994 <_default_esf+0x288>
50003038:	51001b37          	lui	s6,0x51001
5000303c:	51000ab7          	lui	s5,0x51000
50003040:	51000a37          	lui	s4,0x51000
50003044:	00f12023          	sw	a5,0(sp)
50003048:	00050793          	mv	a5,a0
5000304c:	51001537          	lui	a0,0x51001
50003050:	00098893          	mv	a7,s3
50003054:	00048813          	mv	a6,s1
50003058:	99490713          	addi	a4,s2,-1644
5000305c:	5d4b0693          	addi	a3,s6,1492 # 510015d4 <__func__.4052>
50003060:	1d0a8613          	addi	a2,s5,464 # 510001d0 <__devconfig_end+0x17c>
50003064:	1d8a0593          	addi	a1,s4,472 # 510001d8 <__devconfig_end+0x184>
50003068:	96450513          	addi	a0,a0,-1692 # 51000964 <k256+0x238>
5000306c:	eb9fe0ef          	jal	50001f24 <printk>
50003070:	51002537          	lui	a0,0x51002
50003074:	fff00593          	li	a1,-1
50003078:	b1450513          	addi	a0,a0,-1260 # 51001b14 <__device_APPLICATION_start>
5000307c:	7f1010ef          	jal	5000506c <net_buf_alloc>
50003080:	00050413          	mv	s0,a0
50003084:	60c030ef          	jal	50006690 <k_current_get>
50003088:	00050793          	mv	a5,a0
5000308c:	51001537          	lui	a0,0x51001
50003090:	99490893          	addi	a7,s2,-1644
50003094:	00040813          	mv	a6,s0
50003098:	99490713          	addi	a4,s2,-1644
5000309c:	5d4b0693          	addi	a3,s6,1492
500030a0:	1d0a8613          	addi	a2,s5,464
500030a4:	1d8a0593          	addi	a1,s4,472
500030a8:	99450513          	addi	a0,a0,-1644 # 51000994 <k256+0x268>
500030ac:	e79fe0ef          	jal	50001f24 <printk>
500030b0:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500030b4:	00040513          	mv	a0,s0
500030b8:	128020ef          	jal	500051e0 <net_buf_reserve>
500030bc:	00040513          	mv	a0,s0
500030c0:	d59ff0ef          	jal	50002e18 <net_buf_user_data>
500030c4:	00050023          	sb	zero,0(a0)
500030c8:	00040513          	mv	a0,s0
500030cc:	d4dff0ef          	jal	50002e18 <net_buf_user_data>
500030d0:	00951123          	sh	s1,2(a0)
500030d4:	00040513          	mv	a0,s0
500030d8:	d41ff0ef          	jal	50002e18 <net_buf_user_data>
500030dc:	00052223          	sw	zero,4(a0)
500030e0:	00300593          	li	a1,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
500030e4:	00840513          	addi	a0,s0,8
500030e8:	1c4020ef          	jal	500052ac <net_buf_simple_add>
500030ec:	01350123          	sb	s3,2(a0)
500030f0:	00950023          	sb	s1,0(a0)
500030f4:	02c12083          	lw	ra,44(sp)
500030f8:	0084d493          	srli	s1,s1,0x8
500030fc:	009500a3          	sb	s1,1(a0)
50003100:	02012903          	lw	s2,32(sp)
50003104:	00040513          	mv	a0,s0
50003108:	02412483          	lw	s1,36(sp)
5000310c:	02812403          	lw	s0,40(sp)
50003110:	01c12983          	lw	s3,28(sp)
50003114:	01812a03          	lw	s4,24(sp)
50003118:	01412a83          	lw	s5,20(sp)
5000311c:	01012b03          	lw	s6,16(sp)
50003120:	03010113          	addi	sp,sp,48
50003124:	00008067          	ret

50003128 <bt_hci_cmd_send_sync>:
50003128:	fa010113          	addi	sp,sp,-96
5000312c:	04812c23          	sw	s0,88(sp)
50003130:	05312623          	sw	s3,76(sp)
50003134:	03712e23          	sw	s7,60(sp)
50003138:	04112e23          	sw	ra,92(sp)
5000313c:	04912a23          	sw	s1,84(sp)
50003140:	05212823          	sw	s2,80(sp)
50003144:	05412423          	sw	s4,72(sp)
50003148:	05512223          	sw	s5,68(sp)
5000314c:	05612023          	sw	s6,64(sp)
50003150:	03812c23          	sw	s8,56(sp)
50003154:	00050b93          	mv	s7,a0
50003158:	00060993          	mv	s3,a2
5000315c:	00058413          	mv	s0,a1
50003160:	00059a63          	bnez	a1,50003174 <bt_hci_cmd_send_sync+0x4c>
50003164:	e9dff0ef          	jal	50003000 <bt_hci_cmd_create>
50003168:	00050413          	mv	s0,a0
5000316c:	fc900513          	li	a0,-55 # ffffffc9 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffca>
50003170:	10040663          	beqz	s0,5000327c <bt_hci_cmd_send_sync+0x154>
50003174:	510024b7          	lui	s1,0x51002
50003178:	99448c13          	addi	s8,s1,-1644 # 51001994 <_default_esf+0x288>
5000317c:	514030ef          	jal	50006690 <k_current_get>
50003180:	01812223          	sw	s8,4(sp)
50003184:	00c45783          	lhu	a5,12(s0)
50003188:	51001b37          	lui	s6,0x51001
5000318c:	51000ab7          	lui	s5,0x51000
50003190:	51000a37          	lui	s4,0x51000
50003194:	00f12023          	sw	a5,0(sp)
50003198:	00050793          	mv	a5,a0
5000319c:	51001537          	lui	a0,0x51001
500031a0:	000b8893          	mv	a7,s7
500031a4:	00040813          	mv	a6,s0
500031a8:	99448713          	addi	a4,s1,-1644
500031ac:	550b0693          	addi	a3,s6,1360 # 51001550 <__func__.4066>
500031b0:	01c10913          	addi	s2,sp,28
500031b4:	1d0a8613          	addi	a2,s5,464 # 510001d0 <__devconfig_end+0x17c>
500031b8:	1d8a0593          	addi	a1,s4,472 # 510001d8 <__devconfig_end+0x184>
500031bc:	9b050513          	addi	a0,a0,-1616 # 510009b0 <k256+0x284>
500031c0:	d65fe0ef          	jal	50001f24 <printk>
500031c4:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
500031c8:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500031cc:	00090513          	mv	a0,s2
500031d0:	618030ef          	jal	500067e8 <k_sem_init>
500031d4:	00040513          	mv	a0,s0
500031d8:	c41ff0ef          	jal	50002e18 <net_buf_user_data>
500031dc:	01252223          	sw	s2,4(a0)
500031e0:	00040513          	mv	a0,s0
500031e4:	0b8020ef          	jal	5000529c <net_buf_ref>
500031e8:	51002537          	lui	a0,0x51002
500031ec:	00040593          	mv	a1,s0
500031f0:	c7c50513          	addi	a0,a0,-900 # 51001c7c <bt_dev+0xac>
500031f4:	7fd010ef          	jal	500051f0 <net_buf_put>
500031f8:	000025b7          	lui	a1,0x2
500031fc:	71058593          	addi	a1,a1,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
50003200:	00090513          	mv	a0,s2
50003204:	6d4030ef          	jal	500068d8 <k_sem_take>
50003208:	488030ef          	jal	50006690 <k_current_get>
5000320c:	00050913          	mv	s2,a0
50003210:	00040513          	mv	a0,s0
50003214:	c05ff0ef          	jal	50002e18 <net_buf_user_data>
50003218:	00154883          	lbu	a7,1(a0)
5000321c:	51001537          	lui	a0,0x51001
50003220:	00090793          	mv	a5,s2
50003224:	000b8813          	mv	a6,s7
50003228:	99448713          	addi	a4,s1,-1644
5000322c:	550b0693          	addi	a3,s6,1360
50003230:	1d0a8613          	addi	a2,s5,464
50003234:	1d8a0593          	addi	a1,s4,472
50003238:	01812023          	sw	s8,0(sp)
5000323c:	9e450513          	addi	a0,a0,-1564 # 510009e4 <k256+0x2b8>
50003240:	ce5fe0ef          	jal	50001f24 <printk>
50003244:	00040513          	mv	a0,s0
50003248:	bd1ff0ef          	jal	50002e18 <net_buf_user_data>
5000324c:	00154783          	lbu	a5,1(a0)
50003250:	00078a63          	beqz	a5,50003264 <bt_hci_cmd_send_sync+0x13c>
50003254:	00040513          	mv	a0,s0
50003258:	7bd010ef          	jal	50005214 <net_buf_unref>
5000325c:	ffb00513          	li	a0,-5 # fffffffb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffc>
50003260:	01c0006f          	j	5000327c <bt_hci_cmd_send_sync+0x154>
50003264:	00098663          	beqz	s3,50003270 <bt_hci_cmd_send_sync+0x148>
50003268:	0089a023          	sw	s0,0(s3)
5000326c:	00c0006f          	j	50003278 <bt_hci_cmd_send_sync+0x150>
50003270:	00040513          	mv	a0,s0
50003274:	7a1010ef          	jal	50005214 <net_buf_unref>
50003278:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000327c:	05c12083          	lw	ra,92(sp)
50003280:	05812403          	lw	s0,88(sp)
50003284:	05412483          	lw	s1,84(sp)
50003288:	05012903          	lw	s2,80(sp)
5000328c:	04c12983          	lw	s3,76(sp)
50003290:	04812a03          	lw	s4,72(sp)
50003294:	04412a83          	lw	s5,68(sp)
50003298:	04012b03          	lw	s6,64(sp)
5000329c:	03c12b83          	lw	s7,60(sp)
500032a0:	03812c03          	lw	s8,56(sp)
500032a4:	06010113          	addi	sp,sp,96
500032a8:	00008067          	ret

500032ac <set_random_address>:
500032ac:	fe010113          	addi	sp,sp,-32
500032b0:	00112e23          	sw	ra,28(sp)
500032b4:	00812c23          	sw	s0,24(sp)
500032b8:	00912a23          	sw	s1,20(sp)
500032bc:	01212823          	sw	s2,16(sp)
500032c0:	01512223          	sw	s5,4(sp)
500032c4:	00050913          	mv	s2,a0
500032c8:	01312623          	sw	s3,12(sp)
500032cc:	01412423          	sw	s4,8(sp)
500032d0:	3c0030ef          	jal	50006690 <k_current_get>
500032d4:	00050413          	mv	s0,a0
500032d8:	00090513          	mv	a0,s2
500032dc:	9fdff0ef          	jal	50002cd8 <bt_addr_str>
500032e0:	510024b7          	lui	s1,0x51002
500032e4:	00050813          	mv	a6,a0
500032e8:	51002737          	lui	a4,0x51002
500032ec:	510016b7          	lui	a3,0x51001
500032f0:	51000637          	lui	a2,0x51000
500032f4:	510005b7          	lui	a1,0x51000
500032f8:	51001537          	lui	a0,0x51001
500032fc:	bd048493          	addi	s1,s1,-1072 # 51001bd0 <bt_dev>
50003300:	99470893          	addi	a7,a4,-1644 # 51001994 <_default_esf+0x288>
50003304:	00040793          	mv	a5,s0
50003308:	99470713          	addi	a4,a4,-1644
5000330c:	65c68693          	addi	a3,a3,1628 # 5100165c <__func__.4089>
50003310:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50003314:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50003318:	a1850513          	addi	a0,a0,-1512 # 51000a18 <k256+0x2ec>
5000331c:	00848a93          	addi	s5,s1,8
50003320:	c05fe0ef          	jal	50001f24 <printk>
50003324:	00600613          	li	a2,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003328:	000a8593          	mv	a1,s5
5000332c:	00090513          	mv	a0,s2
50003330:	8ccfd0ef          	jal	500003fc <memcmp>
50003334:	00050413          	mv	s0,a0
50003338:	06050263          	beqz	a0,5000339c <set_random_address+0xf0>
5000333c:	000029b7          	lui	s3,0x2
50003340:	00598993          	addi	s3,s3,5 # 2005 <CONFIG_ISR_STACK_SIZE+0x1805>
50003344:	00600593          	li	a1,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003348:	00098513          	mv	a0,s3
5000334c:	cb5ff0ef          	jal	50003000 <bt_hci_cmd_create>
50003350:	00050a13          	mv	s4,a0
50003354:	fc900413          	li	s0,-55 # ffffffc9 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffca>
50003358:	04050263          	beqz	a0,5000339c <set_random_address+0xf0>
5000335c:	00600613          	li	a2,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003360:	00090593          	mv	a1,s2
50003364:	00850513          	addi	a0,a0,8
50003368:	75d010ef          	jal	500052c4 <net_buf_simple_add_mem>
5000336c:	00000613          	li	a2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003370:	000a0593          	mv	a1,s4
50003374:	00098513          	mv	a0,s3
50003378:	db1ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
5000337c:	00050413          	mv	s0,a0
50003380:	00051e63          	bnez	a0,5000339c <set_random_address+0xf0>
50003384:	00600613          	li	a2,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003388:	00090593          	mv	a1,s2
5000338c:	000a8513          	mv	a0,s5
50003390:	8b0fd0ef          	jal	50000440 <memcpy>
50003394:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50003398:	00f483a3          	sb	a5,7(s1)
5000339c:	01c12083          	lw	ra,28(sp)
500033a0:	00040513          	mv	a0,s0
500033a4:	01412483          	lw	s1,20(sp)
500033a8:	01812403          	lw	s0,24(sp)
500033ac:	01012903          	lw	s2,16(sp)
500033b0:	00c12983          	lw	s3,12(sp)
500033b4:	00812a03          	lw	s4,8(sp)
500033b8:	00412a83          	lw	s5,4(sp)
500033bc:	02010113          	addi	sp,sp,32
500033c0:	00008067          	ret

500033c4 <bt_hci_stop_scanning>:
500033c4:	fd010113          	addi	sp,sp,-48
500033c8:	02912223          	sw	s1,36(sp)
500033cc:	510024b7          	lui	s1,0x51002
500033d0:	c3c48493          	addi	s1,s1,-964 # 51001c3c <bt_dev+0x6c>
500033d4:	00048513          	mv	a0,s1
500033d8:	02112623          	sw	ra,44(sp)
500033dc:	02812423          	sw	s0,40(sp)
500033e0:	03212023          	sw	s2,32(sp)
500033e4:	01312e23          	sw	s3,28(sp)
500033e8:	304020ef          	jal	500056ec <atomic_get>
500033ec:	c07517b3          	p.extractu	a5,a0,0,7
500033f0:	fbb00513          	li	a0,-69 # ffffffbb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffbc>
500033f4:	08078863          	beqz	a5,50003484 <bt_hci_stop_scanning+0xc0>
500033f8:	00002437          	lui	s0,0x2
500033fc:	00c40413          	addi	s0,s0,12 # 200c <CONFIG_ISR_STACK_SIZE+0x180c>
50003400:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50003404:	00040513          	mv	a0,s0
50003408:	bf9ff0ef          	jal	50003000 <bt_hci_cmd_create>
5000340c:	00050913          	mv	s2,a0
50003410:	fc900513          	li	a0,-55 # ffffffc9 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffca>
50003414:	06090863          	beqz	s2,50003484 <bt_hci_stop_scanning+0xc0>
50003418:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
5000341c:	00890513          	addi	a0,s2,8
50003420:	68d010ef          	jal	500052ac <net_buf_simple_add>
50003424:	00050993          	mv	s3,a0
50003428:	00200613          	li	a2,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
5000342c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003430:	8a8fd0ef          	jal	500004d8 <memset>
50003434:	000980a3          	sb	zero,1(s3)
50003438:	00098023          	sb	zero,0(s3)
5000343c:	00c10613          	addi	a2,sp,12
50003440:	00090593          	mv	a1,s2
50003444:	00040513          	mv	a0,s0
50003448:	ce1ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
5000344c:	02051c63          	bnez	a0,50003484 <bt_hci_stop_scanning+0xc0>
50003450:	00c12703          	lw	a4,12(sp)
50003454:	00872783          	lw	a5,8(a4)
50003458:	0007c403          	lbu	s0,0(a5)
5000345c:	00041e63          	bnez	s0,50003478 <bt_hci_stop_scanning+0xb4>
50003460:	f7f00593          	li	a1,-129 # ffffff7f <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffff80>
50003464:	00048513          	mv	a0,s1
50003468:	2d0020ef          	jal	50005738 <atomic_and>
5000346c:	dff00593          	li	a1,-513 # fffffdff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffe00>
50003470:	00048513          	mv	a0,s1
50003474:	2c4020ef          	jal	50005738 <atomic_and>
50003478:	00c12503          	lw	a0,12(sp)
5000347c:	599010ef          	jal	50005214 <net_buf_unref>
50003480:	00040513          	mv	a0,s0
50003484:	02c12083          	lw	ra,44(sp)
50003488:	02812403          	lw	s0,40(sp)
5000348c:	02412483          	lw	s1,36(sp)
50003490:	02012903          	lw	s2,32(sp)
50003494:	01c12983          	lw	s3,28(sp)
50003498:	03010113          	addi	sp,sp,48
5000349c:	00008067          	ret

500034a0 <bt_le_scan_update>:
500034a0:	ff010113          	addi	sp,sp,-16
500034a4:	00812423          	sw	s0,8(sp)
500034a8:	51002437          	lui	s0,0x51002
500034ac:	c3c40413          	addi	s0,s0,-964 # 51001c3c <bt_dev+0x6c>
500034b0:	00040513          	mv	a0,s0
500034b4:	00112623          	sw	ra,12(sp)
500034b8:	234020ef          	jal	500056ec <atomic_get>
500034bc:	c0851533          	p.extractu	a0,a0,0,8
500034c0:	02051263          	bnez	a0,500034e4 <bt_le_scan_update+0x44>
500034c4:	00040513          	mv	a0,s0
500034c8:	224020ef          	jal	500056ec <atomic_get>
500034cc:	c0751533          	p.extractu	a0,a0,0,7
500034d0:	00050a63          	beqz	a0,500034e4 <bt_le_scan_update+0x44>
500034d4:	00c12083          	lw	ra,12(sp)
500034d8:	00812403          	lw	s0,8(sp)
500034dc:	01010113          	addi	sp,sp,16
500034e0:	ee5ff06f          	j	500033c4 <bt_hci_stop_scanning>
500034e4:	00c12083          	lw	ra,12(sp)
500034e8:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500034ec:	00812403          	lw	s0,8(sp)
500034f0:	01010113          	addi	sp,sp,16
500034f4:	00008067          	ret

500034f8 <bt_addr_le_create_static>:
500034f8:	ff010113          	addi	sp,sp,-16
500034fc:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50003500:	00812423          	sw	s0,8(sp)
50003504:	00112623          	sw	ra,12(sp)
50003508:	00050413          	mv	s0,a0
5000350c:	00600593          	li	a1,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003510:	00f500ab          	p.sb	a5,1(a0!)
50003514:	2d1010ef          	jal	50004fe4 <bt_rand>
50003518:	00051863          	bnez	a0,50003528 <bt_addr_le_create_static+0x30>
5000351c:	00644783          	lbu	a5,6(s0)
50003520:	f267c7b3          	p.bset	a5,a5,25,6
50003524:	00f40323          	sb	a5,6(s0)
50003528:	00c12083          	lw	ra,12(sp)
5000352c:	00812403          	lw	s0,8(sp)
50003530:	01010113          	addi	sp,sp,16
50003534:	00008067          	ret

50003538 <hci_init>:
50003538:	f8010113          	addi	sp,sp,-128
5000353c:	00001537          	lui	a0,0x1
50003540:	03410613          	addi	a2,sp,52
50003544:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003548:	c0350513          	addi	a0,a0,-1021 # c03 <CONFIG_ISR_STACK_SIZE+0x403>
5000354c:	06812c23          	sw	s0,120(sp)
50003550:	06112e23          	sw	ra,124(sp)
50003554:	06912a23          	sw	s1,116(sp)
50003558:	07212823          	sw	s2,112(sp)
5000355c:	07312623          	sw	s3,108(sp)
50003560:	07412423          	sw	s4,104(sp)
50003564:	07512223          	sw	s5,100(sp)
50003568:	07612023          	sw	s6,96(sp)
5000356c:	05712e23          	sw	s7,92(sp)
50003570:	05812c23          	sw	s8,88(sp)
50003574:	05912a23          	sw	s9,84(sp)
50003578:	bb1ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
5000357c:	00050413          	mv	s0,a0
50003580:	26051263          	bnez	a0,500037e4 <hci_init+0x2ac>
50003584:	03412703          	lw	a4,52(sp)
50003588:	00872783          	lw	a5,8(a4)
5000358c:	0007c403          	lbu	s0,0(a5)
50003590:	51002937          	lui	s2,0x51002
50003594:	0fc030ef          	jal	50006690 <k_current_get>
50003598:	51000ab7          	lui	s5,0x51000
5000359c:	51000a37          	lui	s4,0x51000
500035a0:	510019b7          	lui	s3,0x51001
500035a4:	510016b7          	lui	a3,0x51001
500035a8:	00050793          	mv	a5,a0
500035ac:	99490893          	addi	a7,s2,-1644 # 51001994 <_default_esf+0x288>
500035b0:	00040813          	mv	a6,s0
500035b4:	99490713          	addi	a4,s2,-1644
500035b8:	64868693          	addi	a3,a3,1608 # 51001648 <__func__.4113>
500035bc:	1d0a8613          	addi	a2,s5,464 # 510001d0 <__devconfig_end+0x17c>
500035c0:	1d8a0593          	addi	a1,s4,472 # 510001d8 <__devconfig_end+0x184>
500035c4:	a3098513          	addi	a0,s3,-1488 # 51000a30 <k256+0x304>
500035c8:	95dfe0ef          	jal	50001f24 <printk>
500035cc:	00041e63          	bnez	s0,500035e8 <hci_init+0xb0>
500035d0:	51002537          	lui	a0,0x51002
500035d4:	510027b7          	lui	a5,0x51002
500035d8:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
500035dc:	c3c50513          	addi	a0,a0,-964 # 51001c3c <bt_dev+0x6c>
500035e0:	d207a223          	sw	zero,-732(a5) # 51001d24 <scan_dev_found_cb>
500035e4:	110020ef          	jal	500056f4 <atomic_set>
500035e8:	03412503          	lw	a0,52(sp)
500035ec:	00001b37          	lui	s6,0x1
500035f0:	425010ef          	jal	50005214 <net_buf_unref>
500035f4:	03410613          	addi	a2,sp,52
500035f8:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500035fc:	003b0513          	addi	a0,s6,3 # 1003 <CONFIG_ISR_STACK_SIZE+0x803>
50003600:	b29ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003604:	00050413          	mv	s0,a0
50003608:	1c051e63          	bnez	a0,500037e4 <hci_init+0x2ac>
5000360c:	03412703          	lw	a4,52(sp)
50003610:	00872403          	lw	s0,8(a4)
50003614:	510024b7          	lui	s1,0x51002
50003618:	078030ef          	jal	50006690 <k_current_get>
5000361c:	0014480b          	p.lbu	a6,1(s0!)
50003620:	510016b7          	lui	a3,0x51001
50003624:	00050793          	mv	a5,a0
50003628:	99490893          	addi	a7,s2,-1644
5000362c:	99490713          	addi	a4,s2,-1644
50003630:	4e068693          	addi	a3,a3,1248 # 510014e0 <__func__.4237>
50003634:	1d0a8613          	addi	a2,s5,464
50003638:	1d8a0593          	addi	a1,s4,472
5000363c:	a3098513          	addi	a0,s3,-1488
50003640:	bd048493          	addi	s1,s1,-1072 # 51001bd0 <bt_dev>
50003644:	8e1fe0ef          	jal	50001f24 <printk>
50003648:	00040593          	mv	a1,s0
5000364c:	00800613          	li	a2,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50003650:	01648513          	addi	a0,s1,22
50003654:	dedfc0ef          	jal	50000440 <memcpy>
50003658:	03412503          	lw	a0,52(sp)
5000365c:	3b9010ef          	jal	50005214 <net_buf_unref>
50003660:	03410613          	addi	a2,sp,52
50003664:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003668:	001b0513          	addi	a0,s6,1
5000366c:	abdff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003670:	00050413          	mv	s0,a0
50003674:	16051863          	bnez	a0,500037e4 <hci_init+0x2ac>
50003678:	03412703          	lw	a4,52(sp)
5000367c:	00872403          	lw	s0,8(a4)
50003680:	010030ef          	jal	50006690 <k_current_get>
50003684:	00050793          	mv	a5,a0
50003688:	00044803          	lbu	a6,0(s0)
5000368c:	510028b7          	lui	a7,0x51002
50003690:	510016b7          	lui	a3,0x51001
50003694:	51000637          	lui	a2,0x51000
50003698:	510005b7          	lui	a1,0x51000
5000369c:	51001537          	lui	a0,0x51001
500036a0:	99488893          	addi	a7,a7,-1644 # 51001994 <_default_esf+0x288>
500036a4:	4a468693          	addi	a3,a3,1188 # 510014a4 <__func__.4217>
500036a8:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
500036ac:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
500036b0:	99490713          	addi	a4,s2,-1644
500036b4:	a3050513          	addi	a0,a0,-1488 # 51000a30 <k256+0x304>
500036b8:	86dfe0ef          	jal	50001f24 <printk>
500036bc:	00144783          	lbu	a5,1(s0)
500036c0:	03412503          	lw	a0,52(sp)
500036c4:	00f48723          	sb	a5,14(s1)
500036c8:	00344783          	lbu	a5,3(s0)
500036cc:	00244703          	lbu	a4,2(s0)
500036d0:	00879793          	slli	a5,a5,0x8
500036d4:	00e7e7b3          	or	a5,a5,a4
500036d8:	00f49823          	sh	a5,16(s1)
500036dc:	00444783          	lbu	a5,4(s0)
500036e0:	00f487a3          	sb	a5,15(s1)
500036e4:	00844783          	lbu	a5,8(s0)
500036e8:	00744703          	lbu	a4,7(s0)
500036ec:	00879793          	slli	a5,a5,0x8
500036f0:	00e7e7b3          	or	a5,a5,a4
500036f4:	00f49923          	sh	a5,18(s1)
500036f8:	00644783          	lbu	a5,6(s0)
500036fc:	00544703          	lbu	a4,5(s0)
50003700:	00879793          	slli	a5,a5,0x8
50003704:	00e7e7b3          	or	a5,a5,a4
50003708:	00f49a23          	sh	a5,20(s1)
5000370c:	309010ef          	jal	50005214 <net_buf_unref>
50003710:	03410613          	addi	a2,sp,52
50003714:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003718:	009b0513          	addi	a0,s6,9
5000371c:	a0dff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003720:	00050413          	mv	s0,a0
50003724:	0c051063          	bnez	a0,500037e4 <hci_init+0x2ac>
50003728:	03412703          	lw	a4,52(sp)
5000372c:	00872403          	lw	s0,8(a4)
50003730:	761020ef          	jal	50006690 <k_current_get>
50003734:	0014480b          	p.lbu	a6,1(s0!)
50003738:	510016b7          	lui	a3,0x51001
5000373c:	00050793          	mv	a5,a0
50003740:	99490893          	addi	a7,s2,-1644
50003744:	99490713          	addi	a4,s2,-1644
50003748:	5bc68693          	addi	a3,a3,1468 # 510015bc <__func__.4222>
5000374c:	1d0a8613          	addi	a2,s5,464
50003750:	1d8a0593          	addi	a1,s4,472
50003754:	a3098513          	addi	a0,s3,-1488
50003758:	fccfe0ef          	jal	50001f24 <printk>
5000375c:	00040593          	mv	a1,s0
50003760:	00600613          	li	a2,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
50003764:	00148513          	addi	a0,s1,1
50003768:	cd9fc0ef          	jal	50000440 <memcpy>
5000376c:	03412503          	lw	a0,52(sp)
50003770:	00048023          	sb	zero,0(s1)
50003774:	2a1010ef          	jal	50005214 <net_buf_unref>
50003778:	03410613          	addi	a2,sp,52
5000377c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003780:	002b0513          	addi	a0,s6,2
50003784:	9a5ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003788:	00050413          	mv	s0,a0
5000378c:	04051c63          	bnez	a0,500037e4 <hci_init+0x2ac>
50003790:	03412703          	lw	a4,52(sp)
50003794:	00872403          	lw	s0,8(a4)
50003798:	6f9020ef          	jal	50006690 <k_current_get>
5000379c:	0014480b          	p.lbu	a6,1(s0!)
500037a0:	510016b7          	lui	a3,0x51001
500037a4:	00050793          	mv	a5,a0
500037a8:	99490893          	addi	a7,s2,-1644
500037ac:	99490713          	addi	a4,s2,-1644
500037b0:	4bc68693          	addi	a3,a3,1212 # 510014bc <__func__.4232>
500037b4:	1d0a8613          	addi	a2,s5,464
500037b8:	1d8a0593          	addi	a1,s4,472
500037bc:	a3098513          	addi	a0,s3,-1488
500037c0:	f64fe0ef          	jal	50001f24 <printk>
500037c4:	00040593          	mv	a1,s0
500037c8:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
500037cc:	01e48513          	addi	a0,s1,30
500037d0:	c71fc0ef          	jal	50000440 <memcpy>
500037d4:	03412503          	lw	a0,52(sp)
500037d8:	23d010ef          	jal	50005214 <net_buf_unref>
500037dc:	758010ef          	jal	50004f34 <prng_init>
500037e0:	00050413          	mv	s0,a0
500037e4:	60041663          	bnez	s0,50003df0 <hci_init+0x8b8>
500037e8:	51002a37          	lui	s4,0x51002
500037ec:	bd0a0793          	addi	a5,s4,-1072 # 51001bd0 <bt_dev>
500037f0:	01a7c783          	lbu	a5,26(a5)
500037f4:	bd0a0493          	addi	s1,s4,-1072
500037f8:	0407f793          	andi	a5,a5,64
500037fc:	04079063          	bnez	a5,5000383c <hci_init+0x304>
50003800:	510007b7          	lui	a5,0x51000
50003804:	51000737          	lui	a4,0x51000
50003808:	510026b7          	lui	a3,0x51002
5000380c:	51000637          	lui	a2,0x51000
50003810:	510005b7          	lui	a1,0x51000
50003814:	51001537          	lui	a0,0x51001
50003818:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
5000381c:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50003820:	cd468693          	addi	a3,a3,-812 # 51001cd4 <__func__.4261>
50003824:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50003828:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
5000382c:	a5050513          	addi	a0,a0,-1456 # 51000a50 <k256+0x324>
50003830:	ef4fe0ef          	jal	50001f24 <printk>
50003834:	fed00413          	li	s0,-19 # ffffffed <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffee>
50003838:	5b80006f          	j	50003df0 <hci_init+0x8b8>
5000383c:	00002537          	lui	a0,0x2
50003840:	03410613          	addi	a2,sp,52
50003844:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003848:	00350513          	addi	a0,a0,3 # 2003 <CONFIG_ISR_STACK_SIZE+0x1803>
5000384c:	8ddff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003850:	00050413          	mv	s0,a0
50003854:	1e051a63          	bnez	a0,50003a48 <hci_init+0x510>
50003858:	03412703          	lw	a4,52(sp)
5000385c:	00872403          	lw	s0,8(a4)
50003860:	51002937          	lui	s2,0x51002
50003864:	62d020ef          	jal	50006690 <k_current_get>
50003868:	51000b37          	lui	s6,0x51000
5000386c:	0014480b          	p.lbu	a6,1(s0!)
50003870:	51000ab7          	lui	s5,0x51000
50003874:	510019b7          	lui	s3,0x51001
50003878:	510016b7          	lui	a3,0x51001
5000387c:	00050793          	mv	a5,a0
50003880:	99490893          	addi	a7,s2,-1644 # 51001994 <_default_esf+0x288>
50003884:	99490713          	addi	a4,s2,-1644
50003888:	5a068693          	addi	a3,a3,1440 # 510015a0 <__func__.4227>
5000388c:	1d0b0613          	addi	a2,s6,464 # 510001d0 <__devconfig_end+0x17c>
50003890:	1d8a8593          	addi	a1,s5,472 # 510001d8 <__devconfig_end+0x184>
50003894:	a3098513          	addi	a0,s3,-1488 # 51000a30 <k256+0x304>
50003898:	e8cfe0ef          	jal	50001f24 <printk>
5000389c:	00800613          	li	a2,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
500038a0:	00040593          	mv	a1,s0
500038a4:	07048513          	addi	a0,s1,112
500038a8:	b99fc0ef          	jal	50000440 <memcpy>
500038ac:	03412503          	lw	a0,52(sp)
500038b0:	165010ef          	jal	50005214 <net_buf_unref>
500038b4:	01a4c783          	lbu	a5,26(s1)
500038b8:	0207f793          	andi	a5,a5,32
500038bc:	00078a63          	beqz	a5,500038d0 <hci_init+0x398>
500038c0:	03a4c783          	lbu	a5,58(s1)
500038c4:	0087f793          	andi	a5,a5,8
500038c8:	04079e63          	bnez	a5,50003924 <hci_init+0x3ec>
500038cc:	1080006f          	j	500039d4 <hci_init+0x49c>
500038d0:	00001437          	lui	s0,0x1
500038d4:	c6d40413          	addi	s0,s0,-915 # c6d <CONFIG_ISR_STACK_SIZE+0x46d>
500038d8:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
500038dc:	00040513          	mv	a0,s0
500038e0:	f20ff0ef          	jal	50003000 <bt_hci_cmd_create>
500038e4:	00050b93          	mv	s7,a0
500038e8:	00051663          	bnez	a0,500038f4 <hci_init+0x3bc>
500038ec:	fc900413          	li	s0,-55 # ffffffc9 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffca>
500038f0:	5000006f          	j	50003df0 <hci_init+0x8b8>
500038f4:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
500038f8:	00850513          	addi	a0,a0,8
500038fc:	1b1010ef          	jal	500052ac <net_buf_simple_add>
50003900:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50003904:	00f50023          	sb	a5,0(a0)
50003908:	000500a3          	sb	zero,1(a0)
5000390c:	00000613          	li	a2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003910:	000b8593          	mv	a1,s7
50003914:	00040513          	mv	a0,s0
50003918:	811ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
5000391c:	fa0502e3          	beqz	a0,500038c0 <hci_init+0x388>
50003920:	1240006f          	j	50003a44 <hci_init+0x50c>
50003924:	00002537          	lui	a0,0x2
50003928:	03410613          	addi	a2,sp,52
5000392c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003930:	01c50513          	addi	a0,a0,28 # 201c <CONFIG_ISR_STACK_SIZE+0x181c>
50003934:	ff4ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003938:	00050413          	mv	s0,a0
5000393c:	10051663          	bnez	a0,50003a48 <hci_init+0x510>
50003940:	03412703          	lw	a4,52(sp)
50003944:	00872403          	lw	s0,8(a4)
50003948:	549020ef          	jal	50006690 <k_current_get>
5000394c:	00044803          	lbu	a6,0(s0)
50003950:	510016b7          	lui	a3,0x51001
50003954:	00050793          	mv	a5,a0
50003958:	99490713          	addi	a4,s2,-1644
5000395c:	61c68693          	addi	a3,a3,1564 # 5100161c <__func__.4242>
50003960:	1d0b0613          	addi	a2,s6,464
50003964:	1d8a8593          	addi	a1,s5,472
50003968:	99490893          	addi	a7,s2,-1644
5000396c:	a3098513          	addi	a0,s3,-1488
50003970:	db4fe0ef          	jal	50001f24 <printk>
50003974:	00244783          	lbu	a5,2(s0)
50003978:	00144683          	lbu	a3,1(s0)
5000397c:	00344583          	lbu	a1,3(s0)
50003980:	00879793          	slli	a5,a5,0x8
50003984:	00d7e733          	or	a4,a5,a3
50003988:	01059593          	slli	a1,a1,0x10
5000398c:	00e5e7b3          	or	a5,a1,a4
50003990:	00444583          	lbu	a1,4(s0)
50003994:	00644703          	lbu	a4,6(s0)
50003998:	01859593          	slli	a1,a1,0x18
5000399c:	00544603          	lbu	a2,5(s0)
500039a0:	00f5e5b3          	or	a1,a1,a5
500039a4:	00744783          	lbu	a5,7(s0)
500039a8:	00871713          	slli	a4,a4,0x8
500039ac:	01079793          	slli	a5,a5,0x10
500039b0:	00c766b3          	or	a3,a4,a2
500039b4:	00d7e733          	or	a4,a5,a3
500039b8:	00844783          	lbu	a5,8(s0)
500039bc:	03412503          	lw	a0,52(sp)
500039c0:	01879793          	slli	a5,a5,0x18
500039c4:	00e7e7b3          	or	a5,a5,a4
500039c8:	06b4ac23          	sw	a1,120(s1)
500039cc:	06f4ae23          	sw	a5,124(s1)
500039d0:	045010ef          	jal	50005214 <net_buf_unref>
500039d4:	00002537          	lui	a0,0x2
500039d8:	00800593          	li	a1,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
500039dc:	00150513          	addi	a0,a0,1 # 2001 <CONFIG_ISR_STACK_SIZE+0x1801>
500039e0:	e20ff0ef          	jal	50003000 <bt_hci_cmd_create>
500039e4:	00050413          	mv	s0,a0
500039e8:	f00502e3          	beqz	a0,500038ec <hci_init+0x3b4>
500039ec:	00800593          	li	a1,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
500039f0:	00b50533          	add	a0,a0,a1
500039f4:	0b9010ef          	jal	500052ac <net_buf_simple_add>
500039f8:	0404c703          	lbu	a4,64(s1)
500039fc:	00200793          	li	a5,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50003a00:	00677713          	andi	a4,a4,6
50003a04:	00673463          	p.bneimm	a4,6,50003a0c <hci_init+0x4d4>
50003a08:	18200793          	li	a5,386 # 182 <_STRUCT_KERNEL_SIZE+0x66>
50003a0c:	00f50023          	sb	a5,0(a0)
50003a10:	0087d793          	srli	a5,a5,0x8
50003a14:	00f500a3          	sb	a5,1(a0)
50003a18:	00050123          	sb	zero,2(a0)
50003a1c:	000501a3          	sb	zero,3(a0)
50003a20:	00050223          	sb	zero,4(a0)
50003a24:	000502a3          	sb	zero,5(a0)
50003a28:	00050323          	sb	zero,6(a0)
50003a2c:	000503a3          	sb	zero,7(a0)
50003a30:	00002537          	lui	a0,0x2
50003a34:	00000613          	li	a2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003a38:	00040593          	mv	a1,s0
50003a3c:	00150513          	addi	a0,a0,1 # 2001 <CONFIG_ISR_STACK_SIZE+0x1801>
50003a40:	ee8ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003a44:	00050413          	mv	s0,a0
50003a48:	3a041463          	bnez	s0,50003df0 <hci_init+0x8b8>
50003a4c:	00001937          	lui	s2,0x1
50003a50:	c0190913          	addi	s2,s2,-1023 # c01 <CONFIG_ISR_STACK_SIZE+0x401>
50003a54:	00800593          	li	a1,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50003a58:	00090513          	mv	a0,s2
50003a5c:	da4ff0ef          	jal	50003000 <bt_hci_cmd_create>
50003a60:	00050993          	mv	s3,a0
50003a64:	fc900413          	li	s0,-55 # ffffffc9 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffca>
50003a68:	38050463          	beqz	a0,50003df0 <hci_init+0x8b8>
50003a6c:	00800593          	li	a1,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50003a70:	00b50533          	add	a0,a0,a1
50003a74:	039010ef          	jal	500052ac <net_buf_simple_add>
50003a78:	f8000793          	li	a5,-128 # ffffff80 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffff81>
50003a7c:	00f500a3          	sb	a5,1(a0)
50003a80:	00200793          	li	a5,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50003a84:	00f501a3          	sb	a5,3(a0)
50003a88:	02000793          	li	a5,32 # 20 <CONFIG_NUM_IRQS>
50003a8c:	00050023          	sb	zero,0(a0)
50003a90:	00050123          	sb	zero,2(a0)
50003a94:	00050223          	sb	zero,4(a0)
50003a98:	000502a3          	sb	zero,5(a0)
50003a9c:	00050323          	sb	zero,6(a0)
50003aa0:	00f503a3          	sb	a5,7(a0)
50003aa4:	00000613          	li	a2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003aa8:	00098593          	mv	a1,s3
50003aac:	00090513          	mv	a0,s2
50003ab0:	e78ff0ef          	jal	50003128 <bt_hci_cmd_send_sync>
50003ab4:	00050413          	mv	s0,a0
50003ab8:	32051c63          	bnez	a0,50003df0 <hci_init+0x8b8>
50003abc:	00700613          	li	a2,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003ac0:	01c10593          	addi	a1,sp,28
50003ac4:	bd0a0513          	addi	a0,s4,-1072
50003ac8:	00012e23          	sw	zero,28(sp)
50003acc:	02011023          	sh	zero,32(sp)
50003ad0:	02010123          	sb	zero,34(sp)
50003ad4:	929fc0ef          	jal	500003fc <memcmp>
50003ad8:	51002937          	lui	s2,0x51002
50003adc:	510009b7          	lui	s3,0x51000
50003ae0:	04051463          	bnez	a0,50003b28 <hci_init+0x5f0>
50003ae4:	3ad020ef          	jal	50006690 <k_current_get>
50003ae8:	00050793          	mv	a5,a0
50003aec:	51001ab7          	lui	s5,0x51001
50003af0:	51000cb7          	lui	s9,0x51000
50003af4:	51001537          	lui	a0,0x51001
50003af8:	99490713          	addi	a4,s2,-1644 # 51001994 <_default_esf+0x288>
50003afc:	99490813          	addi	a6,s2,-1644
50003b00:	6aca8693          	addi	a3,s5,1708 # 510016ac <__func__.4309>
50003b04:	1d0c8613          	addi	a2,s9,464 # 510001d0 <__devconfig_end+0x17c>
50003b08:	1d898593          	addi	a1,s3,472 # 510001d8 <__devconfig_end+0x184>
50003b0c:	a8450513          	addi	a0,a0,-1404 # 51000a84 <k256+0x358>
50003b10:	c14fe0ef          	jal	50001f24 <printk>
50003b14:	51002737          	lui	a4,0x51002
50003b18:	3dc72783          	lw	a5,988(a4) # 510023dc <bt_storage>
50003b1c:	00070b93          	mv	s7,a4
50003b20:	02079c63          	bnez	a5,50003b58 <hci_init+0x620>
50003b24:	0500006f          	j	50003b74 <hci_init+0x63c>
50003b28:	510025b7          	lui	a1,0x51002
50003b2c:	00700613          	li	a2,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003b30:	ce458593          	addi	a1,a1,-796 # 51001ce4 <__func__.4320+0x8>
50003b34:	02410513          	addi	a0,sp,36
50003b38:	909fc0ef          	jal	50000440 <memcpy>
50003b3c:	51002537          	lui	a0,0x51002
50003b40:	00700613          	li	a2,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003b44:	02410593          	addi	a1,sp,36
50003b48:	bd050513          	addi	a0,a0,-1072 # 51001bd0 <bt_dev>
50003b4c:	8b1fc0ef          	jal	500003fc <memcmp>
50003b50:	f8050ae3          	beqz	a0,50003ae4 <hci_init+0x5ac>
50003b54:	1400006f          	j	50003c94 <hci_init+0x75c>
50003b58:	0007a783          	lw	a5,0(a5)
50003b5c:	00700693          	li	a3,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003b60:	bd0a0613          	addi	a2,s4,-1072
50003b64:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003b68:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003b6c:	000780e7          	jalr	a5
50003b70:	0a752e63          	p.beqimm	a0,7,50003c2c <hci_init+0x6f4>
50003b74:	31d020ef          	jal	50006690 <k_current_get>
50003b78:	00050793          	mv	a5,a0
50003b7c:	51001b37          	lui	s6,0x51001
50003b80:	51001537          	lui	a0,0x51001
50003b84:	99490813          	addi	a6,s2,-1644
50003b88:	99490713          	addi	a4,s2,-1644
50003b8c:	57cb0693          	addi	a3,s6,1404 # 5100157c <__func__.4294>
50003b90:	1d0c8613          	addi	a2,s9,464
50003b94:	1d898593          	addi	a1,s3,472
50003b98:	acc50513          	addi	a0,a0,-1332 # 51000acc <k256+0x3a0>
50003b9c:	b88fe0ef          	jal	50001f24 <printk>
50003ba0:	bd0a0513          	addi	a0,s4,-1072
50003ba4:	51000c37          	lui	s8,0x51000
50003ba8:	951ff0ef          	jal	500034f8 <bt_addr_le_create_static>
50003bac:	20051663          	bnez	a0,50003db8 <hci_init+0x880>
50003bb0:	3dcba783          	lw	a5,988(s7)
50003bb4:	04078663          	beqz	a5,50003c00 <hci_init+0x6c8>
50003bb8:	51002637          	lui	a2,0x51002
50003bbc:	0047a783          	lw	a5,4(a5)
50003bc0:	00700693          	li	a3,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003bc4:	bd060613          	addi	a2,a2,-1072 # 51001bd0 <bt_dev>
50003bc8:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003bcc:	000780e7          	jalr	a5
50003bd0:	04752e63          	p.beqimm	a0,7,50003c2c <hci_init+0x6f4>
50003bd4:	510007b7          	lui	a5,0x51000
50003bd8:	51000737          	lui	a4,0x51000
50003bdc:	51000637          	lui	a2,0x51000
50003be0:	51001537          	lui	a0,0x51001
50003be4:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50003be8:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50003bec:	57cb0693          	addi	a3,s6,1404
50003bf0:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50003bf4:	1d8c0593          	addi	a1,s8,472 # 510001d8 <__devconfig_end+0x184>
50003bf8:	b0850513          	addi	a0,a0,-1272 # 51000b08 <k256+0x3dc>
50003bfc:	02c0006f          	j	50003c28 <hci_init+0x6f0>
50003c00:	510007b7          	lui	a5,0x51000
50003c04:	51000737          	lui	a4,0x51000
50003c08:	51000637          	lui	a2,0x51000
50003c0c:	51001537          	lui	a0,0x51001
50003c10:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50003c14:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
50003c18:	57cb0693          	addi	a3,s6,1404
50003c1c:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50003c20:	1d8c0593          	addi	a1,s8,472
50003c24:	b3850513          	addi	a0,a0,-1224 # 51000b38 <k256+0x40c>
50003c28:	afcfe0ef          	jal	50001f24 <printk>
50003c2c:	0004c783          	lbu	a5,0(s1)
50003c30:	0017ba63          	p.bneimm	a5,1,50003c44 <hci_init+0x70c>
50003c34:	0064c783          	lbu	a5,6(s1)
50003c38:	0c000713          	li	a4,192 # c0 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x40>
50003c3c:	0c07f793          	andi	a5,a5,192
50003c40:	02e78e63          	beq	a5,a4,50003c7c <hci_init+0x744>
50003c44:	510007b7          	lui	a5,0x51000
50003c48:	51000737          	lui	a4,0x51000
50003c4c:	510016b7          	lui	a3,0x51001
50003c50:	51000637          	lui	a2,0x51000
50003c54:	51001537          	lui	a0,0x51001
50003c58:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50003c5c:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50003c60:	57c68693          	addi	a3,a3,1404 # 5100157c <__func__.4294>
50003c64:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50003c68:	1d898593          	addi	a1,s3,472
50003c6c:	b7050513          	addi	a0,a0,-1168 # 51000b70 <k256+0x444>
50003c70:	ab4fe0ef          	jal	50001f24 <printk>
50003c74:	fea00413          	li	s0,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
50003c78:	14c0006f          	j	50003dc4 <hci_init+0x88c>
50003c7c:	00148513          	addi	a0,s1,1
50003c80:	e2cff0ef          	jal	500032ac <set_random_address>
50003c84:	12051e63          	bnez	a0,50003dc0 <hci_init+0x888>
50003c88:	00400593          	li	a1,4 # 4 <__NANO_ESF_gp_OFFSET>
50003c8c:	06c48513          	addi	a0,s1,108
50003c90:	285010ef          	jal	50005714 <atomic_or>
50003c94:	0004c683          	lbu	a3,0(s1)
50003c98:	00068a63          	beqz	a3,50003cac <hci_init+0x774>
50003c9c:	0216b263          	p.bneimm	a3,1,50003cc0 <hci_init+0x788>
50003ca0:	510015b7          	lui	a1,0x51001
50003ca4:	85458593          	addi	a1,a1,-1964 # 51000854 <k256+0x128>
50003ca8:	00c0006f          	j	50003cb4 <hci_init+0x77c>
50003cac:	510015b7          	lui	a1,0x51001
50003cb0:	84c58593          	addi	a1,a1,-1972 # 5100084c <k256+0x120>
50003cb4:	02c10513          	addi	a0,sp,44
50003cb8:	f0cfc0ef          	jal	500003c4 <strcpy>
50003cbc:	0180006f          	j	50003cd4 <hci_init+0x79c>
50003cc0:	51001637          	lui	a2,0x51001
50003cc4:	85c60613          	addi	a2,a2,-1956 # 5100085c <k256+0x130>
50003cc8:	00700593          	li	a1,7 # 7 <CONFIG_BLUETOOTH_HCI_TX_PRIO>
50003ccc:	02c10513          	addi	a0,sp,44
50003cd0:	a90fe0ef          	jal	50001f60 <snprintk>
50003cd4:	02c10613          	addi	a2,sp,44
50003cd8:	00c12223          	sw	a2,4(sp)
50003cdc:	0014c603          	lbu	a2,1(s1)
50003ce0:	0024c883          	lbu	a7,2(s1)
50003ce4:	0034c803          	lbu	a6,3(s1)
50003ce8:	0044c783          	lbu	a5,4(s1)
50003cec:	0054c703          	lbu	a4,5(s1)
50003cf0:	0064c683          	lbu	a3,6(s1)
50003cf4:	00c12023          	sw	a2,0(sp)
50003cf8:	51001637          	lui	a2,0x51001
50003cfc:	86460613          	addi	a2,a2,-1948 # 51000864 <k256+0x138>
50003d00:	01b00593          	li	a1,27 # 1b <__NANO_ESF_t3_OFFSET+0x3>
50003d04:	03410513          	addi	a0,sp,52
50003d08:	a58fe0ef          	jal	50001f60 <snprintk>
50003d0c:	51001ab7          	lui	s5,0x51001
50003d10:	51001a37          	lui	s4,0x51001
50003d14:	51001537          	lui	a0,0x51001
50003d18:	99490813          	addi	a6,s2,-1644
50003d1c:	03410793          	addi	a5,sp,52
50003d20:	99490713          	addi	a4,s2,-1644
50003d24:	69ca8693          	addi	a3,s5,1692 # 5100169c <__func__.4304>
50003d28:	bb4a0613          	addi	a2,s4,-1100 # 51000bb4 <k256+0x488>
50003d2c:	1d898593          	addi	a1,s3,472
50003d30:	bbc50513          	addi	a0,a0,-1092 # 51000bbc <k256+0x490>
50003d34:	9f0fe0ef          	jal	50001f24 <printk>
50003d38:	00e4cb03          	lbu	s6,14(s1)
50003d3c:	99490b93          	addi	s7,s2,-1644
50003d40:	000b0513          	mv	a0,s6
50003d44:	8e8ff0ef          	jal	50002e2c <ver_str>
50003d48:	0144d783          	lhu	a5,20(s1)
50003d4c:	0104d883          	lhu	a7,16(s1)
50003d50:	00f12023          	sw	a5,0(sp)
50003d54:	00050793          	mv	a5,a0
50003d58:	51001537          	lui	a0,0x51001
50003d5c:	000b0813          	mv	a6,s6
50003d60:	99490713          	addi	a4,s2,-1644
50003d64:	69ca8693          	addi	a3,s5,1692
50003d68:	bb4a0613          	addi	a2,s4,-1100
50003d6c:	1d898593          	addi	a1,s3,472
50003d70:	01712223          	sw	s7,4(sp)
50003d74:	bdc50513          	addi	a0,a0,-1060 # 51000bdc <k256+0x4b0>
50003d78:	9acfe0ef          	jal	50001f24 <printk>
50003d7c:	00f4cb03          	lbu	s6,15(s1)
50003d80:	000b0513          	mv	a0,s6
50003d84:	8a8ff0ef          	jal	50002e2c <ver_str>
50003d88:	00050793          	mv	a5,a0
50003d8c:	0124d883          	lhu	a7,18(s1)
50003d90:	51001537          	lui	a0,0x51001
50003d94:	01712023          	sw	s7,0(sp)
50003d98:	000b0813          	mv	a6,s6
50003d9c:	99490713          	addi	a4,s2,-1644
50003da0:	69ca8693          	addi	a3,s5,1692
50003da4:	bb4a0613          	addi	a2,s4,-1100
50003da8:	1d898593          	addi	a1,s3,472
50003dac:	c2c50513          	addi	a0,a0,-980 # 51000c2c <k256+0x500>
50003db0:	974fe0ef          	jal	50001f24 <printk>
50003db4:	03c0006f          	j	50003df0 <hci_init+0x8b8>
50003db8:	00050413          	mv	s0,a0
50003dbc:	0080006f          	j	50003dc4 <hci_init+0x88c>
50003dc0:	00050413          	mv	s0,a0
50003dc4:	510007b7          	lui	a5,0x51000
50003dc8:	51000737          	lui	a4,0x51000
50003dcc:	51000637          	lui	a2,0x51000
50003dd0:	51001537          	lui	a0,0x51001
50003dd4:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50003dd8:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50003ddc:	6aca8693          	addi	a3,s5,1708
50003de0:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50003de4:	1d898593          	addi	a1,s3,472
50003de8:	c6450513          	addi	a0,a0,-924 # 51000c64 <k256+0x538>
50003dec:	938fe0ef          	jal	50001f24 <printk>
50003df0:	07c12083          	lw	ra,124(sp)
50003df4:	00040513          	mv	a0,s0
50003df8:	07412483          	lw	s1,116(sp)
50003dfc:	07812403          	lw	s0,120(sp)
50003e00:	07012903          	lw	s2,112(sp)
50003e04:	06c12983          	lw	s3,108(sp)
50003e08:	06812a03          	lw	s4,104(sp)
50003e0c:	06412a83          	lw	s5,100(sp)
50003e10:	06012b03          	lw	s6,96(sp)
50003e14:	05c12b83          	lw	s7,92(sp)
50003e18:	05812c03          	lw	s8,88(sp)
50003e1c:	05412c83          	lw	s9,84(sp)
50003e20:	08010113          	addi	sp,sp,128
50003e24:	00008067          	ret

50003e28 <init_work>:
50003e28:	ff010113          	addi	sp,sp,-16
50003e2c:	00812423          	sw	s0,8(sp)
50003e30:	00112623          	sw	ra,12(sp)
50003e34:	f04ff0ef          	jal	50003538 <hci_init>
50003e38:	00050413          	mv	s0,a0
50003e3c:	00051e63          	bnez	a0,50003e58 <init_work+0x30>
50003e40:	51002537          	lui	a0,0x51002
50003e44:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50003e48:	c3c50513          	addi	a0,a0,-964 # 51001c3c <bt_dev+0x6c>
50003e4c:	0c9010ef          	jal	50005714 <atomic_or>
50003e50:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50003e54:	e4cff0ef          	jal	500034a0 <bt_le_scan_update>
50003e58:	510027b7          	lui	a5,0x51002
50003e5c:	d1c7a303          	lw	t1,-740(a5) # 51001d1c <ready_cb>
50003e60:	00030c63          	beqz	t1,50003e78 <init_work+0x50>
50003e64:	00040513          	mv	a0,s0
50003e68:	00c12083          	lw	ra,12(sp)
50003e6c:	00812403          	lw	s0,8(sp)
50003e70:	01010113          	addi	sp,sp,16
50003e74:	00030067          	jr	t1
50003e78:	00c12083          	lw	ra,12(sp)
50003e7c:	00812403          	lw	s0,8(sp)
50003e80:	01010113          	addi	sp,sp,16
50003e84:	00008067          	ret

50003e88 <bt_send>:
50003e88:	fe010113          	addi	sp,sp,-32
50003e8c:	00112e23          	sw	ra,28(sp)
50003e90:	00812c23          	sw	s0,24(sp)
50003e94:	00912a23          	sw	s1,20(sp)
50003e98:	00050413          	mv	s0,a0
50003e9c:	7f4020ef          	jal	50006690 <k_current_get>
50003ea0:	00050493          	mv	s1,a0
50003ea4:	00040513          	mv	a0,s0
50003ea8:	f71fe0ef          	jal	50002e18 <net_buf_user_data>
50003eac:	51002737          	lui	a4,0x51002
50003eb0:	99470793          	addi	a5,a4,-1644 # 51001994 <_default_esf+0x288>
50003eb4:	00c45883          	lhu	a7,12(s0)
50003eb8:	00f12223          	sw	a5,4(sp)
50003ebc:	00054783          	lbu	a5,0(a0)
50003ec0:	510026b7          	lui	a3,0x51002
50003ec4:	51000637          	lui	a2,0x51000
50003ec8:	510005b7          	lui	a1,0x51000
50003ecc:	51001537          	lui	a0,0x51001
50003ed0:	00f12023          	sw	a5,0(sp)
50003ed4:	00040813          	mv	a6,s0
50003ed8:	00048793          	mv	a5,s1
50003edc:	99470713          	addi	a4,a4,-1644
50003ee0:	ccc68693          	addi	a3,a3,-820 # 51001ccc <__func__.4315>
50003ee4:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50003ee8:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50003eec:	c9450513          	addi	a0,a0,-876 # 51000c94 <k256+0x568>
50003ef0:	834fe0ef          	jal	50001f24 <printk>
50003ef4:	510027b7          	lui	a5,0x51002
50003ef8:	c907a303          	lw	t1,-880(a5) # 51001c90 <bt_dev+0xc0>
50003efc:	00040513          	mv	a0,s0
50003f00:	01c12083          	lw	ra,28(sp)
50003f04:	01812403          	lw	s0,24(sp)
50003f08:	01412483          	lw	s1,20(sp)
50003f0c:	00c32303          	lw	t1,12(t1)
50003f10:	02010113          	addi	sp,sp,32
50003f14:	00030067          	jr	t1

50003f18 <hci_tx_thread>:
50003f18:	fa010113          	addi	sp,sp,-96
50003f1c:	04112e23          	sw	ra,92(sp)
50003f20:	04812c23          	sw	s0,88(sp)
50003f24:	04912a23          	sw	s1,84(sp)
50003f28:	05212823          	sw	s2,80(sp)
50003f2c:	05412423          	sw	s4,72(sp)
50003f30:	05512223          	sw	s5,68(sp)
50003f34:	05612023          	sw	s6,64(sp)
50003f38:	03712e23          	sw	s7,60(sp)
50003f3c:	03812c23          	sw	s8,56(sp)
50003f40:	03a12823          	sw	s10,48(sp)
50003f44:	03b12623          	sw	s11,44(sp)
50003f48:	05312623          	sw	s3,76(sp)
50003f4c:	03912a23          	sw	s9,52(sp)
50003f50:	740020ef          	jal	50006690 <k_current_get>
50003f54:	51002437          	lui	s0,0x51002
50003f58:	00050793          	mv	a5,a0
50003f5c:	51002ab7          	lui	s5,0x51002
50003f60:	51001bb7          	lui	s7,0x51001
50003f64:	51000937          	lui	s2,0x51000
50003f68:	510004b7          	lui	s1,0x51000
50003f6c:	51001537          	lui	a0,0x51001
50003f70:	bd0a8a13          	addi	s4,s5,-1072 # 51001bd0 <bt_dev>
50003f74:	99440813          	addi	a6,s0,-1644 # 51001994 <_default_esf+0x288>
50003f78:	99440713          	addi	a4,s0,-1644
50003f7c:	600b8693          	addi	a3,s7,1536 # 51001600 <__func__.4209>
50003f80:	1d090613          	addi	a2,s2,464 # 510001d0 <__devconfig_end+0x17c>
50003f84:	1d848593          	addi	a1,s1,472 # 510001d8 <__devconfig_end+0x184>
50003f88:	d2050513          	addi	a0,a0,-736 # 51000d20 <k256+0x5f4>
50003f8c:	51001b37          	lui	s6,0x51001
50003f90:	f95fd0ef          	jal	50001f24 <printk>
50003f94:	51002c37          	lui	s8,0x51002
50003f98:	000b0d13          	mv	s10,s6
50003f9c:	bd0a8a93          	addi	s5,s5,-1072
50003fa0:	080a0d93          	addi	s11,s4,128
50003fa4:	bc0c0b93          	addi	s7,s8,-1088 # 51001bc0 <events.4208>
50003fa8:	004ba783          	lw	a5,4(s7)
50003fac:	c8c027b3          	p.insert	a5,zero,4,12
50003fb0:	00fba223          	sw	a5,4(s7)
50003fb4:	6dc020ef          	jal	50006690 <k_current_get>
50003fb8:	00050793          	mv	a5,a0
50003fbc:	51001637          	lui	a2,0x51001
50003fc0:	51001537          	lui	a0,0x51001
50003fc4:	60060693          	addi	a3,a2,1536 # 51001600 <__func__.4209>
50003fc8:	1d848593          	addi	a1,s1,472
50003fcc:	1d090613          	addi	a2,s2,464
50003fd0:	99440893          	addi	a7,s0,-1644
50003fd4:	00100813          	li	a6,1 # 1 <CONFIG_ARCH>
50003fd8:	99440713          	addi	a4,s0,-1644
50003fdc:	d4050513          	addi	a0,a0,-704 # 51000d40 <k256+0x614>
50003fe0:	f45fd0ef          	jal	50001f24 <printk>
50003fe4:	fff00613          	li	a2,-1
50003fe8:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50003fec:	bc0c0513          	addi	a0,s8,-1088
50003ff0:	510009b7          	lui	s3,0x51000
50003ff4:	3a1010ef          	jal	50005b94 <k_poll>
50003ff8:	04050063          	beqz	a0,50004038 <hci_tx_thread+0x120>
50003ffc:	510007b7          	lui	a5,0x51000
50004000:	51000737          	lui	a4,0x51000
50004004:	510016b7          	lui	a3,0x51001
50004008:	51000637          	lui	a2,0x51000
5000400c:	51001537          	lui	a0,0x51001
50004010:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004014:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004018:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
5000401c:	60068693          	addi	a3,a3,1536 # 51001600 <__func__.4209>
50004020:	1d898593          	addi	a1,s3,472 # 510001d8 <__devconfig_end+0x184>
50004024:	d7450513          	addi	a0,a0,-652 # 51000d74 <k256+0x648>
50004028:	efdfd0ef          	jal	50001f24 <printk>
5000402c:	00001637          	lui	a2,0x1
50004030:	bcd60613          	addi	a2,a2,-1075 # bcd <CONFIG_ISR_STACK_SIZE+0x3cd>
50004034:	2700006f          	j	500042a4 <hci_tx_thread+0x38c>
50004038:	658020ef          	jal	50006690 <k_current_get>
5000403c:	510027b7          	lui	a5,0x51002
50004040:	99478893          	addi	a7,a5,-1644 # 51001994 <_default_esf+0x288>
50004044:	51001cb7          	lui	s9,0x51001
50004048:	00050793          	mv	a5,a0
5000404c:	51000637          	lui	a2,0x51000
50004050:	51001537          	lui	a0,0x51001
50004054:	00100813          	li	a6,1 # 1 <CONFIG_ARCH>
50004058:	99440713          	addi	a4,s0,-1644
5000405c:	6b8c8693          	addi	a3,s9,1720 # 510016b8 <__func__.4193>
50004060:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50004064:	1d898593          	addi	a1,s3,472
50004068:	de050513          	addi	a0,a0,-544 # 51000de0 <k256+0x6b4>
5000406c:	eb9fd0ef          	jal	50001f24 <printk>
50004070:	620020ef          	jal	50006690 <k_current_get>
50004074:	00050793          	mv	a5,a0
50004078:	004ba803          	lw	a6,4(s7)
5000407c:	51001537          	lui	a0,0x51001
50004080:	99440893          	addi	a7,s0,-1644
50004084:	c8c81833          	p.extractu	a6,a6,4,12
50004088:	99440713          	addi	a4,s0,-1644
5000408c:	6b8c8693          	addi	a3,s9,1720
50004090:	1d090613          	addi	a2,s2,464
50004094:	1d848593          	addi	a1,s1,472
50004098:	e0050513          	addi	a0,a0,-512 # 51000e00 <k256+0x6d4>
5000409c:	e89fd0ef          	jal	50001f24 <printk>
500040a0:	004ba783          	lw	a5,4(s7)
500040a4:	c8c797b3          	p.extractu	a5,a5,4,12
500040a8:	1a27ae63          	p.beqimm	a5,2,50004264 <hci_tx_thread+0x34c>
500040ac:	0287ac63          	p.beqimm	a5,8,500040e4 <hci_tx_thread+0x1cc>
500040b0:	1a078a63          	beqz	a5,50004264 <hci_tx_thread+0x34c>
500040b4:	51000837          	lui	a6,0x51000
500040b8:	51000737          	lui	a4,0x51000
500040bc:	51000637          	lui	a2,0x51000
500040c0:	51001537          	lui	a0,0x51001
500040c4:	27080813          	addi	a6,a6,624 # 51000270 <__devconfig_end+0x21c>
500040c8:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
500040cc:	6b8c8693          	addi	a3,s9,1720
500040d0:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
500040d4:	1d848593          	addi	a1,s1,472
500040d8:	e2450513          	addi	a0,a0,-476 # 51000e24 <k256+0x6f8>
500040dc:	e49fd0ef          	jal	50001f24 <printk>
500040e0:	1840006f          	j	50004264 <hci_tx_thread+0x34c>
500040e4:	004bc783          	lbu	a5,4(s7)
500040e8:	16079e63          	bnez	a5,50004264 <hci_tx_thread+0x34c>
500040ec:	5a4020ef          	jal	50006690 <k_current_get>
500040f0:	00050793          	mv	a5,a0
500040f4:	51001537          	lui	a0,0x51001
500040f8:	99440813          	addi	a6,s0,-1644
500040fc:	99440713          	addi	a4,s0,-1644
50004100:	63cb0693          	addi	a3,s6,1596 # 5100163c <__func__.4188>
50004104:	1d090613          	addi	a2,s2,464
50004108:	1d848593          	addi	a1,s1,472
5000410c:	e5850513          	addi	a0,a0,-424 # 51000e58 <k256+0x72c>
50004110:	e15fd0ef          	jal	50001f24 <printk>
50004114:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004118:	0aca0513          	addi	a0,s4,172
5000411c:	044010ef          	jal	50005160 <net_buf_get>
50004120:	00050993          	mv	s3,a0
50004124:	14050463          	beqz	a0,5000426c <hci_tx_thread+0x354>
50004128:	568020ef          	jal	50006690 <k_current_get>
5000412c:	00050793          	mv	a5,a0
50004130:	51001537          	lui	a0,0x51001
50004134:	99440813          	addi	a6,s0,-1644
50004138:	99440713          	addi	a4,s0,-1644
5000413c:	63cb0693          	addi	a3,s6,1596
50004140:	1d090613          	addi	a2,s2,464
50004144:	1d848593          	addi	a1,s1,472
50004148:	e8450513          	addi	a0,a0,-380 # 51000e84 <k256+0x758>
5000414c:	dd9fd0ef          	jal	50001f24 <printk>
50004150:	fff00593          	li	a1,-1
50004154:	080a0513          	addi	a0,s4,128
50004158:	780020ef          	jal	500068d8 <k_sem_take>
5000415c:	094a2783          	lw	a5,148(s4)
50004160:	0c079463          	bnez	a5,50004228 <hci_tx_thread+0x310>
50004164:	00098513          	mv	a0,s3
50004168:	134010ef          	jal	5000529c <net_buf_ref>
5000416c:	08aaaa23          	sw	a0,148(s5)
50004170:	520020ef          	jal	50006690 <k_current_get>
50004174:	00a12e23          	sw	a0,28(sp)
50004178:	00098513          	mv	a0,s3
5000417c:	c9dfe0ef          	jal	50002e18 <net_buf_user_data>
50004180:	99440793          	addi	a5,s0,-1644
50004184:	00255803          	lhu	a6,2(a0)
50004188:	00f12023          	sw	a5,0(sp)
5000418c:	51001537          	lui	a0,0x51001
50004190:	01c12783          	lw	a5,28(sp)
50004194:	00098893          	mv	a7,s3
50004198:	99440713          	addi	a4,s0,-1644
5000419c:	63cd0693          	addi	a3,s10,1596
500041a0:	1d090613          	addi	a2,s2,464
500041a4:	1d848593          	addi	a1,s1,472
500041a8:	eb050513          	addi	a0,a0,-336 # 51000eb0 <k256+0x784>
500041ac:	d79fd0ef          	jal	50001f24 <printk>
500041b0:	00098513          	mv	a0,s3
500041b4:	cd5ff0ef          	jal	50003e88 <bt_send>
500041b8:	00050793          	mv	a5,a0
500041bc:	0a050463          	beqz	a0,50004264 <hci_tx_thread+0x34c>
500041c0:	51000837          	lui	a6,0x51000
500041c4:	51000737          	lui	a4,0x51000
500041c8:	51000637          	lui	a2,0x51000
500041cc:	510005b7          	lui	a1,0x51000
500041d0:	51001537          	lui	a0,0x51001
500041d4:	27080813          	addi	a6,a6,624 # 51000270 <__devconfig_end+0x21c>
500041d8:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
500041dc:	63cb0693          	addi	a3,s6,1596
500041e0:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
500041e4:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
500041e8:	cec50513          	addi	a0,a0,-788 # 51000cec <k256+0x5c0>
500041ec:	d39fd0ef          	jal	50001f24 <printk>
500041f0:	000d8513          	mv	a0,s11
500041f4:	60c020ef          	jal	50006800 <k_sem_give>
500041f8:	00098513          	mv	a0,s3
500041fc:	c1dfe0ef          	jal	50002e18 <net_buf_user_data>
50004200:	00255503          	lhu	a0,2(a0)
50004204:	00000613          	li	a2,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004208:	01f00593          	li	a1,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
5000420c:	c79fe0ef          	jal	50002e84 <hci_cmd_done>
50004210:	094aa503          	lw	a0,148(s5)
50004214:	000010ef          	jal	50005214 <net_buf_unref>
50004218:	00098513          	mv	a0,s3
5000421c:	080aaa23          	sw	zero,148(s5)
50004220:	7f5000ef          	jal	50005214 <net_buf_unref>
50004224:	0400006f          	j	50004264 <hci_tx_thread+0x34c>
50004228:	510007b7          	lui	a5,0x51000
5000422c:	51000737          	lui	a4,0x51000
50004230:	51000637          	lui	a2,0x51000
50004234:	51001537          	lui	a0,0x51001
50004238:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
5000423c:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004240:	63cb0693          	addi	a3,s6,1596
50004244:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004248:	1d848593          	addi	a1,s1,472
5000424c:	ef050513          	addi	a0,a0,-272 # 51000ef0 <k256+0x7c4>
50004250:	cd5fd0ef          	jal	50001f24 <printk>
50004254:	094a2503          	lw	a0,148(s4)
50004258:	7bd000ef          	jal	50005214 <net_buf_unref>
5000425c:	080a2a23          	sw	zero,148(s4)
50004260:	f05ff06f          	j	50004164 <hci_tx_thread+0x24c>
50004264:	3bc020ef          	jal	50006620 <k_yield>
50004268:	d3dff06f          	j	50003fa4 <hci_tx_thread+0x8c>
5000426c:	510007b7          	lui	a5,0x51000
50004270:	51000737          	lui	a4,0x51000
50004274:	510016b7          	lui	a3,0x51001
50004278:	51000637          	lui	a2,0x51000
5000427c:	51001537          	lui	a0,0x51001
50004280:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004284:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004288:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
5000428c:	63c68693          	addi	a3,a3,1596 # 5100163c <__func__.4188>
50004290:	1d848593          	addi	a1,s1,472
50004294:	f1c50513          	addi	a0,a0,-228 # 51000f1c <k256+0x7f0>
50004298:	c8dfd0ef          	jal	50001f24 <printk>
5000429c:	00001637          	lui	a2,0x1
500042a0:	b6960613          	addi	a2,a2,-1175 # b69 <CONFIG_ISR_STACK_SIZE+0x369>
500042a4:	510015b7          	lui	a1,0x51001
500042a8:	51001537          	lui	a0,0x51001
500042ac:	da058593          	addi	a1,a1,-608 # 51000da0 <k256+0x674>
500042b0:	dd450513          	addi	a0,a0,-556 # 51000dd4 <k256+0x6a8>
500042b4:	c71fd0ef          	jal	50001f24 <printk>
500042b8:	510015b7          	lui	a1,0x51001
500042bc:	70c58593          	addi	a1,a1,1804 # 5100170c <_default_esf>
500042c0:	00500513          	li	a0,5 # 5 <__NANO_ESF_gp_OFFSET+0x1>
500042c4:	194010ef          	jal	50005458 <_NanoFatalErrorHandler>

500042c8 <bt_recv>:
500042c8:	fa010113          	addi	sp,sp,-96
500042cc:	04912a23          	sw	s1,84(sp)
500042d0:	510024b7          	lui	s1,0x51002
500042d4:	04112e23          	sw	ra,92(sp)
500042d8:	04812c23          	sw	s0,88(sp)
500042dc:	05212823          	sw	s2,80(sp)
500042e0:	00050413          	mv	s0,a0
500042e4:	05312623          	sw	s3,76(sp)
500042e8:	05412423          	sw	s4,72(sp)
500042ec:	05512223          	sw	s5,68(sp)
500042f0:	05612023          	sw	s6,64(sp)
500042f4:	03712e23          	sw	s7,60(sp)
500042f8:	03812c23          	sw	s8,56(sp)
500042fc:	03912a23          	sw	s9,52(sp)
50004300:	03a12823          	sw	s10,48(sp)
50004304:	03b12623          	sw	s11,44(sp)
50004308:	388020ef          	jal	50006690 <k_current_get>
5000430c:	99448793          	addi	a5,s1,-1644 # 51001994 <_default_esf+0x288>
50004310:	00c45883          	lhu	a7,12(s0)
50004314:	51002937          	lui	s2,0x51002
50004318:	00f12023          	sw	a5,0(sp)
5000431c:	51000a37          	lui	s4,0x51000
50004320:	00050793          	mv	a5,a0
50004324:	510009b7          	lui	s3,0x51000
50004328:	51001537          	lui	a0,0x51001
5000432c:	99448713          	addi	a4,s1,-1644
50004330:	00040813          	mv	a6,s0
50004334:	cdc90693          	addi	a3,s2,-804 # 51001cdc <__func__.4320>
50004338:	1d0a0613          	addi	a2,s4,464 # 510001d0 <__devconfig_end+0x17c>
5000433c:	1d898593          	addi	a1,s3,472 # 510001d8 <__devconfig_end+0x184>
50004340:	f4450513          	addi	a0,a0,-188 # 51000f44 <k256+0x818>
50004344:	be1fd0ef          	jal	50001f24 <printk>
50004348:	00644503          	lbu	a0,6(s0)
5000434c:	509000ef          	jal	50005054 <net_buf_pool_get>
50004350:	01a55703          	lhu	a4,26(a0)
50004354:	00300793          	li	a5,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
50004358:	02e7ea63          	bltu	a5,a4,5000438c <bt_recv+0xc4>
5000435c:	510007b7          	lui	a5,0x51000
50004360:	51000737          	lui	a4,0x51000
50004364:	51000637          	lui	a2,0x51000
50004368:	51001537          	lui	a0,0x51001
5000436c:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004370:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004374:	cdc90693          	addi	a3,s2,-804
50004378:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
5000437c:	1d898593          	addi	a1,s3,472
50004380:	f6850513          	addi	a0,a0,-152 # 51000f68 <k256+0x83c>
50004384:	ba1fd0ef          	jal	50001f24 <printk>
50004388:	0dc0006f          	j	50004464 <bt_recv+0x19c>
5000438c:	00040513          	mv	a0,s0
50004390:	a89fe0ef          	jal	50002e18 <net_buf_user_data>
50004394:	00054a83          	lbu	s5,0(a0)
50004398:	081abe63          	p.bneimm	s5,1,50004434 <bt_recv+0x16c>
5000439c:	00842b83          	lw	s7,8(s0)
500043a0:	2f0020ef          	jal	50006690 <k_current_get>
500043a4:	00050793          	mv	a5,a0
500043a8:	51001c37          	lui	s8,0x51001
500043ac:	000bc803          	lbu	a6,0(s7)
500043b0:	51001537          	lui	a0,0x51001
500043b4:	99448893          	addi	a7,s1,-1644
500043b8:	99448713          	addi	a4,s1,-1644
500043bc:	610c0693          	addi	a3,s8,1552 # 51001610 <__func__.4179>
500043c0:	1d0a0613          	addi	a2,s4,464
500043c4:	1d898593          	addi	a1,s3,472
500043c8:	f9450513          	addi	a0,a0,-108 # 51000f94 <k256+0x868>
500043cc:	b59fd0ef          	jal	50001f24 <printk>
500043d0:	000bc783          	lbu	a5,0(s7)
500043d4:	ff278793          	addi	a5,a5,-14
500043d8:	08faee63          	bltu	s5,a5,50004474 <bt_recv+0x1ac>
500043dc:	510007b7          	lui	a5,0x51000
500043e0:	51000737          	lui	a4,0x51000
500043e4:	51000637          	lui	a2,0x51000
500043e8:	51001537          	lui	a0,0x51001
500043ec:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
500043f0:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
500043f4:	610c0693          	addi	a3,s8,1552
500043f8:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
500043fc:	1d898593          	addi	a1,s3,472
50004400:	0fc50513          	addi	a0,a0,252 # 510010fc <k256+0x9d0>
50004404:	b21fd0ef          	jal	50001f24 <printk>
50004408:	00001637          	lui	a2,0x1
5000440c:	510015b7          	lui	a1,0x51001
50004410:	51001537          	lui	a0,0x51001
50004414:	da058593          	addi	a1,a1,-608 # 51000da0 <k256+0x674>
50004418:	b0460613          	addi	a2,a2,-1276 # b04 <CONFIG_ISR_STACK_SIZE+0x304>
5000441c:	dd450513          	addi	a0,a0,-556 # 51000dd4 <k256+0x6a8>
50004420:	b05fd0ef          	jal	50001f24 <printk>
50004424:	510015b7          	lui	a1,0x51001
50004428:	70c58593          	addi	a1,a1,1804 # 5100170c <_default_esf>
5000442c:	00500513          	li	a0,5 # 5 <__NANO_ESF_gp_OFFSET+0x1>
50004430:	028010ef          	jal	50005458 <_NanoFatalErrorHandler>
50004434:	51000837          	lui	a6,0x51000
50004438:	51000737          	lui	a4,0x51000
5000443c:	51000637          	lui	a2,0x51000
50004440:	51001537          	lui	a0,0x51001
50004444:	27080813          	addi	a6,a6,624 # 51000270 <__devconfig_end+0x21c>
50004448:	000a8793          	mv	a5,s5
5000444c:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004450:	cdc90693          	addi	a3,s2,-804
50004454:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004458:	1d898593          	addi	a1,s3,472
5000445c:	0d850513          	addi	a0,a0,216 # 510010d8 <k256+0x9ac>
50004460:	ac5fd0ef          	jal	50001f24 <printk>
50004464:	00040513          	mv	a0,s0
50004468:	5ad000ef          	jal	50005214 <net_buf_unref>
5000446c:	fea00513          	li	a0,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
50004470:	34c0006f          	j	500047bc <bt_recv+0x4f4>
50004474:	00840913          	addi	s2,s0,8
50004478:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
5000447c:	00090513          	mv	a0,s2
50004480:	65d000ef          	jal	500052dc <net_buf_simple_pull>
50004484:	000bcc83          	lbu	s9,0(s7)
50004488:	03e00793          	li	a5,62 # 3e <CONFIG_UART_CONSOLE_INIT_PRIORITY+0x2>
5000448c:	00842b83          	lw	s7,8(s0)
50004490:	2cfc9a63          	bne	s9,a5,50004764 <bt_recv+0x49c>
50004494:	1fc020ef          	jal	50006690 <k_current_get>
50004498:	00050793          	mv	a5,a0
5000449c:	000bc803          	lbu	a6,0(s7)
500044a0:	51001c37          	lui	s8,0x51001
500044a4:	51001537          	lui	a0,0x51001
500044a8:	99448893          	addi	a7,s1,-1644
500044ac:	99448713          	addi	a4,s1,-1644
500044b0:	58cc0693          	addi	a3,s8,1420 # 5100158c <__func__.4169>
500044b4:	1d0a0613          	addi	a2,s4,464
500044b8:	1d898593          	addi	a1,s3,472
500044bc:	fb850513          	addi	a0,a0,-72 # 51000fb8 <k256+0x88c>
500044c0:	a65fd0ef          	jal	50001f24 <printk>
500044c4:	000a8593          	mv	a1,s5
500044c8:	00090513          	mv	a0,s2
500044cc:	611000ef          	jal	500052dc <net_buf_simple_pull>
500044d0:	000bca83          	lbu	s5,0(s7)
500044d4:	068aa063          	p.beqimm	s5,8,50004534 <bt_recv+0x26c>
500044d8:	0e9aae63          	p.beqimm	s5,9,500045d4 <bt_recv+0x30c>
500044dc:	222abe63          	p.bneimm	s5,2,50004718 <bt_recv+0x450>
500044e0:	00090513          	mv	a0,s2
500044e4:	619000ef          	jal	500052fc <net_buf_simple_pull_u8>
500044e8:	00098b13          	mv	s6,s3
500044ec:	00050993          	mv	s3,a0
500044f0:	1a0020ef          	jal	50006690 <k_current_get>
500044f4:	00050793          	mv	a5,a0
500044f8:	51001ab7          	lui	s5,0x51001
500044fc:	51001537          	lui	a0,0x51001
50004500:	99448893          	addi	a7,s1,-1644
50004504:	99448713          	addi	a4,s1,-1644
50004508:	00098813          	mv	a6,s3
5000450c:	68ca8693          	addi	a3,s5,1676 # 5100168c <__func__.4158>
50004510:	1d0a0613          	addi	a2,s4,464
50004514:	1d8b0593          	addi	a1,s6,472
50004518:	00450513          	addi	a0,a0,4 # 51001004 <k256+0x8d8>
5000451c:	000a0d13          	mv	s10,s4
50004520:	a05fd0ef          	jal	50001f24 <printk>
50004524:	99448493          	addi	s1,s1,-1644
50004528:	51001cb7          	lui	s9,0x51001
5000452c:	00890d93          	addi	s11,s2,8
50004530:	1e00006f          	j	50004710 <bt_recv+0x448>
50004534:	00842903          	lw	s2,8(s0)
50004538:	158020ef          	jal	50006690 <k_current_get>
5000453c:	00050793          	mv	a5,a0
50004540:	99448893          	addi	a7,s1,-1644
50004544:	99448713          	addi	a4,s1,-1644
50004548:	00094803          	lbu	a6,0(s2)
5000454c:	510016b7          	lui	a3,0x51001
50004550:	51001537          	lui	a0,0x51001
50004554:	510024b7          	lui	s1,0x51002
50004558:	50068693          	addi	a3,a3,1280 # 51001500 <__func__.4100>
5000455c:	1d0a0613          	addi	a2,s4,464
50004560:	1d898593          	addi	a1,s3,472
50004564:	fe050513          	addi	a0,a0,-32 # 51000fe0 <k256+0x8b4>
50004568:	c3c48493          	addi	s1,s1,-964 # 51001c3c <bt_dev+0x6c>
5000456c:	9b9fd0ef          	jal	50001f24 <printk>
50004570:	fef00593          	li	a1,-17 # ffffffef <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff0>
50004574:	00048513          	mv	a0,s1
50004578:	1c0010ef          	jal	50005738 <atomic_and>
5000457c:	00094783          	lbu	a5,0(s2)
50004580:	02079263          	bnez	a5,500045a4 <bt_recv+0x2dc>
50004584:	51002537          	lui	a0,0x51002
50004588:	00190593          	addi	a1,s2,1
5000458c:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
50004590:	00050513          	mv	a0,a0
50004594:	eadfb0ef          	jal	50000440 <memcpy>
50004598:	000a8593          	mv	a1,s5
5000459c:	00048513          	mv	a0,s1
500045a0:	174010ef          	jal	50005714 <atomic_or>
500045a4:	510027b7          	lui	a5,0x51002
500045a8:	d187a483          	lw	s1,-744(a5) # 51001d18 <pub_key_cb>
500045ac:	00190993          	addi	s3,s2,1
500045b0:	20048063          	beqz	s1,500047b0 <bt_recv+0x4e8>
500045b4:	00094703          	lbu	a4,0(s2)
500045b8:	0004a783          	lw	a5,0(s1)
500045bc:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500045c0:	00071463          	bnez	a4,500045c8 <bt_recv+0x300>
500045c4:	00098513          	mv	a0,s3
500045c8:	000780e7          	jalr	a5
500045cc:	0044a483          	lw	s1,4(s1)
500045d0:	fe1ff06f          	j	500045b0 <bt_recv+0x2e8>
500045d4:	00842903          	lw	s2,8(s0)
500045d8:	0b8020ef          	jal	50006690 <k_current_get>
500045dc:	00050793          	mv	a5,a0
500045e0:	00094803          	lbu	a6,0(s2)
500045e4:	510016b7          	lui	a3,0x51001
500045e8:	51001537          	lui	a0,0x51001
500045ec:	99448713          	addi	a4,s1,-1644
500045f0:	99448893          	addi	a7,s1,-1644
500045f4:	52c68693          	addi	a3,a3,1324 # 5100152c <__func__.4108>
500045f8:	1d0a0613          	addi	a2,s4,464
500045fc:	1d898593          	addi	a1,s3,472
50004600:	fe050513          	addi	a0,a0,-32 # 51000fe0 <k256+0x8b4>
50004604:	921fd0ef          	jal	50001f24 <printk>
50004608:	510027b7          	lui	a5,0x51002
5000460c:	d207a703          	lw	a4,-736(a5) # 51001d20 <dh_key_cb>
50004610:	d2078493          	addi	s1,a5,-736
50004614:	18070e63          	beqz	a4,500047b0 <bt_recv+0x4e8>
50004618:	00094783          	lbu	a5,0(s2)
5000461c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004620:	00079463          	bnez	a5,50004628 <bt_recv+0x360>
50004624:	00190513          	addi	a0,s2,1
50004628:	000700e7          	jalr	a4
5000462c:	0004a023          	sw	zero,0(s1)
50004630:	1800006f          	j	500047b0 <bt_recv+0x4e8>
50004634:	00842a03          	lw	s4,8(s0)
50004638:	00900593          	li	a1,9 # 9 <___thread_base_t_thread_state_OFFSET>
5000463c:	00090513          	mv	a0,s2
50004640:	49d000ef          	jal	500052dc <net_buf_simple_pull>
50004644:	008a4783          	lbu	a5,8(s4)
50004648:	001a0b93          	addi	s7,s4,1
5000464c:	00fa07b3          	add	a5,s4,a5
50004650:	00978c03          	lb	s8,9(a5)
50004654:	03c020ef          	jal	50006690 <k_current_get>
50004658:	00050a93          	mv	s5,a0
5000465c:	000b8513          	mv	a0,s7
50004660:	eecfe0ef          	jal	50002d4c <bt_addr_le_str>
50004664:	000a4883          	lbu	a7,0(s4)
50004668:	00912423          	sw	s1,8(sp)
5000466c:	01812223          	sw	s8,4(sp)
50004670:	008a4783          	lbu	a5,8(s4)
50004674:	51001637          	lui	a2,0x51001
50004678:	00f12023          	sw	a5,0(sp)
5000467c:	00050813          	mv	a6,a0
50004680:	000a8793          	mv	a5,s5
50004684:	00048713          	mv	a4,s1
50004688:	68c60693          	addi	a3,a2,1676 # 5100168c <__func__.4158>
5000468c:	1d8b0593          	addi	a1,s6,472
50004690:	1d0d0613          	addi	a2,s10,464
50004694:	034c8513          	addi	a0,s9,52 # 51001034 <k256+0x908>
50004698:	88dfd0ef          	jal	50001f24 <printk>
5000469c:	51002737          	lui	a4,0x51002
500046a0:	d2470a93          	addi	s5,a4,-732 # 51001d24 <scan_dev_found_cb>
500046a4:	000aa783          	lw	a5,0(s5)
500046a8:	04078863          	beqz	a5,500046f8 <bt_recv+0x430>
500046ac:	00090513          	mv	a0,s2
500046b0:	47d000ef          	jal	5000532c <net_buf_simple_headroom>
500046b4:	00c45783          	lhu	a5,12(s0)
500046b8:	00a12c23          	sw	a0,24(sp)
500046bc:	00f12e23          	sw	a5,28(sp)
500046c0:	008a4783          	lbu	a5,8(s4)
500046c4:	00090693          	mv	a3,s2
500046c8:	00f41623          	sh	a5,12(s0)
500046cc:	000a4603          	lbu	a2,0(s4)
500046d0:	000aa783          	lw	a5,0(s5)
500046d4:	000c0593          	mv	a1,s8
500046d8:	000b8513          	mv	a0,s7
500046dc:	000780e7          	jalr	a5
500046e0:	01812703          	lw	a4,24(sp)
500046e4:	df0737b3          	p.bclr	a5,a4,15,16
500046e8:	00fd87b3          	add	a5,s11,a5
500046ec:	00f42423          	sw	a5,8(s0)
500046f0:	01c12783          	lw	a5,28(sp)
500046f4:	00f41623          	sh	a5,12(s0)
500046f8:	008a4583          	lbu	a1,8(s4)
500046fc:	00090513          	mv	a0,s2
50004700:	00158593          	addi	a1,a1,1
50004704:	fff98993          	addi	s3,s3,-1
50004708:	3d5000ef          	jal	500052dc <net_buf_simple_pull>
5000470c:	0ff9f993          	andi	s3,s3,255
50004710:	f20992e3          	bnez	s3,50004634 <bt_recv+0x36c>
50004714:	09c0006f          	j	500047b0 <bt_recv+0x4e8>
50004718:	00c45483          	lhu	s1,12(s0)
5000471c:	00842503          	lw	a0,8(s0)
50004720:	00048593          	mv	a1,s1
50004724:	d20fe0ef          	jal	50002c44 <bt_hex>
50004728:	510007b7          	lui	a5,0x51000
5000472c:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004730:	00050893          	mv	a7,a0
50004734:	51000737          	lui	a4,0x51000
50004738:	51000637          	lui	a2,0x51000
5000473c:	51001537          	lui	a0,0x51001
50004740:	00f12023          	sw	a5,0(sp)
50004744:	00048813          	mv	a6,s1
50004748:	000a8793          	mv	a5,s5
5000474c:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
50004750:	58cc0693          	addi	a3,s8,1420
50004754:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
50004758:	1d898593          	addi	a1,s3,472
5000475c:	06c50513          	addi	a0,a0,108 # 5100106c <k256+0x940>
50004760:	04c0006f          	j	500047ac <bt_recv+0x4e4>
50004764:	00c45483          	lhu	s1,12(s0)
50004768:	000b8513          	mv	a0,s7
5000476c:	00048593          	mv	a1,s1
50004770:	cd4fe0ef          	jal	50002c44 <bt_hex>
50004774:	51000737          	lui	a4,0x51000
50004778:	27070713          	addi	a4,a4,624 # 51000270 <__devconfig_end+0x21c>
5000477c:	00e12023          	sw	a4,0(sp)
50004780:	00050893          	mv	a7,a0
50004784:	51000737          	lui	a4,0x51000
50004788:	51000637          	lui	a2,0x51000
5000478c:	51001537          	lui	a0,0x51001
50004790:	00048813          	mv	a6,s1
50004794:	000c8793          	mv	a5,s9
50004798:	37c70713          	addi	a4,a4,892 # 5100037c <__devconfig_end+0x328>
5000479c:	610c0693          	addi	a3,s8,1552
500047a0:	38460613          	addi	a2,a2,900 # 51000384 <__devconfig_end+0x330>
500047a4:	1d898593          	addi	a1,s3,472
500047a8:	0a450513          	addi	a0,a0,164 # 510010a4 <k256+0x978>
500047ac:	f78fd0ef          	jal	50001f24 <printk>
500047b0:	00040513          	mv	a0,s0
500047b4:	261000ef          	jal	50005214 <net_buf_unref>
500047b8:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500047bc:	05c12083          	lw	ra,92(sp)
500047c0:	05812403          	lw	s0,88(sp)
500047c4:	05412483          	lw	s1,84(sp)
500047c8:	05012903          	lw	s2,80(sp)
500047cc:	04c12983          	lw	s3,76(sp)
500047d0:	04812a03          	lw	s4,72(sp)
500047d4:	04412a83          	lw	s5,68(sp)
500047d8:	04012b03          	lw	s6,64(sp)
500047dc:	03c12b83          	lw	s7,60(sp)
500047e0:	03812c03          	lw	s8,56(sp)
500047e4:	03412c83          	lw	s9,52(sp)
500047e8:	03012d03          	lw	s10,48(sp)
500047ec:	02c12d83          	lw	s11,44(sp)
500047f0:	06010113          	addi	sp,sp,96
500047f4:	00008067          	ret

500047f8 <bt_recv_prio>:
500047f8:	fd010113          	addi	sp,sp,-48
500047fc:	02812423          	sw	s0,40(sp)
50004800:	02912223          	sw	s1,36(sp)
50004804:	02112623          	sw	ra,44(sp)
50004808:	03212023          	sw	s2,32(sp)
5000480c:	01312e23          	sw	s3,28(sp)
50004810:	01412c23          	sw	s4,24(sp)
50004814:	01512a23          	sw	s5,20(sp)
50004818:	01612823          	sw	s6,16(sp)
5000481c:	01712623          	sw	s7,12(sp)
50004820:	01812423          	sw	s8,8(sp)
50004824:	00050413          	mv	s0,a0
50004828:	00852903          	lw	s2,8(a0)
5000482c:	decfe0ef          	jal	50002e18 <net_buf_user_data>
50004830:	00054783          	lbu	a5,0(a0)
50004834:	510004b7          	lui	s1,0x51000
50004838:	0417a063          	p.beqimm	a5,1,50004878 <bt_recv_prio+0x80>
5000483c:	510007b7          	lui	a5,0x51000
50004840:	51000737          	lui	a4,0x51000
50004844:	510016b7          	lui	a3,0x51001
50004848:	51000637          	lui	a2,0x51000
5000484c:	51001537          	lui	a0,0x51001
50004850:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004854:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004858:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
5000485c:	6c868693          	addi	a3,a3,1736 # 510016c8 <__func__.4327>
50004860:	1d848593          	addi	a1,s1,472 # 510001d8 <__devconfig_end+0x184>
50004864:	13c50513          	addi	a0,a0,316 # 5100113c <k256+0xa10>
50004868:	ebcfd0ef          	jal	50001f24 <printk>
5000486c:	00001637          	lui	a2,0x1
50004870:	f3460613          	addi	a2,a2,-204 # f34 <CONFIG_ISR_STACK_SIZE+0x734>
50004874:	0440006f          	j	500048b8 <bt_recv_prio+0xc0>
50004878:	00c45703          	lhu	a4,12(s0)
5000487c:	06e7e063          	bltu	a5,a4,500048dc <bt_recv_prio+0xe4>
50004880:	510007b7          	lui	a5,0x51000
50004884:	51000737          	lui	a4,0x51000
50004888:	510016b7          	lui	a3,0x51001
5000488c:	51000637          	lui	a2,0x51000
50004890:	51001537          	lui	a0,0x51001
50004894:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004898:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
5000489c:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
500048a0:	6c868693          	addi	a3,a3,1736 # 510016c8 <__func__.4327>
500048a4:	1d848593          	addi	a1,s1,472
500048a8:	18050513          	addi	a0,a0,384 # 51001180 <k256+0xa54>
500048ac:	e78fd0ef          	jal	50001f24 <printk>
500048b0:	00001637          	lui	a2,0x1
500048b4:	f3560613          	addi	a2,a2,-203 # f35 <CONFIG_ISR_STACK_SIZE+0x735>
500048b8:	510015b7          	lui	a1,0x51001
500048bc:	51001537          	lui	a0,0x51001
500048c0:	da058593          	addi	a1,a1,-608 # 51000da0 <k256+0x674>
500048c4:	dd450513          	addi	a0,a0,-556 # 51000dd4 <k256+0x6a8>
500048c8:	e5cfd0ef          	jal	50001f24 <printk>
500048cc:	510015b7          	lui	a1,0x51001
500048d0:	70c58593          	addi	a1,a1,1804 # 5100170c <_default_esf>
500048d4:	00500513          	li	a0,5 # 5 <__NANO_ESF_gp_OFFSET+0x1>
500048d8:	381000ef          	jal	50005458 <_NanoFatalErrorHandler>
500048dc:	00094703          	lbu	a4,0(s2)
500048e0:	ff270713          	addi	a4,a4,-14
500048e4:	04e7f063          	bleu	a4,a5,50004924 <bt_recv_prio+0x12c>
500048e8:	510007b7          	lui	a5,0x51000
500048ec:	51000737          	lui	a4,0x51000
500048f0:	510016b7          	lui	a3,0x51001
500048f4:	51000637          	lui	a2,0x51000
500048f8:	51001537          	lui	a0,0x51001
500048fc:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004900:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004904:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004908:	6c868693          	addi	a3,a3,1736 # 510016c8 <__func__.4327>
5000490c:	1d848593          	addi	a1,s1,472
50004910:	20450513          	addi	a0,a0,516 # 51001204 <k256+0xad8>
50004914:	e10fd0ef          	jal	50001f24 <printk>
50004918:	00001637          	lui	a2,0x1
5000491c:	f3660613          	addi	a2,a2,-202 # f36 <CONFIG_ISR_STACK_SIZE+0x736>
50004920:	f99ff06f          	j	500048b8 <bt_recv_prio+0xc0>
50004924:	00840a93          	addi	s5,s0,8
50004928:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
5000492c:	000a8513          	mv	a0,s5
50004930:	1ad000ef          	jal	500052dc <net_buf_simple_pull>
50004934:	00094783          	lbu	a5,0(s2)
50004938:	51000bb7          	lui	s7,0x51000
5000493c:	51002937          	lui	s2,0x51002
50004940:	51001b37          	lui	s6,0x51001
50004944:	06e7be63          	p.bneimm	a5,14,500049c0 <bt_recv_prio+0x1c8>
50004948:	00842703          	lw	a4,8(s0)
5000494c:	00274983          	lbu	s3,2(a4)
50004950:	00174783          	lbu	a5,1(a4)
50004954:	00899993          	slli	s3,s3,0x8
50004958:	00f9e9b3          	or	s3,s3,a5
5000495c:	00074a03          	lbu	s4,0(a4)
50004960:	531010ef          	jal	50006690 <k_current_get>
50004964:	510016b7          	lui	a3,0x51001
50004968:	00050793          	mv	a5,a0
5000496c:	1d0b8613          	addi	a2,s7,464 # 510001d0 <__devconfig_end+0x17c>
50004970:	99490893          	addi	a7,s2,-1644 # 51001994 <_default_esf+0x288>
50004974:	00098813          	mv	a6,s3
50004978:	99490713          	addi	a4,s2,-1644
5000497c:	56868693          	addi	a3,a3,1384 # 51001568 <__func__.4127>
50004980:	1d848593          	addi	a1,s1,472
50004984:	1bcb0513          	addi	a0,s6,444 # 510011bc <k256+0xa90>
50004988:	d9cfd0ef          	jal	50001f24 <printk>
5000498c:	00300593          	li	a1,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
50004990:	000a8513          	mv	a0,s5
50004994:	149000ef          	jal	500052dc <net_buf_simple_pull>
50004998:	00842783          	lw	a5,8(s0)
5000499c:	0007c583          	lbu	a1,0(a5)
500049a0:	00040613          	mv	a2,s0
500049a4:	00098513          	mv	a0,s3
500049a8:	cdcfe0ef          	jal	50002e84 <hci_cmd_done>
500049ac:	0c0a0263          	beqz	s4,50004a70 <bt_recv_prio+0x278>
500049b0:	51002537          	lui	a0,0x51002
500049b4:	c5050513          	addi	a0,a0,-944 # 51001c50 <bt_dev+0x80>
500049b8:	649010ef          	jal	50006800 <k_sem_give>
500049bc:	0b40006f          	j	50004a70 <bt_recv_prio+0x278>
500049c0:	06f7b663          	p.bneimm	a5,15,50004a2c <bt_recv_prio+0x234>
500049c4:	00842a03          	lw	s4,8(s0)
500049c8:	003a4983          	lbu	s3,3(s4)
500049cc:	002a4783          	lbu	a5,2(s4)
500049d0:	00899993          	slli	s3,s3,0x8
500049d4:	00f9e9b3          	or	s3,s3,a5
500049d8:	001a4c03          	lbu	s8,1(s4)
500049dc:	4b5010ef          	jal	50006690 <k_current_get>
500049e0:	510016b7          	lui	a3,0x51001
500049e4:	00050793          	mv	a5,a0
500049e8:	1d0b8613          	addi	a2,s7,464
500049ec:	99490893          	addi	a7,s2,-1644
500049f0:	00098813          	mv	a6,s3
500049f4:	99490713          	addi	a4,s2,-1644
500049f8:	67068693          	addi	a3,a3,1648 # 51001670 <__func__.4134>
500049fc:	1d848593          	addi	a1,s1,472
50004a00:	1bcb0513          	addi	a0,s6,444
50004a04:	d20fd0ef          	jal	50001f24 <printk>
50004a08:	00400593          	li	a1,4 # 4 <__NANO_ESF_gp_OFFSET>
50004a0c:	000a8513          	mv	a0,s5
50004a10:	0cd000ef          	jal	500052dc <net_buf_simple_pull>
50004a14:	000a4583          	lbu	a1,0(s4)
50004a18:	00040613          	mv	a2,s0
50004a1c:	00098513          	mv	a0,s3
50004a20:	c64fe0ef          	jal	50002e84 <hci_cmd_done>
50004a24:	040c0663          	beqz	s8,50004a70 <bt_recv_prio+0x278>
50004a28:	f89ff06f          	j	500049b0 <bt_recv_prio+0x1b8>
50004a2c:	00040513          	mv	a0,s0
50004a30:	7e4000ef          	jal	50005214 <net_buf_unref>
50004a34:	510007b7          	lui	a5,0x51000
50004a38:	51000737          	lui	a4,0x51000
50004a3c:	510016b7          	lui	a3,0x51001
50004a40:	51000637          	lui	a2,0x51000
50004a44:	51001537          	lui	a0,0x51001
50004a48:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004a4c:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004a50:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004a54:	6c868693          	addi	a3,a3,1736 # 510016c8 <__func__.4327>
50004a58:	1d848593          	addi	a1,s1,472
50004a5c:	1e050513          	addi	a0,a0,480 # 510011e0 <k256+0xab4>
50004a60:	cc4fd0ef          	jal	50001f24 <printk>
50004a64:	00001637          	lui	a2,0x1
50004a68:	f4860613          	addi	a2,a2,-184 # f48 <CONFIG_ISR_STACK_SIZE+0x748>
50004a6c:	e4dff06f          	j	500048b8 <bt_recv_prio+0xc0>
50004a70:	00040513          	mv	a0,s0
50004a74:	7a0000ef          	jal	50005214 <net_buf_unref>
50004a78:	02c12083          	lw	ra,44(sp)
50004a7c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004a80:	02812403          	lw	s0,40(sp)
50004a84:	02412483          	lw	s1,36(sp)
50004a88:	02012903          	lw	s2,32(sp)
50004a8c:	01c12983          	lw	s3,28(sp)
50004a90:	01812a03          	lw	s4,24(sp)
50004a94:	01412a83          	lw	s5,20(sp)
50004a98:	01012b03          	lw	s6,16(sp)
50004a9c:	00c12b83          	lw	s7,12(sp)
50004aa0:	00812c03          	lw	s8,8(sp)
50004aa4:	03010113          	addi	sp,sp,48
50004aa8:	00008067          	ret

50004aac <bt_hci_driver_register>:
50004aac:	51002737          	lui	a4,0x51002
50004ab0:	bd070713          	addi	a4,a4,-1072 # 51001bd0 <bt_dev>
50004ab4:	0c072783          	lw	a5,192(a4)
50004ab8:	08079663          	bnez	a5,50004b44 <bt_hci_driver_register+0x98>
50004abc:	00852683          	lw	a3,8(a0)
50004ac0:	fea00793          	li	a5,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
50004ac4:	08068263          	beqz	a3,50004b48 <bt_hci_driver_register+0x9c>
50004ac8:	00c52683          	lw	a3,12(a0)
50004acc:	06068e63          	beqz	a3,50004b48 <bt_hci_driver_register+0x9c>
50004ad0:	ff010113          	addi	sp,sp,-16
50004ad4:	00812423          	sw	s0,8(sp)
50004ad8:	00050413          	mv	s0,a0
50004adc:	00112623          	sw	ra,12(sp)
50004ae0:	0ca72023          	sw	a0,192(a4)
50004ae4:	3ad010ef          	jal	50006690 <k_current_get>
50004ae8:	00042683          	lw	a3,0(s0)
50004aec:	51002737          	lui	a4,0x51002
50004af0:	00050793          	mv	a5,a0
50004af4:	99470813          	addi	a6,a4,-1644 # 51001994 <_default_esf+0x288>
50004af8:	00068463          	beqz	a3,50004b00 <bt_hci_driver_register+0x54>
50004afc:	00068813          	mv	a6,a3
50004b00:	510016b7          	lui	a3,0x51001
50004b04:	51000637          	lui	a2,0x51000
50004b08:	510005b7          	lui	a1,0x51000
50004b0c:	51001537          	lui	a0,0x51001
50004b10:	99470893          	addi	a7,a4,-1644
50004b14:	5e868693          	addi	a3,a3,1512 # 510015e8 <__func__.4335>
50004b18:	99470713          	addi	a4,a4,-1644
50004b1c:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50004b20:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004b24:	24450513          	addi	a0,a0,580 # 51001244 <k256+0xb18>
50004b28:	bfcfd0ef          	jal	50001f24 <printk>
50004b2c:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004b30:	00c12083          	lw	ra,12(sp)
50004b34:	00078513          	mv	a0,a5
50004b38:	00812403          	lw	s0,8(sp)
50004b3c:	01010113          	addi	sp,sp,16
50004b40:	00008067          	ret
50004b44:	fbb00793          	li	a5,-69 # ffffffbb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffbc>
50004b48:	00078513          	mv	a0,a5
50004b4c:	00008067          	ret

50004b50 <bt_enable>:
50004b50:	fd010113          	addi	sp,sp,-48
50004b54:	02812423          	sw	s0,40(sp)
50004b58:	01412c23          	sw	s4,24(sp)
50004b5c:	51002437          	lui	s0,0x51002
50004b60:	00050a13          	mv	s4,a0
50004b64:	51001537          	lui	a0,0x51001
50004b68:	26850513          	addi	a0,a0,616 # 51001268 <k256+0xb3c>
50004b6c:	bd040413          	addi	s0,s0,-1072 # 51001bd0 <bt_dev>
50004b70:	02112623          	sw	ra,44(sp)
50004b74:	02912223          	sw	s1,36(sp)
50004b78:	03212023          	sw	s2,32(sp)
50004b7c:	01312e23          	sw	s3,28(sp)
50004b80:	ba4fd0ef          	jal	50001f24 <printk>
50004b84:	0c042783          	lw	a5,192(s0)
50004b88:	04079063          	bnez	a5,50004bc8 <bt_enable+0x78>
50004b8c:	510007b7          	lui	a5,0x51000
50004b90:	51000737          	lui	a4,0x51000
50004b94:	510016b7          	lui	a3,0x51001
50004b98:	51000637          	lui	a2,0x51000
50004b9c:	510005b7          	lui	a1,0x51000
50004ba0:	51001537          	lui	a0,0x51001
50004ba4:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004ba8:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004bac:	68068693          	addi	a3,a3,1664 # 51001680 <__func__.4348>
50004bb0:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004bb4:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004bb8:	27850513          	addi	a0,a0,632 # 51001278 <k256+0xb4c>
50004bbc:	b68fd0ef          	jal	50001f24 <printk>
50004bc0:	fed00493          	li	s1,-19 # ffffffed <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffee>
50004bc4:	1380006f          	j	50004cfc <bt_enable+0x1ac>
50004bc8:	51001537          	lui	a0,0x51001
50004bcc:	2a450513          	addi	a0,a0,676 # 510012a4 <k256+0xb78>
50004bd0:	06c40993          	addi	s3,s0,108
50004bd4:	b50fd0ef          	jal	50001f24 <printk>
50004bd8:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50004bdc:	00098513          	mv	a0,s3
50004be0:	335000ef          	jal	50005714 <atomic_or>
50004be4:	fc1534b3          	p.bclr	s1,a0,30,1
50004be8:	10049463          	bnez	s1,50004cf0 <bt_enable+0x1a0>
50004bec:	51001537          	lui	a0,0x51001
50004bf0:	510027b7          	lui	a5,0x51002
50004bf4:	2bc50513          	addi	a0,a0,700 # 510012bc <k256+0xb90>
50004bf8:	d147ae23          	sw	s4,-740(a5) # 51001d1c <ready_cb>
50004bfc:	b28fd0ef          	jal	50001f24 <printk>
50004c00:	500046b7          	lui	a3,0x50004
50004c04:	510035b7          	lui	a1,0x51003
50004c08:	51002537          	lui	a0,0x51002
50004c0c:	ff700893          	li	a7,-9 # fffffff7 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff8>
50004c10:	00000813          	li	a6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004c14:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004c18:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004c1c:	f1868693          	addi	a3,a3,-232 # 50003f18 <hci_tx_thread>
50004c20:	22c00613          	li	a2,556 # 22c <CONFIG_IDLE_STACK_SIZE+0x2c>
50004c24:	9b058593          	addi	a1,a1,-1616 # 510029b0 <tx_thread_stack>
50004c28:	00012223          	sw	zero,4(sp)
50004c2c:	00012023          	sw	zero,0(sp)
50004c30:	04050513          	addi	a0,a0,64 # 51002040 <tx_thread_data>
50004c34:	22c020ef          	jal	50006e60 <k_thread_create>
50004c38:	51001537          	lui	a0,0x51001
50004c3c:	2d450513          	addi	a0,a0,724 # 510012d4 <k256+0xba8>
50004c40:	ae4fd0ef          	jal	50001f24 <printk>
50004c44:	0c042783          	lw	a5,192(s0)
50004c48:	0087a783          	lw	a5,8(a5)
50004c4c:	000780e7          	jalr	a5
50004c50:	00050913          	mv	s2,a0
50004c54:	04050263          	beqz	a0,50004c98 <bt_enable+0x148>
50004c58:	00050793          	mv	a5,a0
50004c5c:	51000837          	lui	a6,0x51000
50004c60:	51000737          	lui	a4,0x51000
50004c64:	510016b7          	lui	a3,0x51001
50004c68:	51000637          	lui	a2,0x51000
50004c6c:	510005b7          	lui	a1,0x51000
50004c70:	51001537          	lui	a0,0x51001
50004c74:	27080813          	addi	a6,a6,624 # 51000270 <__devconfig_end+0x21c>
50004c78:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004c7c:	68068693          	addi	a3,a3,1664 # 51001680 <__func__.4348>
50004c80:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004c84:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004c88:	2f050513          	addi	a0,a0,752 # 510012f0 <k256+0xbc4>
50004c8c:	a98fd0ef          	jal	50001f24 <printk>
50004c90:	00090493          	mv	s1,s2
50004c94:	0680006f          	j	50004cfc <bt_enable+0x1ac>
50004c98:	51001537          	lui	a0,0x51001
50004c9c:	31c50513          	addi	a0,a0,796 # 5100131c <k256+0xbf0>
50004ca0:	a84fd0ef          	jal	50001f24 <printk>
50004ca4:	020a1263          	bnez	s4,50004cc8 <bt_enable+0x178>
50004ca8:	891fe0ef          	jal	50003538 <hci_init>
50004cac:	04051663          	bnez	a0,50004cf8 <bt_enable+0x1a8>
50004cb0:	00200593          	li	a1,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
50004cb4:	00098513          	mv	a0,s3
50004cb8:	25d000ef          	jal	50005714 <atomic_or>
50004cbc:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004cc0:	fe0fe0ef          	jal	500034a0 <bt_le_scan_update>
50004cc4:	0380006f          	j	50004cfc <bt_enable+0x1ac>
50004cc8:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50004ccc:	06840513          	addi	a0,s0,104
50004cd0:	245000ef          	jal	50005714 <atomic_or>
50004cd4:	fc153533          	p.bclr	a0,a0,30,1
50004cd8:	02051263          	bnez	a0,50004cfc <bt_enable+0x1ac>
50004cdc:	51002537          	lui	a0,0x51002
50004ce0:	06040593          	addi	a1,s0,96
50004ce4:	3f850513          	addi	a0,a0,1016 # 510023f8 <k_sys_work_q>
50004ce8:	3a0010ef          	jal	50006088 <k_queue_append>
50004cec:	0100006f          	j	50004cfc <bt_enable+0x1ac>
50004cf0:	fbb00493          	li	s1,-69 # ffffffbb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffbc>
50004cf4:	0080006f          	j	50004cfc <bt_enable+0x1ac>
50004cf8:	00050493          	mv	s1,a0
50004cfc:	02c12083          	lw	ra,44(sp)
50004d00:	00048513          	mv	a0,s1
50004d04:	02812403          	lw	s0,40(sp)
50004d08:	02412483          	lw	s1,36(sp)
50004d0c:	02012903          	lw	s2,32(sp)
50004d10:	01c12983          	lw	s3,28(sp)
50004d14:	01812a03          	lw	s4,24(sp)
50004d18:	03010113          	addi	sp,sp,48
50004d1c:	00008067          	ret

50004d20 <bt_buf_get_rx>:

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
50004d20:	ff010113          	addi	sp,sp,-16
50004d24:	00912223          	sw	s1,4(sp)
50004d28:	00050493          	mv	s1,a0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
50004d2c:	51002537          	lui	a0,0x51002
50004d30:	b3850513          	addi	a0,a0,-1224 # 51001b38 <hci_rx_pool>

	return bt_le_scan_update(false);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
50004d34:	00812423          	sw	s0,8(sp)
50004d38:	00112623          	sw	ra,12(sp)
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
50004d3c:	330000ef          	jal	5000506c <net_buf_alloc>
50004d40:	00050413          	mv	s0,a0
#endif

	if (buf) {
50004d44:	00050c63          	beqz	a0,50004d5c <bt_buf_get_rx+0x3c>
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);
50004d48:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004d4c:	494000ef          	jal	500051e0 <net_buf_reserve>
50004d50:	00040513          	mv	a0,s0
50004d54:	8c4fe0ef          	jal	50002e18 <net_buf_user_data>
50004d58:	00950023          	sb	s1,0(a0)
		bt_buf_set_type(buf, type);
	}

	return buf;
}
50004d5c:	00c12083          	lw	ra,12(sp)
50004d60:	00040513          	mv	a0,s0
50004d64:	00412483          	lw	s1,4(sp)
50004d68:	00812403          	lw	s0,8(sp)
50004d6c:	01010113          	addi	sp,sp,16
50004d70:	00008067          	ret

50004d74 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
50004d74:	ff010113          	addi	sp,sp,-16
50004d78:	00912223          	sw	s1,4(sp)
50004d7c:	01212023          	sw	s2,0(sp)
50004d80:	00112623          	sw	ra,12(sp)
50004d84:	00812423          	sw	s0,8(sp)
50004d88:	00050913          	mv	s2,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50004d8c:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
50004d90:	3004b7f3          	csrrc	a5,mstatus,s1
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
50004d94:	51002737          	lui	a4,0x51002
50004d98:	bd070713          	addi	a4,a4,-1072 # 51001bd0 <bt_dev>
50004d9c:	09472403          	lw	s0,148(a4)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50004da0:	fc17b7b3          	p.bclr	a5,a5,30,1
	bt_dev.sent_cmd = NULL;
50004da4:	08072a23          	sw	zero,148(a4)
50004da8:	3007a7f3          	csrrs	a5,mstatus,a5
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);
50004dac:	0e5010ef          	jal	50006690 <k_current_get>
50004db0:	00050793          	mv	a5,a0
50004db4:	51002737          	lui	a4,0x51002
50004db8:	510016b7          	lui	a3,0x51001
50004dbc:	51000637          	lui	a2,0x51000
50004dc0:	510005b7          	lui	a1,0x51000
50004dc4:	51001537          	lui	a0,0x51001
50004dc8:	99470893          	addi	a7,a4,-1644 # 51001994 <_default_esf+0x288>
50004dcc:	00040813          	mv	a6,s0
50004dd0:	99470713          	addi	a4,a4,-1644
50004dd4:	51468693          	addi	a3,a3,1300 # 51001514 <__func__.4402>
50004dd8:	1d060613          	addi	a2,a2,464 # 510001d0 <__devconfig_end+0x17c>
50004ddc:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004de0:	33050513          	addi	a0,a0,816 # 51001330 <k256+0xc04>
50004de4:	940fd0ef          	jal	50001f24 <printk>

	if (buf) {
50004de8:	02041263          	bnez	s0,50004e0c <bt_buf_get_cmd_complete+0x98>
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
50004dec:	00090593          	mv	a1,s2
}
50004df0:	00012903          	lw	s2,0(sp)
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
50004df4:	00048513          	mv	a0,s1
}
50004df8:	00c12083          	lw	ra,12(sp)
50004dfc:	00812403          	lw	s0,8(sp)
50004e00:	00412483          	lw	s1,4(sp)
50004e04:	01010113          	addi	sp,sp,16
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
50004e08:	f19ff06f          	j	50004d20 <bt_buf_get_rx>
50004e0c:	00040513          	mv	a0,s0
50004e10:	808fe0ef          	jal	50002e18 <net_buf_user_data>
50004e14:	00950023          	sb	s1,0(a0)
	BT_DBG("sent_cmd %p", buf);

	if (buf) {
		bt_buf_set_type(buf, BT_BUF_EVT);
		buf->len = 0;
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);
50004e18:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004e1c:	00040513          	mv	a0,s0

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
		bt_buf_set_type(buf, BT_BUF_EVT);
		buf->len = 0;
50004e20:	00041623          	sh	zero,12(s0)
		net_buf_reserve(buf, CONFIG_BLUETOOTH_HCI_RESERVE);
50004e24:	3bc000ef          	jal	500051e0 <net_buf_reserve>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
50004e28:	00c12083          	lw	ra,12(sp)
50004e2c:	00040513          	mv	a0,s0
50004e30:	00412483          	lw	s1,4(sp)
50004e34:	00812403          	lw	s0,8(sp)
50004e38:	00012903          	lw	s2,0(sp)
50004e3c:	01010113          	addi	sp,sp,16
50004e40:	00008067          	ret

50004e44 <prng_reseed.constprop.1>:

#include "hci_core.h"

static struct tc_hmac_prng_struct prng;

static int prng_reseed(struct tc_hmac_prng_struct *h)
50004e44:	fc010113          	addi	sp,sp,-64
50004e48:	02912a23          	sw	s1,52(sp)

	for (i = 0; i < (sizeof(seed) / 8); i++) {
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004e4c:	000024b7          	lui	s1,0x2

#include "hci_core.h"

static struct tc_hmac_prng_struct prng;

static int prng_reseed(struct tc_hmac_prng_struct *h)
50004e50:	02812c23          	sw	s0,56(sp)
50004e54:	03212823          	sw	s2,48(sp)
50004e58:	02112e23          	sw	ra,60(sp)
50004e5c:	00000413          	li	s0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>

	for (i = 0; i < (sizeof(seed) / 8); i++) {
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004e60:	01848493          	addi	s1,s1,24 # 2018 <CONFIG_ISR_STACK_SIZE+0x1818>
{
	u8_t seed[32];
	s64_t extra;
	int ret, i;

	for (i = 0; i < (sizeof(seed) / 8); i++) {
50004e64:	02000913          	li	s2,32 # 20 <CONFIG_NUM_IRQS>
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004e68:	00810613          	addi	a2,sp,8
50004e6c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004e70:	00048513          	mv	a0,s1
50004e74:	ab4fe0ef          	jal	50003128 <bt_hci_cmd_send_sync>
		if (ret) {
50004e78:	00050663          	beqz	a0,50004e84 <prng_reseed.constprop.1+0x40>

	for (i = 0; i < (sizeof(seed) / 8); i++) {
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004e7c:	00050793          	mv	a5,a0
50004e80:	0980006f          	j	50004f18 <prng_reseed.constprop.1+0xd4>
		if (ret) {
			return ret;
		}

		rp = (void *)rsp->data;
		memcpy(&seed[i * 8], rp->rand, 8);
50004e84:	00812783          	lw	a5,8(sp)
50004e88:	0087a583          	lw	a1,8(a5)
50004e8c:	01010793          	addi	a5,sp,16
50004e90:	00878533          	add	a0,a5,s0
50004e94:	00800613          	li	a2,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50004e98:	00158593          	addi	a1,a1,1
50004e9c:	da4fb0ef          	jal	50000440 <memcpy>
50004ea0:	00840413          	addi	s0,s0,8

		net_buf_unref(rsp);
50004ea4:	00812503          	lw	a0,8(sp)
50004ea8:	36c000ef          	jal	50005214 <net_buf_unref>
{
	u8_t seed[32];
	s64_t extra;
	int ret, i;

	for (i = 0; i < (sizeof(seed) / 8); i++) {
50004eac:	fb241ee3          	bne	s0,s2,50004e68 <prng_reseed.constprop.1+0x24>
		memcpy(&seed[i * 8], rp->rand, 8);

		net_buf_unref(rsp);
	}

	extra = k_uptime_get();
50004eb0:	2b9010ef          	jal	50006968 <k_uptime_get>
50004eb4:	00a12423          	sw	a0,8(sp)

	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (u8_t *)&extra,
50004eb8:	00800713          	li	a4,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50004ebc:	51002537          	lui	a0,0x51002
		memcpy(&seed[i * 8], rp->rand, 8);

		net_buf_unref(rsp);
	}

	extra = k_uptime_get();
50004ec0:	00b12623          	sw	a1,12(sp)

	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (u8_t *)&extra,
50004ec4:	00e106b3          	add	a3,sp,a4
50004ec8:	00040613          	mv	a2,s0
50004ecc:	01010593          	addi	a1,sp,16
50004ed0:	0b050513          	addi	a0,a0,176 # 510020b0 <prng>
50004ed4:	bf1fd0ef          	jal	50002ac4 <tc_hmac_prng_reseed>
	if (ret == TC_CRYPTO_FAIL) {
		BT_ERR("Failed to re-seed PRNG");
		return -EIO;
	}

	return 0;
50004ed8:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>

	extra = k_uptime_get();

	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (u8_t *)&extra,
				  sizeof(extra));
	if (ret == TC_CRYPTO_FAIL) {
50004edc:	02051e63          	bnez	a0,50004f18 <prng_reseed.constprop.1+0xd4>
		BT_ERR("Failed to re-seed PRNG");
50004ee0:	510007b7          	lui	a5,0x51000
50004ee4:	51000737          	lui	a4,0x51000
50004ee8:	510016b7          	lui	a3,0x51001
50004eec:	51000637          	lui	a2,0x51000
50004ef0:	510005b7          	lui	a1,0x51000
50004ef4:	51001537          	lui	a0,0x51001
50004ef8:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004efc:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004f00:	6e468693          	addi	a3,a3,1764 # 510016e4 <__func__.3488>
50004f04:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004f08:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004f0c:	3ec50513          	addi	a0,a0,1004 # 510013ec <k256+0xcc0>
50004f10:	814fd0ef          	jal	50001f24 <printk>
50004f14:	ffb00793          	li	a5,-5 # fffffffb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffc>
		return -EIO;
	}

	return 0;
}
50004f18:	03c12083          	lw	ra,60(sp)
50004f1c:	00078513          	mv	a0,a5
50004f20:	03812403          	lw	s0,56(sp)
50004f24:	03412483          	lw	s1,52(sp)
50004f28:	03012903          	lw	s2,48(sp)
50004f2c:	04010113          	addi	sp,sp,64
50004f30:	00008067          	ret

50004f34 <prng_init>:
	struct bt_hci_rp_le_rand *rp;
	struct net_buf *rsp;
	int ret;

	/* Check first that HCI_LE_Rand is supported */
	if (!(bt_dev.supported_commands[27] & BIT(7))) {
50004f34:	510027b7          	lui	a5,0x51002
50004f38:	c0978783          	lb	a5,-1015(a5) # 51001c09 <bt_dev+0x39>
		return -ENOTSUP;
50004f3c:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
	struct bt_hci_rp_le_rand *rp;
	struct net_buf *rsp;
	int ret;

	/* Check first that HCI_LE_Rand is supported */
	if (!(bt_dev.supported_commands[27] & BIT(7))) {
50004f40:	0a07d063          	bgez	a5,50004fe0 <prng_init+0xac>

	return 0;
}

int prng_init(void)
{
50004f44:	fe010113          	addi	sp,sp,-32
	/* Check first that HCI_LE_Rand is supported */
	if (!(bt_dev.supported_commands[27] & BIT(7))) {
		return -ENOTSUP;
	}

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004f48:	00002537          	lui	a0,0x2
50004f4c:	00c10613          	addi	a2,sp,12
50004f50:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50004f54:	01850513          	addi	a0,a0,24 # 2018 <CONFIG_ISR_STACK_SIZE+0x1818>

	return 0;
}

int prng_init(void)
{
50004f58:	00112e23          	sw	ra,28(sp)
50004f5c:	00812c23          	sw	s0,24(sp)
	/* Check first that HCI_LE_Rand is supported */
	if (!(bt_dev.supported_commands[27] & BIT(7))) {
		return -ENOTSUP;
	}

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
50004f60:	9c8fe0ef          	jal	50003128 <bt_hci_cmd_send_sync>
	if (ret) {
50004f64:	06051863          	bnez	a0,50004fd4 <prng_init+0xa0>
		return ret;
	}

	rp = (void *)rsp->data;

	ret = tc_hmac_prng_init(&prng, rp->rand, sizeof(rp->rand));
50004f68:	00c12783          	lw	a5,12(sp)
50004f6c:	0087a583          	lw	a1,8(a5)
50004f70:	51002537          	lui	a0,0x51002
50004f74:	00800613          	li	a2,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50004f78:	00158593          	addi	a1,a1,1
50004f7c:	0b050513          	addi	a0,a0,176 # 510020b0 <prng>
50004f80:	aa1fd0ef          	jal	50002a20 <tc_hmac_prng_init>
50004f84:	00050413          	mv	s0,a0

	net_buf_unref(rsp);
50004f88:	00c12503          	lw	a0,12(sp)
50004f8c:	288000ef          	jal	50005214 <net_buf_unref>

	if (ret == TC_CRYPTO_FAIL) {
50004f90:	04041063          	bnez	s0,50004fd0 <prng_init+0x9c>
		BT_ERR("Failed to initialize PRNG");
50004f94:	510007b7          	lui	a5,0x51000
50004f98:	51000737          	lui	a4,0x51000
50004f9c:	510016b7          	lui	a3,0x51001
50004fa0:	51000637          	lui	a2,0x51000
50004fa4:	510005b7          	lui	a1,0x51000
50004fa8:	51001537          	lui	a0,0x51001
50004fac:	27078793          	addi	a5,a5,624 # 51000270 <__devconfig_end+0x21c>
50004fb0:	27870713          	addi	a4,a4,632 # 51000278 <__devconfig_end+0x224>
50004fb4:	6d868693          	addi	a3,a3,1752 # 510016d8 <__func__.3495>
50004fb8:	28060613          	addi	a2,a2,640 # 51000280 <__devconfig_end+0x22c>
50004fbc:	1d858593          	addi	a1,a1,472 # 510001d8 <__devconfig_end+0x184>
50004fc0:	41450513          	addi	a0,a0,1044 # 51001414 <k256+0xce8>
50004fc4:	f61fc0ef          	jal	50001f24 <printk>
		return -EIO;
50004fc8:	ffb00513          	li	a0,-5 # fffffffb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffc>
50004fcc:	0080006f          	j	50004fd4 <prng_init+0xa0>
	}

	/* re-seed is needed after init */
	return prng_reseed(&prng);
50004fd0:	e75ff0ef          	jal	50004e44 <prng_reseed.constprop.1>
}
50004fd4:	01c12083          	lw	ra,28(sp)
50004fd8:	01812403          	lw	s0,24(sp)
50004fdc:	02010113          	addi	sp,sp,32
50004fe0:	00008067          	ret

50004fe4 <bt_rand>:

int bt_rand(void *buf, size_t len)
{
50004fe4:	ff010113          	addi	sp,sp,-16
50004fe8:	00812423          	sw	s0,8(sp)
	int ret;

	ret = tc_hmac_prng_generate(buf, len, &prng);
50004fec:	51002437          	lui	s0,0x51002
50004ff0:	0b040613          	addi	a2,s0,176 # 510020b0 <prng>
	/* re-seed is needed after init */
	return prng_reseed(&prng);
}

int bt_rand(void *buf, size_t len)
{
50004ff4:	00912223          	sw	s1,4(sp)
50004ff8:	01212023          	sw	s2,0(sp)
50004ffc:	00112623          	sw	ra,12(sp)
50005000:	00050493          	mv	s1,a0
50005004:	00058913          	mv	s2,a1
	int ret;

	ret = tc_hmac_prng_generate(buf, len, &prng);
50005008:	b45fd0ef          	jal	50002b4c <tc_hmac_prng_generate>
	if (ret == TC_HMAC_PRNG_RESEED_REQ) {
5000500c:	03f53063          	p.bneimm	a0,-1,5000502c <bt_rand+0x48>
		ret = prng_reseed(&prng);
50005010:	e35ff0ef          	jal	50004e44 <prng_reseed.constprop.1>
50005014:	00050793          	mv	a5,a0
		if (ret) {
50005018:	02051063          	bnez	a0,50005038 <bt_rand+0x54>
			return ret;
		}

		ret = tc_hmac_prng_generate(buf, len, &prng);
5000501c:	0b040613          	addi	a2,s0,176
50005020:	00090593          	mv	a1,s2
50005024:	00048513          	mv	a0,s1
50005028:	b25fd0ef          	jal	50002b4c <tc_hmac_prng_generate>
	}

	if (ret == TC_CRYPTO_SUCCESS) {
		return 0;
5000502c:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
		}

		ret = tc_hmac_prng_generate(buf, len, &prng);
	}

	if (ret == TC_CRYPTO_SUCCESS) {
50005030:	00152463          	p.beqimm	a0,1,50005038 <bt_rand+0x54>
		return 0;
	}

	return -EIO;
50005034:	ffb00793          	li	a5,-5 # fffffffb <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffc>
}
50005038:	00c12083          	lw	ra,12(sp)
5000503c:	00078513          	mv	a0,a5
50005040:	00812403          	lw	s0,8(sp)
50005044:	00412483          	lw	s1,4(sp)
50005048:	00012903          	lw	s2,0(sp)
5000504c:	01010113          	addi	sp,sp,16
50005050:	00008067          	ret

50005054 <net_buf_pool_get>:

	val = UNALIGNED_GET((u32_t *)buf->data);
	net_buf_simple_pull(buf, sizeof(val));

	return sys_be32_to_cpu(val);
}
50005054:	510027b7          	lui	a5,0x51002
50005058:	02400713          	li	a4,36 # 24 <__NANO_ESF_t6_OFFSET>
5000505c:	b1478793          	addi	a5,a5,-1260 # 51001b14 <__device_APPLICATION_start>
50005060:	42e507b3          	p.mac	a5,a0,a4
50005064:	00078513          	mv	a0,a5
50005068:	00008067          	ret

5000506c <net_buf_alloc>:
5000506c:	ff010113          	addi	sp,sp,-16
50005070:	00812423          	sw	s0,8(sp)
50005074:	00112623          	sw	ra,12(sp)
50005078:	00912223          	sw	s1,4(sp)
5000507c:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50005080:	30043473          	csrrc	s0,mstatus,s0
50005084:	01655783          	lhu	a5,22(a0)
50005088:	fc143433          	p.bclr	s0,s0,30,1
5000508c:	08078663          	beqz	a5,50005118 <net_buf_alloc+0xac>
50005090:	01455703          	lhu	a4,20(a0)
50005094:	00050493          	mv	s1,a0
50005098:	00e7fc63          	bleu	a4,a5,500050b0 <net_buf_alloc+0x44>
5000509c:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500050a0:	108010ef          	jal	500061a8 <k_queue_get>
500050a4:	00050663          	beqz	a0,500050b0 <net_buf_alloc+0x44>
500050a8:	30042473          	csrrs	s0,mstatus,s0
500050ac:	07c0006f          	j	50005128 <net_buf_alloc+0xbc>
500050b0:	0164d683          	lhu	a3,22(s1)
500050b4:	fff68793          	addi	a5,a3,-1
500050b8:	00f49b23          	sh	a5,22(s1)
500050bc:	30042473          	csrrs	s0,mstatus,s0
500050c0:	0184d783          	lhu	a5,24(s1)
500050c4:	0204a503          	lw	a0,32(s1)
500050c8:	00378793          	addi	a5,a5,3
500050cc:	c207b733          	p.bclr	a4,a5,1,0
500050d0:	01a4d783          	lhu	a5,26(s1)
500050d4:	00378793          	addi	a5,a5,3
500050d8:	c207b7b3          	p.bclr	a5,a5,1,0
500050dc:	00f707b3          	add	a5,a4,a5
500050e0:	0144d703          	lhu	a4,20(s1)
500050e4:	01078793          	addi	a5,a5,16
500050e8:	40d70733          	sub	a4,a4,a3
500050ec:	42e78533          	p.mac	a0,a5,a4
500050f0:	510027b7          	lui	a5,0x51002
500050f4:	b1478793          	addi	a5,a5,-1260 # 51001b14 <__device_APPLICATION_start>
500050f8:	04f4b75b          	p.subn	a4,s1,a5,2
500050fc:	38e397b7          	lui	a5,0x38e39
50005100:	e3978793          	addi	a5,a5,-455 # 38e38e39 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x35e89db9>
50005104:	02f707b3          	mul	a5,a4,a5
50005108:	00f50323          	sb	a5,6(a0)
5000510c:	0184d783          	lhu	a5,24(s1)
50005110:	00f51723          	sh	a5,14(a0)
50005114:	0140006f          	j	50005128 <net_buf_alloc+0xbc>
50005118:	30042473          	csrrs	s0,mstatus,s0
5000511c:	08c010ef          	jal	500061a8 <k_queue_get>
50005120:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005124:	02050263          	beqz	a0,50005148 <net_buf_alloc+0xdc>
50005128:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
5000512c:	00f50223          	sb	a5,4(a0)
50005130:	01050793          	addi	a5,a0,16
50005134:	00f52423          	sw	a5,8(a0)
50005138:	000502a3          	sb	zero,5(a0)
5000513c:	00052023          	sw	zero,0(a0)
50005140:	00051623          	sh	zero,12(a0)
50005144:	00050793          	mv	a5,a0
50005148:	00c12083          	lw	ra,12(sp)
5000514c:	00078513          	mv	a0,a5
50005150:	00812403          	lw	s0,8(sp)
50005154:	00412483          	lw	s1,4(sp)
50005158:	01010113          	addi	sp,sp,16
5000515c:	00008067          	ret

50005160 <net_buf_get>:
50005160:	ff010113          	addi	sp,sp,-16
50005164:	01212023          	sw	s2,0(sp)
50005168:	00112623          	sw	ra,12(sp)
5000516c:	00812423          	sw	s0,8(sp)
50005170:	00912223          	sw	s1,4(sp)
50005174:	00050913          	mv	s2,a0
50005178:	030010ef          	jal	500061a8 <k_queue_get>
5000517c:	04050463          	beqz	a0,500051c4 <net_buf_get+0x64>
50005180:	00050413          	mv	s0,a0
50005184:	00050493          	mv	s1,a0
50005188:	0054c783          	lbu	a5,5(s1)
5000518c:	fc17b7b3          	p.bclr	a5,a5,30,1
50005190:	02078463          	beqz	a5,500051b8 <net_buf_get+0x58>
50005194:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005198:	00090513          	mv	a0,s2
5000519c:	00c010ef          	jal	500061a8 <k_queue_get>
500051a0:	0054c783          	lbu	a5,5(s1)
500051a4:	00a4a023          	sw	a0,0(s1)
500051a8:	c007b7b3          	p.bclr	a5,a5,0,0
500051ac:	00f482a3          	sb	a5,5(s1)
500051b0:	00050493          	mv	s1,a0
500051b4:	fd5ff06f          	j	50005188 <net_buf_get+0x28>
500051b8:	0004a023          	sw	zero,0(s1)
500051bc:	00040513          	mv	a0,s0
500051c0:	0080006f          	j	500051c8 <net_buf_get+0x68>
500051c4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500051c8:	00c12083          	lw	ra,12(sp)
500051cc:	00812403          	lw	s0,8(sp)
500051d0:	00412483          	lw	s1,4(sp)
500051d4:	00012903          	lw	s2,0(sp)
500051d8:	01010113          	addi	sp,sp,16
500051dc:	00008067          	ret

500051e0 <net_buf_reserve>:
500051e0:	01050793          	addi	a5,a0,16
500051e4:	00b785b3          	add	a1,a5,a1
500051e8:	00b52423          	sw	a1,8(a0)
500051ec:	00008067          	ret

500051f0 <net_buf_put>:
500051f0:	00058613          	mv	a2,a1
500051f4:	00062703          	lw	a4,0(a2)
500051f8:	00070c63          	beqz	a4,50005210 <net_buf_put+0x20>
500051fc:	00564783          	lbu	a5,5(a2)
50005200:	c007c7b3          	p.bset	a5,a5,0,0
50005204:	00f602a3          	sb	a5,5(a2)
50005208:	00070613          	mv	a2,a4
5000520c:	fe9ff06f          	j	500051f4 <net_buf_put+0x4>
50005210:	6910006f          	j	500060a0 <k_queue_append_list>

50005214 <net_buf_unref>:
50005214:	ff010113          	addi	sp,sp,-16
50005218:	00812423          	sw	s0,8(sp)
5000521c:	51002437          	lui	s0,0x51002
50005220:	00912223          	sw	s1,4(sp)
50005224:	00112623          	sw	ra,12(sp)
50005228:	01212023          	sw	s2,0(sp)
5000522c:	00050593          	mv	a1,a0
50005230:	b1440413          	addi	s0,s0,-1260 # 51001b14 <__device_APPLICATION_start>
50005234:	02400493          	li	s1,36 # 24 <__NANO_ESF_t6_OFFSET>
50005238:	04058663          	beqz	a1,50005284 <net_buf_unref+0x70>
5000523c:	0045c783          	lbu	a5,4(a1)
50005240:	0005a903          	lw	s2,0(a1)
50005244:	fff78793          	addi	a5,a5,-1
50005248:	0ff7f793          	andi	a5,a5,255
5000524c:	00f58223          	sb	a5,4(a1)
50005250:	02079a63          	bnez	a5,50005284 <net_buf_unref+0x70>
50005254:	0065c783          	lbu	a5,6(a1)
50005258:	00040513          	mv	a0,s0
5000525c:	0005a023          	sw	zero,0(a1)
50005260:	42978533          	p.mac	a0,a5,s1
50005264:	01c52783          	lw	a5,28(a0)
50005268:	00078863          	beqz	a5,50005278 <net_buf_unref+0x64>
5000526c:	00058513          	mv	a0,a1
50005270:	000780e7          	jalr	a5
50005274:	0080006f          	j	5000527c <net_buf_unref+0x68>
50005278:	61d000ef          	jal	50006094 <k_queue_prepend>
5000527c:	00090593          	mv	a1,s2
50005280:	fb9ff06f          	j	50005238 <net_buf_unref+0x24>
50005284:	00c12083          	lw	ra,12(sp)
50005288:	00812403          	lw	s0,8(sp)
5000528c:	00412483          	lw	s1,4(sp)
50005290:	00012903          	lw	s2,0(sp)
50005294:	01010113          	addi	sp,sp,16
50005298:	00008067          	ret

5000529c <net_buf_ref>:
5000529c:	00454783          	lbu	a5,4(a0)
500052a0:	00178793          	addi	a5,a5,1
500052a4:	00f50223          	sb	a5,4(a0)
500052a8:	00008067          	ret

500052ac <net_buf_simple_add>:
500052ac:	00455783          	lhu	a5,4(a0)
500052b0:	00052703          	lw	a4,0(a0)
500052b4:	00b785b3          	add	a1,a5,a1
500052b8:	00b51223          	sh	a1,4(a0)
500052bc:	00f70533          	add	a0,a4,a5
500052c0:	00008067          	ret

500052c4 <net_buf_simple_add_mem>:
500052c4:	00455783          	lhu	a5,4(a0)
500052c8:	00052703          	lw	a4,0(a0)
500052cc:	00c786b3          	add	a3,a5,a2
500052d0:	00d51223          	sh	a3,4(a0)
500052d4:	00f70533          	add	a0,a4,a5
500052d8:	968fb06f          	j	50000440 <memcpy>

500052dc <net_buf_simple_pull>:
500052dc:	00455783          	lhu	a5,4(a0)
500052e0:	40b787b3          	sub	a5,a5,a1
500052e4:	00f51223          	sh	a5,4(a0)
500052e8:	00052783          	lw	a5,0(a0)
500052ec:	00b785b3          	add	a1,a5,a1
500052f0:	00b52023          	sw	a1,0(a0)
500052f4:	00058513          	mv	a0,a1
500052f8:	00008067          	ret

500052fc <net_buf_simple_pull_u8>:
500052fc:	ff010113          	addi	sp,sp,-16
50005300:	00052783          	lw	a5,0(a0)
50005304:	00112623          	sw	ra,12(sp)
50005308:	00812423          	sw	s0,8(sp)
5000530c:	0007c403          	lbu	s0,0(a5)
50005310:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50005314:	fc9ff0ef          	jal	500052dc <net_buf_simple_pull>
50005318:	00c12083          	lw	ra,12(sp)
5000531c:	00040513          	mv	a0,s0
50005320:	00812403          	lw	s0,8(sp)
50005324:	01010113          	addi	sp,sp,16
50005328:	00008067          	ret

5000532c <net_buf_simple_headroom>:

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
5000532c:	00850793          	addi	a5,a0,8
50005330:	00052503          	lw	a0,0(a0)
}
50005334:	40f50533          	sub	a0,a0,a5
50005338:	00008067          	ret

5000533c <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
5000533c:	00052783          	lw	a5,0(a0)
50005340:	00655703          	lhu	a4,6(a0)
	return sys_be32_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
50005344:	00850693          	addi	a3,a0,8
}

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
50005348:	40d787b3          	sub	a5,a5,a3
5000534c:	00455503          	lhu	a0,4(a0)
50005350:	40f707b3          	sub	a5,a4,a5
}
50005354:	40a78533          	sub	a0,a5,a0
50005358:	00008067          	ret

5000535c <_arch_irq_enable>:
};

int _arch_irq_is_enabled(unsigned int irq)
{
	return !!(PPU_IER & (1 << irq));
}
5000535c:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50005360:	300736f3          	csrrc	a3,mstatus,a4
50005364:	1a1047b7          	lui	a5,0x1a104
50005368:	0007a603          	lw	a2,0(a5) # 1a104000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f80>
5000536c:	00a71533          	sll	a0,a4,a0
50005370:	00a66733          	or	a4,a2,a0
50005374:	00e7a82b          	p.sw	a4,16(a5!)
50005378:	0007a703          	lw	a4,0(a5)
5000537c:	00e56533          	or	a0,a0,a4
50005380:	00a7a023          	sw	a0,0(a5)
50005384:	fc16b7b3          	p.bclr	a5,a3,30,1
50005388:	3007a7f3          	csrrs	a5,mstatus,a5
5000538c:	00008067          	ret

50005390 <soc_interrupt_init>:
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50005390:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50005394:	3007b7f3          	csrrc	a5,mstatus,a5
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();
	PPU_IER = 0;
50005398:	1a1047b7          	lui	a5,0x1a104
5000539c:	0007a82b          	p.sw	zero,16(a5!) # 1a104010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f90>
	PPU_EER = 0;
500053a0:	0007a023          	sw	zero,0(a5)
500053a4:	00008067          	ret

500053a8 <k_cpu_idle>:
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500053a8:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500053ac:	3007a773          	csrrs	a4,mstatus,a5
#endif
	/* unlock interrupts */
	irq_unlock(key);

	/* Put CPU core to sleep via SCR register */
	PPU_SCR = 0x01;
500053b0:	1a104737          	lui	a4,0x1a104
500053b4:	02f72023          	sw	a5,32(a4) # 1a104020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154fa0>

	/* Wait for interrupt */
	SOC_WFI;
500053b8:	10200073          	wfi
500053bc:	00008067          	ret
500053c0:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500053c4:	3007a7f3          	csrrs	a5,mstatus,a5
500053c8:	00008067          	ret

500053cc <__start>:
500053cc:	00ffe117          	auipc	sp,0xffe
500053d0:	00410113          	addi	sp,sp,4 # 510033d0 <_interrupt_stack>
500053d4:	000012b7          	lui	t0,0x1
500053d8:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
500053dc:	00510133          	add	sp,sp,t0
500053e0:	220000ef          	jal	50005600 <_PrepC>

500053e4 <_SysFatalErrorHandler>:
 *
 * @return N/A
 */
FUNC_NORETURN __weak void _SysFatalErrorHandler(unsigned int reason,
						const NANO_ESF *esf)
{
500053e4:	ff010113          	addi	sp,sp,-16
500053e8:	00112623          	sw	ra,12(sp)
500053ec:	00812423          	sw	s0,8(sp)
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
500053f0:	06652063          	p.beqimm	a0,6,50005450 <_SysFatalErrorHandler+0x6c>
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
500053f4:	1f1010ef          	jal	50006de4 <k_is_in_isr>
500053f8:	00050c63          	beqz	a0,50005410 <_SysFatalErrorHandler+0x2c>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
500053fc:	1e9010ef          	jal	50006de4 <k_is_in_isr>
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
50005400:	02051e63          	bnez	a0,5000543c <_SysFatalErrorHandler+0x58>
50005404:	510015b7          	lui	a1,0x51001
50005408:	77858593          	addi	a1,a1,1912 # 51001778 <_default_esf+0x6c>
5000540c:	0380006f          	j	50005444 <_SysFatalErrorHandler+0x60>
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
50005410:	1e5010ef          	jal	50006df4 <_is_thread_essential>
50005414:	fe0514e3          	bnez	a0,500053fc <_SysFatalErrorHandler+0x18>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
		goto hang_system;
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
50005418:	51002437          	lui	s0,0x51002
5000541c:	2c040413          	addi	s0,s0,704 # 510022c0 <_kernel>
50005420:	51001537          	lui	a0,0x51001
50005424:	00842583          	lw	a1,8(s0)
50005428:	7ac50513          	addi	a0,a0,1964 # 510017ac <_default_esf+0xa0>
5000542c:	af9fc0ef          	jal	50001f24 <printk>
	k_thread_abort(_current);
50005430:	00842503          	lw	a0,8(s0)
50005434:	40d010ef          	jal	50007040 <k_thread_abort>
50005438:	0180006f          	j	50005450 <_SysFatalErrorHandler+0x6c>
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
5000543c:	510015b7          	lui	a1,0x51001
50005440:	77458593          	addi	a1,a1,1908 # 51001774 <_default_esf+0x68>
50005444:	51001537          	lui	a0,0x51001
50005448:	78c50513          	addi	a0,a0,1932 # 5100178c <_default_esf+0x80>
5000544c:	ad9fc0ef          	jal	50001f24 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
50005450:	f59ff0ef          	jal	500053a8 <k_cpu_idle>
50005454:	ffdff06f          	j	50005450 <_SysFatalErrorHandler+0x6c>

50005458 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *esf)
{
50005458:	fb010113          	addi	sp,sp,-80
	switch (reason) {
5000545c:	00600793          	li	a5,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *esf)
{
50005460:	04812423          	sw	s0,72(sp)
50005464:	04912223          	sw	s1,68(sp)
50005468:	04112623          	sw	ra,76(sp)
5000546c:	00050493          	mv	s1,a0
50005470:	00058413          	mv	s0,a1
	switch (reason) {
50005474:	04a7e663          	bltu	a5,a0,500054c0 <_NanoFatalErrorHandler+0x68>
50005478:	51001737          	lui	a4,0x51001
5000547c:	00251793          	slli	a5,a0,0x2
50005480:	6f070713          	addi	a4,a4,1776 # 510016f0 <__func__.3488+0xc>
50005484:	20f77783          	p.lw	a5,a5(a4)
50005488:	00078067          	jr	a5
	case _NANO_ERR_CPU_EXCEPTION:
	case _NANO_ERR_SPURIOUS_INT:
		break;

	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
5000548c:	51001537          	lui	a0,0x51001
50005490:	7d450513          	addi	a0,a0,2004 # 510017d4 <_default_esf+0xc8>
50005494:	00c0006f          	j	500054a0 <_NanoFatalErrorHandler+0x48>
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
50005498:	51002537          	lui	a0,0x51002
5000549c:	80050513          	addi	a0,a0,-2048 # 51001800 <_default_esf+0xf4>
500054a0:	a85fc0ef          	jal	50001f24 <printk>
		break;
500054a4:	02c0006f          	j	500054d0 <_NanoFatalErrorHandler+0x78>

	case _NANO_ERR_KERNEL_OOPS:
		printk("***** Kernel OOPS! *****\n");
500054a8:	51002537          	lui	a0,0x51002
500054ac:	82850513          	addi	a0,a0,-2008 # 51001828 <_default_esf+0x11c>
500054b0:	ff1ff06f          	j	500054a0 <_NanoFatalErrorHandler+0x48>
		break;

	case _NANO_ERR_KERNEL_PANIC:
		printk("***** Kernel Panic! *****\n");
500054b4:	51002537          	lui	a0,0x51002
500054b8:	84450513          	addi	a0,a0,-1980 # 51001844 <_default_esf+0x138>
500054bc:	fe5ff06f          	j	500054a0 <_NanoFatalErrorHandler+0x48>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
500054c0:	51002537          	lui	a0,0x51002
500054c4:	00048593          	mv	a1,s1
500054c8:	86050513          	addi	a0,a0,-1952 # 51001860 <_default_esf+0x154>
500054cc:	a59fc0ef          	jal	50001f24 <printk>
		break;
	}

	printk("Current thread ID = %p\n"
500054d0:	1c0010ef          	jal	50006690 <k_current_get>
500054d4:	deadc7b7          	lui	a5,0xdeadc
	       "  t1: 0x%x  t2: 0x%x  t3: 0x%x  t4: 0x%x\n"
	       "  t5: 0x%x  t6: 0x%x  a0: 0x%x  a1: 0x%x\n"
	       "  a2: 0x%x  a3: 0x%x  a4: 0x%x  a5: 0x%x\n"
	       "  a6: 0x%x  a7: 0x%x\n",
	       k_current_get(),
	       (esf->mepc == 0xdeadbaad) ? 0xdeadbaad : esf->mepc - 4,
500054d8:	04842603          	lw	a2,72(s0)
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
500054dc:	aad78793          	addi	a5,a5,-1363 # deadbaad <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xdeadbaae>
500054e0:	00050593          	mv	a1,a0
500054e4:	00f60463          	beq	a2,a5,500054ec <_NanoFatalErrorHandler+0x94>
500054e8:	ffc60613          	addi	a2,a2,-4
500054ec:	04442503          	lw	a0,68(s0)
500054f0:	01042883          	lw	a7,16(s0)
500054f4:	00c42803          	lw	a6,12(s0)
500054f8:	00842783          	lw	a5,8(s0)
500054fc:	00442703          	lw	a4,4(s0)
50005500:	00042683          	lw	a3,0(s0)
50005504:	02a12823          	sw	a0,48(sp)
50005508:	04042503          	lw	a0,64(s0)
5000550c:	02a12623          	sw	a0,44(sp)
50005510:	03c42503          	lw	a0,60(s0)
50005514:	02a12423          	sw	a0,40(sp)
50005518:	03842503          	lw	a0,56(s0)
5000551c:	02a12223          	sw	a0,36(sp)
50005520:	03442503          	lw	a0,52(s0)
50005524:	02a12023          	sw	a0,32(sp)
50005528:	03042503          	lw	a0,48(s0)
5000552c:	00a12e23          	sw	a0,28(sp)
50005530:	02c42503          	lw	a0,44(s0)
50005534:	00a12c23          	sw	a0,24(sp)
50005538:	02842503          	lw	a0,40(s0)
5000553c:	00a12a23          	sw	a0,20(sp)
50005540:	02442503          	lw	a0,36(s0)
50005544:	00a12823          	sw	a0,16(sp)
50005548:	02042503          	lw	a0,32(s0)
5000554c:	00a12623          	sw	a0,12(sp)
50005550:	01c42503          	lw	a0,28(s0)
50005554:	00a12423          	sw	a0,8(sp)
50005558:	01842503          	lw	a0,24(s0)
5000555c:	00a12223          	sw	a0,4(sp)
50005560:	01442503          	lw	a0,20(s0)
50005564:	00a12023          	sw	a0,0(sp)
50005568:	51002537          	lui	a0,0x51002
5000556c:	88450513          	addi	a0,a0,-1916 # 51001884 <_default_esf+0x178>
50005570:	9b5fc0ef          	jal	50001f24 <printk>
	       esf->t1, esf->t2, esf->t3, esf->t4,
	       esf->t5, esf->t6, esf->a0, esf->a1,
	       esf->a2, esf->a3, esf->a4, esf->a5,
	       esf->a6, esf->a7);

	_SysFatalErrorHandler(reason, esf);
50005574:	00040593          	mv	a1,s0
50005578:	00048513          	mv	a0,s1
5000557c:	e69ff0ef          	jal	500053e4 <_SysFatalErrorHandler>

50005580 <_Fault>:
}
#endif


FUNC_NORETURN void _Fault(const NANO_ESF *esf)
{
50005580:	ff010113          	addi	sp,sp,-16
50005584:	00812423          	sw	s0,8(sp)
50005588:	00112623          	sw	ra,12(sp)
5000558c:	00050413          	mv	s0,a0
	u32_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
50005590:	34202673          	csrr	a2,mcause
50005594:	00500793          	li	a5,5 # 5 <__NANO_ESF_gp_OFFSET+0x1>

	mcause &= SOC_MCAUSE_EXP_MASK;
50005598:	f4563633          	p.bclr	a2,a2,26,5
5000559c:	00c7ec63          	bltu	a5,a2,500055b4 <_Fault+0x34>
500055a0:	510027b7          	lui	a5,0x51002
500055a4:	00261593          	slli	a1,a2,0x2
500055a8:	a4878793          	addi	a5,a5,-1464 # 51001a48 <CSWTCH.4>
500055ac:	20b7f583          	p.lw	a1,a1(a5)
500055b0:	00c0006f          	j	500055bc <_Fault+0x3c>
500055b4:	510015b7          	lui	a1,0x51001
500055b8:	8a858593          	addi	a1,a1,-1880 # 510008a8 <k256+0x17c>

	printk("Exception cause %s (%d)\n", cause_str(mcause), (int)mcause);
500055bc:	51002537          	lui	a0,0x51002
500055c0:	97c50513          	addi	a0,a0,-1668 # 5100197c <_default_esf+0x270>
500055c4:	961fc0ef          	jal	50001f24 <printk>

	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
500055c8:	00040593          	mv	a1,s0
500055cc:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500055d0:	e89ff0ef          	jal	50005458 <_NanoFatalErrorHandler>

500055d4 <_irq_spurious>:
#include <toolchain.h>
#include <kernel_structs.h>
#include <misc/printk.h>

void _irq_spurious(void *unused)
{
500055d4:	ff010113          	addi	sp,sp,-16
500055d8:	00112623          	sw	ra,12(sp)
	u32_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
500055dc:	342025f3          	csrr	a1,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
500055e0:	51002537          	lui	a0,0x51002
500055e4:	f455b5b3          	p.bclr	a1,a1,26,5
500055e8:	a2050513          	addi	a0,a0,-1504 # 51001a20 <_default_esf+0x314>
500055ec:	939fc0ef          	jal	50001f24 <printk>
		printk("PLIC interrupt line causing the IRQ: %d\n",
		       riscv_plic_get_irq());
	}
#endif

	_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
500055f0:	510015b7          	lui	a1,0x51001
500055f4:	70c58593          	addi	a1,a1,1804 # 5100170c <_default_esf>
500055f8:	00400513          	li	a0,4 # 4 <__NANO_ESF_gp_OFFSET>
500055fc:	e5dff0ef          	jal	50005458 <_NanoFatalErrorHandler>

50005600 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
50005600:	ff010113          	addi	sp,sp,-16
50005604:	00112623          	sw	ra,12(sp)
	_bss_zero();
50005608:	224000ef          	jal	5000582c <_bss_zero>
#ifdef CONFIG_XIP
	_data_copy();
#endif
	_Cstart();
5000560c:	280000ef          	jal	5000588c <_Cstart>

50005610 <_thread_entry_wrapper>:
50005610:	7f80106f          	j	50006e08 <_thread_entry>

50005614 <_new_thread>:

void _new_thread(struct k_thread *thread, char *stack_memory,
		 size_t stack_size, _thread_entry_t thread_func,
		 void *arg1, void *arg2, void *arg3,
		 int priority, unsigned int options)
{
50005614:	fe010113          	addi	sp,sp,-32
50005618:	00812c23          	sw	s0,24(sp)
5000561c:	01212823          	sw	s2,16(sp)
50005620:	01612023          	sw	s6,0(sp)
50005624:	00058413          	mv	s0,a1
50005628:	00060913          	mv	s2,a2
5000562c:	00068b13          	mv	s6,a3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
50005630:	00088593          	mv	a1,a7
50005634:	02012683          	lw	a3,32(sp)
50005638:	00400613          	li	a2,4 # 4 <__NANO_ESF_gp_OFFSET>
5000563c:	00112e23          	sw	ra,28(sp)
50005640:	00912a23          	sw	s1,20(sp)
50005644:	01312623          	sw	s3,12(sp)
50005648:	00050493          	mv	s1,a0
5000564c:	01412423          	sw	s4,8(sp)
50005650:	01512223          	sw	s5,4(sp)
50005654:	00078a13          	mv	s4,a5
50005658:	00070a93          	mv	s5,a4
5000565c:	00080993          	mv	s3,a6
50005660:	1b9010ef          	jal	50007018 <_init_thread_base>

	_new_thread_init(thread, stack_memory, stack_size, priority, options);

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
50005664:	f9890593          	addi	a1,s2,-104
50005668:	00b405b3          	add	a1,s0,a1
5000566c:	c605b5b3          	p.bclr	a1,a1,3,0
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to _thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
50005670:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
50005674:	0404ae23          	sw	zero,92(s1)
	thread->fn_abort = NULL;
50005678:	0604a023          	sw	zero,96(s1)
5000567c:	04f5a623          	sw	a5,76(a1)
	stack_init->mepc = (u32_t)_thread_entry_wrapper;
50005680:	500057b7          	lui	a5,0x50005
50005684:	61078793          	addi	a5,a5,1552 # 50005610 <_thread_entry_wrapper>

	thread->callee_saved.sp = (u32_t)stack_init;

	thread_monitor_init(thread);
}
50005688:	01c12083          	lw	ra,28(sp)
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
				 stack_size - sizeof(struct __esf));

	/* Setup the initial stack frame */
	stack_init->a0 = (u32_t)thread_func;
5000568c:	0365a423          	sw	s6,40(a1)
	stack_init->a1 = (u32_t)arg1;
50005690:	0355a623          	sw	s5,44(a1)
	stack_init->a2 = (u32_t)arg2;
50005694:	0345a823          	sw	s4,48(a1)
	stack_init->a3 = (u32_t)arg3;
50005698:	0335aa23          	sw	s3,52(a1)
	 * 2) the core will jump to _thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
	stack_init->mepc = (u32_t)_thread_entry_wrapper;
5000569c:	04f5a423          	sw	a5,72(a1)

	thread->callee_saved.sp = (u32_t)stack_init;

	thread_monitor_init(thread);
}
500056a0:	01812403          	lw	s0,24(sp)
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
	stack_init->mepc = (u32_t)_thread_entry_wrapper;

	thread->callee_saved.sp = (u32_t)stack_init;
500056a4:	02b4a423          	sw	a1,40(s1)

	thread_monitor_init(thread);
}
500056a8:	01012903          	lw	s2,16(sp)
500056ac:	01412483          	lw	s1,20(sp)
500056b0:	00c12983          	lw	s3,12(sp)
500056b4:	00812a03          	lw	s4,8(sp)
500056b8:	00412a83          	lw	s5,4(sp)
500056bc:	00012b03          	lw	s6,0(sp)
500056c0:	02010113          	addi	sp,sp,32
500056c4:	00008067          	ret

500056c8 <_irq_do_offload>:
 */
void _irq_do_offload(void)
{
	irq_offload_routine_t tmp;

	if (!_offload_routine)
500056c8:	510027b7          	lui	a5,0x51002
500056cc:	3e07a703          	lw	a4,992(a5) # 510023e0 <_offload_routine>
500056d0:	00070c63          	beqz	a4,500056e8 <_irq_do_offload+0x20>
		return;

	tmp = _offload_routine;
500056d4:	3e07a303          	lw	t1,992(a5)
	_offload_routine = NULL;
500056d8:	3e07a023          	sw	zero,992(a5)

	tmp((void *)offload_param);
500056dc:	510027b7          	lui	a5,0x51002
500056e0:	d287a503          	lw	a0,-728(a5) # 51001d28 <offload_param>
500056e4:	00030067          	jr	t1
500056e8:	00008067          	ret

500056ec <atomic_get>:
	*target ^= value;

	irq_unlock(key);

	return ret;
}
500056ec:	00052503          	lw	a0,0(a0)
500056f0:	00008067          	ret

500056f4 <atomic_set>:
500056f4:	00050713          	mv	a4,a0
500056f8:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500056fc:	3007b7f3          	csrrc	a5,mstatus,a5
50005700:	00052503          	lw	a0,0(a0)
50005704:	fc17b7b3          	p.bclr	a5,a5,30,1
50005708:	00b72023          	sw	a1,0(a4)
5000570c:	3007a7f3          	csrrs	a5,mstatus,a5
50005710:	00008067          	ret

50005714 <atomic_or>:
50005714:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50005718:	3007b7f3          	csrrc	a5,mstatus,a5
5000571c:	00052703          	lw	a4,0(a0)
50005720:	fc17b7b3          	p.bclr	a5,a5,30,1
50005724:	00b765b3          	or	a1,a4,a1
50005728:	00b52023          	sw	a1,0(a0)
5000572c:	3007a7f3          	csrrs	a5,mstatus,a5
50005730:	00070513          	mv	a0,a4
50005734:	00008067          	ret

50005738 <atomic_and>:
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50005738:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
5000573c:	3007b7f3          	csrrc	a5,mstatus,a5
	unsigned int key;
	atomic_val_t ret;

	key = irq_lock();

	ret = *target;
50005740:	00052703          	lw	a4,0(a0)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50005744:	fc17b7b3          	p.bclr	a5,a5,30,1
	*target &= value;
50005748:	00b775b3          	and	a1,a4,a1
5000574c:	00b52023          	sw	a1,0(a0)
50005750:	3007a7f3          	csrrs	a5,mstatus,a5

	irq_unlock(key);

	return ret;
}
50005754:	00070513          	mv	a0,a4
50005758:	00008067          	ret

5000575c <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
5000575c:	ff010113          	addi	sp,sp,-16
50005760:	00912223          	sw	s1,4(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50005764:	510027b7          	lui	a5,0x51002
50005768:	00150493          	addi	s1,a0,1
5000576c:	a6078793          	addi	a5,a5,-1440 # 51001a60 <config_levels>
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
50005770:	00812423          	sw	s0,8(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50005774:	00249493          	slli	s1,s1,0x2
50005778:	00251413          	slli	s0,a0,0x2
5000577c:	2087f403          	p.lw	s0,s0(a5)
50005780:	2097f483          	p.lw	s1,s1(a5)
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
50005784:	00112623          	sw	ra,12(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50005788:	00947e63          	bleu	s1,s0,500057a4 <_sys_device_do_config_level+0x48>
								info++) {
		struct device_config *device = info->config;

		device->init(info);
5000578c:	00042783          	lw	a5,0(s0)
50005790:	00040513          	mv	a0,s0
50005794:	0047a783          	lw	a5,4(a5)
50005798:	000780e7          	jalr	a5
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
								info++) {
5000579c:	00c40413          	addi	s0,s0,12
500057a0:	fe9ff06f          	j	50005788 <_sys_device_do_config_level+0x2c>
		struct device_config *device = info->config;

		device->init(info);
	}
}
500057a4:	00c12083          	lw	ra,12(sp)
500057a8:	00812403          	lw	s0,8(sp)
500057ac:	00412483          	lw	s1,4(sp)
500057b0:	01010113          	addi	sp,sp,16
500057b4:	00008067          	ret

500057b8 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
500057b8:	ff010113          	addi	sp,sp,-16
500057bc:	00812423          	sw	s0,8(sp)
500057c0:	00912223          	sw	s1,4(sp)
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
500057c4:	51002437          	lui	s0,0x51002
500057c8:	510024b7          	lui	s1,0x51002
		device->init(info);
	}
}

struct device *device_get_binding(const char *name)
{
500057cc:	01212023          	sw	s2,0(sp)
500057d0:	00112623          	sw	ra,12(sp)
500057d4:	00050913          	mv	s2,a0
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
500057d8:	ac040413          	addi	s0,s0,-1344 # 51001ac0 <__device_PRE_KERNEL_1_start>
500057dc:	b1448493          	addi	s1,s1,-1260 # 51001b14 <__device_APPLICATION_start>
500057e0:	02940863          	beq	s0,s1,50005810 <device_get_binding+0x58>
		if (info->driver_api && !strcmp(name, info->config->name)) {
500057e4:	00442783          	lw	a5,4(s0)
500057e8:	00079663          	bnez	a5,500057f4 <device_get_binding+0x3c>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
500057ec:	00c40413          	addi	s0,s0,12
500057f0:	ff1ff06f          	j	500057e0 <device_get_binding+0x28>
		if (info->driver_api && !strcmp(name, info->config->name)) {
500057f4:	00042783          	lw	a5,0(s0)
500057f8:	00090513          	mv	a0,s2
500057fc:	0007a583          	lw	a1,0(a5)
50005800:	be1fa0ef          	jal	500003e0 <strcmp>
50005804:	fe0514e3          	bnez	a0,500057ec <device_get_binding+0x34>
50005808:	00040513          	mv	a0,s0
5000580c:	0080006f          	j	50005814 <device_get_binding+0x5c>
			return info;
		}
	}

	return NULL;
50005810:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
}
50005814:	00c12083          	lw	ra,12(sp)
50005818:	00812403          	lw	s0,8(sp)
5000581c:	00412483          	lw	s1,4(sp)
50005820:	00012903          	lw	s2,0(sp)
50005824:	01010113          	addi	sp,sp,16
50005828:	00008067          	ret

5000582c <_bss_zero>:
	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}

void __weak main(void)
{
5000582c:	51002537          	lui	a0,0x51002
50005830:	51002637          	lui	a2,0x51002
50005834:	d0050793          	addi	a5,a0,-768 # 51001d00 <__bss_start>
50005838:	47860613          	addi	a2,a2,1144 # 51002478 <__bss_end>
5000583c:	40f60633          	sub	a2,a2,a5
50005840:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005844:	d0050513          	addi	a0,a0,-768
50005848:	c91fa06f          	j	500004d8 <memset>

5000584c <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
5000584c:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
50005850:	00200513          	li	a0,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
50005854:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
50005858:	f05ff0ef          	jal	5000575c <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
5000585c:	00300513          	li	a0,3 # 3 <CONFIG_BLUETOOTH_RX_BUF_COUNT>
50005860:	efdff0ef          	jal	5000575c <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
50005864:	6d8010ef          	jal	50006f3c <_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
50005868:	b1dfa0ef          	jal	50000384 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
5000586c:	510027b7          	lui	a5,0x51002
50005870:	1e878793          	addi	a5,a5,488 # 510021e8 <_main_thread_s>
50005874:	0087c703          	lbu	a4,8(a5)
50005878:	c0073733          	p.bclr	a4,a4,0,0
5000587c:	00e78423          	sb	a4,8(a5)
}
50005880:	00c12083          	lw	ra,12(sp)
50005884:	01010113          	addi	sp,sp,16
50005888:	00008067          	ret

5000588c <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
5000588c:	f6010113          	addi	sp,sp,-160
50005890:	08812c23          	sw	s0,152(sp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
50005894:	51002437          	lui	s0,0x51002
50005898:	2c040793          	addi	a5,s0,704 # 510022c0 <_kernel>
5000589c:	01410713          	addi	a4,sp,20
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
500058a0:	08112e23          	sw	ra,156(sp)
500058a4:	08912a23          	sw	s1,148(sp)
500058a8:	09212823          	sw	s2,144(sp)
500058ac:	09312623          	sw	s3,140(sp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
500058b0:	00e7a423          	sw	a4,8(a5)

	dummy_thread->base.user_options = K_ESSENTIAL;
500058b4:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500058b8:	00f10e23          	sb	a5,28(sp)
	dummy_thread->base.thread_state = _THREAD_DUMMY;
500058bc:	00f10ea3          	sb	a5,29(sp)
}

static inline void _IntLibInit(void)
{
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
500058c0:	ad1ff0ef          	jal	50005390 <soc_interrupt_init>
500058c4:	510027b7          	lui	a5,0x51002
500058c8:	2dc78793          	addi	a5,a5,732 # 510022dc <_kernel+0x1c>
500058cc:	2c040413          	addi	s0,s0,704
500058d0:	020350fb          	lp.setupi	x1,32,500058dc <_Cstart+0x50>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
500058d4:	00f7a023          	sw	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
500058d8:	00f7a223          	sw	a5,4(a5)
500058dc:	00878793          	addi	a5,a5,8
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
500058e0:	51002937          	lui	s2,0x51002
500058e4:	1e890993          	addi	s3,s2,488 # 510021e8 <_main_thread_s>

	_new_thread(_main_thread, _main_stack,
500058e8:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
500058ec:	500066b7          	lui	a3,0x50006
500058f0:	510035b7          	lui	a1,0x51003
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
500058f4:	01342a23          	sw	s3,20(s0)

	_new_thread(_main_thread, _main_stack,
500058f8:	00000893          	li	a7,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500058fc:	00000813          	li	a6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005900:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005904:	84c68693          	addi	a3,a3,-1972 # 5000584c <_main>
50005908:	40000613          	li	a2,1024 # 400 <CONFIG_BLUETOOTH_RX_STACK_SIZE>
5000590c:	dd058593          	addi	a1,a1,-560 # 51002dd0 <_main_stack>
50005910:	1e890513          	addi	a0,s2,488
50005914:	00912023          	sw	s1,0(sp)
50005918:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000591c:	cf9ff0ef          	jal	50005614 <_new_thread>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
50005920:	0099c783          	lbu	a5,9(s3)
		    MAIN_STACK_SIZE, _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
50005924:	1e890513          	addi	a0,s2,488
50005928:	c027b7b3          	p.bclr	a5,a5,0,2
5000592c:	00f984a3          	sb	a5,9(s3)
50005930:	1c1000ef          	jal	500062f0 <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_thread, _idle_stack,
50005934:	51002937          	lui	s2,0x51002
50005938:	500076b7          	lui	a3,0x50007
5000593c:	510035b7          	lui	a1,0x51003
50005940:	00f00893          	li	a7,15 # f <CONFIG_NUM_PREEMPT_PRIORITIES>
50005944:	00000813          	li	a6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005948:	15c68693          	addi	a3,a3,348 # 5000715c <idle>
5000594c:	20000613          	li	a2,512 # 200 <CONFIG_IDLE_STACK_SIZE>
50005950:	1d058593          	addi	a1,a1,464 # 510031d0 <_idle_stack>
50005954:	25490993          	addi	s3,s2,596 # 51002254 <_idle_thread_s>
50005958:	00000713          	li	a4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000595c:	25490513          	addi	a0,s2,596
50005960:	00912023          	sw	s1,0(sp)
50005964:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005968:	cadff0ef          	jal	50005614 <_new_thread>
5000596c:	0099c783          	lbu	a5,9(s3)
		    IDLE_STACK_SIZE, idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
50005970:	25490513          	addi	a0,s2,596
50005974:	c027b7b3          	p.bclr	a5,a5,0,2
50005978:	00f984a3          	sb	a5,9(s3)
5000597c:	175000ef          	jal	500062f0 <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
50005980:	510027b7          	lui	a5,0x51002
50005984:	2cc78793          	addi	a5,a5,716 # 510022cc <_kernel+0xc>
50005988:	00f42623          	sw	a5,12(s0)
	list->tail = (sys_dnode_t *)list;
5000598c:	00f42823          	sw	a5,16(s0)
void k_cpu_idle(void);
void k_cpu_atomic_idle(unsigned int key);

static ALWAYS_INLINE void kernel_arch_init(void)
{
	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
50005990:	000017b7          	lui	a5,0x1
50005994:	80078713          	addi	a4,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
50005998:	510037b7          	lui	a5,0x51003
5000599c:	3d078793          	addi	a5,a5,976 # 510033d0 <_interrupt_stack>
500059a0:	00e787b3          	add	a5,a5,a4
	 */

	prepare_multithreading(dummy_thread);

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
500059a4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500059a8:	00f42223          	sw	a5,4(s0)
500059ac:	db1ff0ef          	jal	5000575c <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
500059b0:	00048513          	mv	a0,s1
500059b4:	da9ff0ef          	jal	5000575c <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
500059b8:	51002537          	lui	a0,0x51002
500059bc:	a7450513          	addi	a0,a0,-1420 # 51001a74 <config_levels+0x14>
500059c0:	d64fc0ef          	jal	50001f24 <printk>
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500059c4:	3004b4f3          	csrrc	s1,mstatus,s1

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
500059c8:	531000ef          	jal	500066f8 <_update_time_slice_before_swap>
#endif

	return __swap(key);
500059cc:	fc14b533          	p.bclr	a0,s1,30,1
500059d0:	991fa0ef          	jal	50000360 <__swap>

500059d4 <clear_event_registrations>:
	/* event->tag is left uninitialized: the user will set it if needed */
	event->type = type;
	event->state = K_POLL_STATE_NOT_READY;
	event->mode = mode;
	event->unused = 0;
	event->obj = obj;
500059d4:	00c00713          	li	a4,12 # c <_DEVICE_STRUCT_SIZE>
500059d8:	02e58733          	mul	a4,a1,a4
500059dc:	00870793          	addi	a5,a4,8
500059e0:	00f507b3          	add	a5,a0,a5
500059e4:	00e50533          	add	a0,a0,a4
500059e8:	fff00713          	li	a4,-1
500059ec:	00100813          	li	a6,1 # 1 <CONFIG_ARCH>
500059f0:	00258693          	addi	a3,a1,2
500059f4:	02e5de63          	ble	a4,a1,50005a30 <clear_event_registrations+0x5c>
500059f8:	00080693          	mv	a3,a6
500059fc:	0340006f          	j	50005a30 <clear_event_registrations+0x5c>
50005a00:	00554703          	lbu	a4,5(a0)
50005a04:	00052023          	sw	zero,0(a0)
50005a08:	f6473733          	p.bclr	a4,a4,27,4
50005a0c:	02273863          	p.bneimm	a4,2,50005a3c <clear_event_registrations+0x68>
50005a10:	0007a703          	lw	a4,0(a5)
50005a14:	00072823          	sw	zero,16(a4)
50005a18:	fc163633          	p.bclr	a2,a2,30,1
50005a1c:	30062673          	csrrs	a2,mstatus,a2
50005a20:	30083673          	csrrc	a2,mstatus,a6
50005a24:	fc163633          	p.bclr	a2,a2,30,1
50005a28:	ff478793          	addi	a5,a5,-12
50005a2c:	ff450513          	addi	a0,a0,-12
50005a30:	fff68693          	addi	a3,a3,-1
50005a34:	fc0696e3          	bnez	a3,50005a00 <clear_event_registrations+0x2c>
50005a38:	00008067          	ret
50005a3c:	fc472ae3          	p.beqimm	a4,4,50005a10 <clear_event_registrations+0x3c>
50005a40:	fc173ce3          	p.bneimm	a4,1,50005a18 <clear_event_registrations+0x44>
50005a44:	0007a703          	lw	a4,0(a5)
50005a48:	00072023          	sw	zero,0(a4)
50005a4c:	fcdff06f          	j	50005a18 <clear_event_registrations+0x44>

50005a50 <_signal_poll_event>:
50005a50:	00052783          	lw	a5,0(a0)
50005a54:	ff010113          	addi	sp,sp,-16
50005a58:	00812423          	sw	s0,8(sp)
50005a5c:	00912223          	sw	s1,4(sp)
50005a60:	00112623          	sw	ra,12(sp)
50005a64:	01212023          	sw	s2,0(sp)
50005a68:	00050413          	mv	s0,a0
50005a6c:	00058493          	mv	s1,a1
50005a70:	00062023          	sw	zero,0(a2)
50005a74:	0e078063          	beqz	a5,50005b54 <_signal_poll_event+0x104>
50005a78:	0007a783          	lw	a5,0(a5)
50005a7c:	0097c703          	lbu	a4,9(a5)
50005a80:	c05736b3          	p.bclr	a3,a4,0,5
50005a84:	00277713          	andi	a4,a4,2
50005a88:	00d784a3          	sb	a3,9(a5)
50005a8c:	0c070463          	beqz	a4,50005b54 <_signal_poll_event+0x104>
50005a90:	0207a703          	lw	a4,32(a5)
50005a94:	ff500513          	li	a0,-11 # fffffff5 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff6>
50005a98:	0fe72263          	p.beqimm	a4,-2,50005b7c <_signal_poll_event+0x12c>
50005a9c:	0007a683          	lw	a3,0(a5)
50005aa0:	0047a703          	lw	a4,4(a5)
50005aa4:	00d72023          	sw	a3,0(a4)
50005aa8:	0007a683          	lw	a3,0(a5)
50005aac:	00060913          	mv	s2,a2
50005ab0:	00e6a223          	sw	a4,4(a3)
50005ab4:	0097c703          	lbu	a4,9(a5)
50005ab8:	0207a603          	lw	a2,32(a5)
50005abc:	c0173733          	p.bclr	a4,a4,0,1
50005ac0:	00e784a3          	sb	a4,9(a5)
50005ac4:	05f62063          	p.beqimm	a2,-1,50005b04 <_signal_poll_event+0xb4>
50005ac8:	51002737          	lui	a4,0x51002
50005acc:	2d072703          	lw	a4,720(a4) # 510022d0 <_kernel+0x10>
50005ad0:	01078693          	addi	a3,a5,16
50005ad4:	00d70a63          	beq	a4,a3,50005ae8 <_signal_poll_event+0x98>
50005ad8:	0107a683          	lw	a3,16(a5)
50005adc:	0106a703          	lw	a4,16(a3)
50005ae0:	00c70733          	add	a4,a4,a2
50005ae4:	00e6a823          	sw	a4,16(a3)
50005ae8:	0147a703          	lw	a4,20(a5)
50005aec:	0107a683          	lw	a3,16(a5)
50005af0:	00d72023          	sw	a3,0(a4)
50005af4:	0107a683          	lw	a3,16(a5)
50005af8:	00e6a223          	sw	a4,4(a3)
50005afc:	fff00713          	li	a4,-1
50005b00:	02e7a023          	sw	a4,32(a5)
50005b04:	0097c703          	lbu	a4,9(a5)
50005b08:	0607a423          	sw	zero,104(a5)
50005b0c:	f4573733          	p.bclr	a4,a4,26,5
50005b10:	04071263          	bnez	a4,50005b54 <_signal_poll_event+0x104>
50005b14:	0207a703          	lw	a4,32(a5)
50005b18:	03f73e63          	p.bneimm	a4,-1,50005b54 <_signal_poll_event+0x104>
50005b1c:	00078513          	mv	a0,a5
50005b20:	7d0000ef          	jal	500062f0 <_add_thread_to_ready_q>
50005b24:	510027b7          	lui	a5,0x51002
50005b28:	2c07a703          	lw	a4,704(a5) # 510022c0 <_kernel>
50005b2c:	04071463          	bnez	a4,50005b74 <_signal_poll_event+0x124>
50005b30:	2c078793          	addi	a5,a5,704
50005b34:	0087a783          	lw	a5,8(a5)
50005b38:	00a7d703          	lhu	a4,10(a5)
50005b3c:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
50005b40:	02e7ea63          	bltu	a5,a4,50005b74 <_signal_poll_event+0x124>
50005b44:	1a1000ef          	jal	500064e4 <__must_switch_threads>
50005b48:	02050663          	beqz	a0,50005b74 <_signal_poll_event+0x124>
50005b4c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50005b50:	00f92023          	sw	a5,0(s2)
50005b54:	00442783          	lw	a5,4(s0)
50005b58:	c8c79733          	p.extractu	a4,a5,4,12
50005b5c:	00e4e5b3          	or	a1,s1,a4
50005b60:	c8c5a7b3          	p.insert	a5,a1,4,12
50005b64:	00042023          	sw	zero,0(s0)
50005b68:	00f42223          	sw	a5,4(s0)
50005b6c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005b70:	00c0006f          	j	50005b7c <_signal_poll_event+0x12c>
50005b74:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005b78:	fd9ff06f          	j	50005b50 <_signal_poll_event+0x100>
50005b7c:	00c12083          	lw	ra,12(sp)
50005b80:	00812403          	lw	s0,8(sp)
50005b84:	00412483          	lw	s1,4(sp)
50005b88:	00012903          	lw	s2,0(sp)
50005b8c:	01010113          	addi	sp,sp,16
50005b90:	00008067          	ret

50005b94 <k_poll>:
	event->poller = NULL;
	event->state |= state;
}

int k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
50005b94:	fd010113          	addi	sp,sp,-48
50005b98:	01412c23          	sw	s4,24(sp)
50005b9c:	02112623          	sw	ra,44(sp)
50005ba0:	02812423          	sw	s0,40(sp)
50005ba4:	02912223          	sw	s1,36(sp)
50005ba8:	03212023          	sw	s2,32(sp)
50005bac:	01312e23          	sw	s3,28(sp)
50005bb0:	00050a13          	mv	s4,a0
50005bb4:	00100813          	li	a6,1 # 1 <CONFIG_ARCH>
50005bb8:	300836f3          	csrrc	a3,mstatus,a6

	int last_registered = -1, in_use = 0, rc;
	unsigned int key;

	key = irq_lock();
	set_polling_state(_current);
50005bbc:	51002737          	lui	a4,0x51002
50005bc0:	2c070793          	addi	a5,a4,704 # 510022c0 <_kernel>
50005bc4:	0087a883          	lw	a7,8(a5)
#endif
}

static inline void _set_thread_states(struct k_thread *thread, u32_t states)
{
	thread->base.thread_state |= states;
50005bc8:	0098c503          	lbu	a0,9(a7)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50005bcc:	fc16b6b3          	p.bclr	a3,a3,30,1
50005bd0:	c0554533          	p.bset	a0,a0,0,5
50005bd4:	00a884a3          	sb	a0,9(a7)
50005bd8:	3006a6f3          	csrrs	a3,mstatus,a3
	/*
	 * We can get by with one poller structure for all events for now:
	 * if/when we allow multiple threads to poll on the same object, we
	 * will need one per poll event associated with an object.
	 */
	struct _poller poller = { .thread = _current };
50005bdc:	0087a783          	lw	a5,8(a5)
50005be0:	00f12223          	sw	a5,4(sp)
50005be4:	008a0693          	addi	a3,s4,8
50005be8:	000a0793          	mv	a5,s4
{
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(events, "NULL events\n");
	__ASSERT(num_events > 0, "zero events\n");

	int last_registered = -1, in_use = 0, rc;
50005bec:	00000413          	li	s0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005bf0:	fff00993          	li	s3,-1
50005bf4:	2c070713          	addi	a4,a4,704
			set_event_ready(&events[ii], state);
			clear_polling_state(_current);
		} else if (timeout != K_NO_WAIT && is_polling() && !in_use) {
			rc = register_event(&events[ii]);
			if (rc == 0) {
				events[ii].poller = &poller;
50005bf8:	00410e93          	addi	t4,sp,4
50005bfc:	01058333          	add	t1,a1,a6
50005c00:	0405da63          	bgez	a1,50005c54 <k_poll+0xc0>
50005c04:	00080313          	mv	t1,a6
50005c08:	04c0006f          	j	50005c54 <k_poll+0xc0>
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50005c0c:	300838f3          	csrrc	a7,mstatus,a6
}

/* must be called with interrupts locked */
static inline int is_condition_met(struct k_poll_event *event, u32_t *state)
{
	switch (event->type) {
50005c10:	0057c503          	lbu	a0,5(a5)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50005c14:	fc18b8b3          	p.bclr	a7,a7,30,1
50005c18:	f6453533          	p.bclr	a0,a0,27,4
50005c1c:	04252e63          	p.beqimm	a0,2,50005c78 <k_poll+0xe4>
50005c20:	04453263          	p.bneimm	a0,4,50005c64 <k_poll+0xd0>
50005c24:	0006a583          	lw	a1,0(a3)
			return 1;
		}
		break;
	case K_POLL_TYPE_DATA_AVAILABLE:
		if (!k_queue_is_empty(event->queue)) {
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
50005c28:	00800e13          	li	t3,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
			*state = K_POLL_STATE_SEM_AVAILABLE;
			return 1;
		}
		break;
	case K_POLL_TYPE_DATA_AVAILABLE:
		if (!k_queue_is_empty(event->queue)) {
50005c2c:	0085a583          	lw	a1,8(a1)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
			return 1;
		}
		break;
	case K_POLL_TYPE_SIGNAL:
		if (event->signal->signaled) {
50005c30:	0e059863          	bnez	a1,50005d20 <k_poll+0x18c>

		key = irq_lock();
		if (is_condition_met(&events[ii], &state)) {
			set_event_ready(&events[ii], state);
			clear_polling_state(_current);
		} else if (timeout != K_NO_WAIT && is_polling() && !in_use) {
50005c34:	00060a63          	beqz	a2,50005c48 <k_poll+0xb4>
}

/* must be called with interrupts locked */
static inline int is_polling(void)
{
	return _is_thread_polling(_current);
50005c38:	00872583          	lw	a1,8(a4)

		key = irq_lock();
		if (is_condition_met(&events[ii], &state)) {
			set_event_ready(&events[ii], state);
			clear_polling_state(_current);
		} else if (timeout != K_NO_WAIT && is_polling() && !in_use) {
50005c3c:	0095ce03          	lbu	t3,9(a1)
50005c40:	020e7e13          	andi	t3,t3,32
50005c44:	100e1463          	bnez	t3,50005d4c <k_poll+0x1b8>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50005c48:	3008a8f3          	csrrs	a7,mstatus,a7
50005c4c:	00c78793          	addi	a5,a5,12
50005c50:	00c68693          	addi	a3,a3,12
50005c54:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
50005c58:	fff30313          	addi	t1,t1,-1
50005c5c:	fa0318e3          	bnez	t1,50005c0c <k_poll+0x78>
50005c60:	02c0006f          	j	50005c8c <k_poll+0xf8>
}

/* must be called with interrupts locked */
static inline int is_condition_met(struct k_poll_event *event, u32_t *state)
{
	switch (event->type) {
50005c64:	fc1538e3          	p.bneimm	a0,1,50005c34 <k_poll+0xa0>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
			return 1;
		}
		break;
	case K_POLL_TYPE_SIGNAL:
		if (event->signal->signaled) {
50005c68:	0006a583          	lw	a1,0(a3)
			*state = K_POLL_STATE_SIGNALED;
50005c6c:	00200e13          	li	t3,2 # 2 <CONFIG_BLUETOOTH_HCI_CMD_COUNT>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
			return 1;
		}
		break;
	case K_POLL_TYPE_SIGNAL:
		if (event->signal->signaled) {
50005c70:	0045a583          	lw	a1,4(a1)
50005c74:	fbdff06f          	j	50005c30 <k_poll+0x9c>
50005c78:	0006a583          	lw	a1,0(a3)
/* must be called with interrupts locked */
static inline int is_condition_met(struct k_poll_event *event, u32_t *state)
{
	switch (event->type) {
	case K_POLL_TYPE_SEM_AVAILABLE:
		if (k_sem_count_get(event->sem) > 0) {
50005c7c:	0085a583          	lw	a1,8(a1)
50005c80:	fa058ae3          	beqz	a1,50005c34 <k_poll+0xa0>
			*state = K_POLL_STATE_SEM_AVAILABLE;
50005c84:	00400e13          	li	t3,4 # 4 <__NANO_ESF_gp_OFFSET>
50005c88:	0980006f          	j	50005d20 <k_poll+0x18c>
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50005c8c:	3004b973          	csrrc	s2,mstatus,s1
}

/* must be called with interrupts locked */
static inline int is_polling(void)
{
	return _is_thread_polling(_current);
50005c90:	00872703          	lw	a4,8(a4)
50005c94:	00974783          	lbu	a5,9(a4)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50005c98:	fc193933          	p.bclr	s2,s2,30,1
	 * success or a -EADDRINUSE error. In the case of a -EADDRINUSE error,
	 * the events that were available are still flagged as such, and it is
	 * valid for the caller to consider them available, as if this function
	 * returned success.
	 */
	if (!is_polling()) {
50005c9c:	0207f693          	andi	a3,a5,32
50005ca0:	00069e63          	bnez	a3,50005cbc <k_poll+0x128>
		clear_event_registrations(events, last_registered, key);
50005ca4:	00090613          	mv	a2,s2
50005ca8:	00098593          	mv	a1,s3
50005cac:	000a0513          	mv	a0,s4
50005cb0:	d25ff0ef          	jal	500059d4 <clear_event_registrations>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50005cb4:	30092973          	csrrs	s2,mstatus,s2
50005cb8:	0600006f          	j	50005d18 <k_poll+0x184>
}

static inline void _reset_thread_states(struct k_thread *thread,
					u32_t states)
{
	thread->base.thread_state &= ~states;
50005cbc:	c057b7b3          	p.bclr	a5,a5,0,5
50005cc0:	00f704a3          	sb	a5,9(a4)
		return in_use;
	}

	clear_polling_state(_current);

	if (timeout == K_NO_WAIT) {
50005cc4:	00061863          	bnez	a2,50005cd4 <k_poll+0x140>
50005cc8:	30092973          	csrrs	s2,mstatus,s2
		irq_unlock(key);
		return -EAGAIN;
50005ccc:	ff500513          	li	a0,-11 # fffffff5 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff6>
50005cd0:	0e40006f          	j	50005db4 <k_poll+0x220>
	}

	_wait_q_t wait_q = _WAIT_Q_INIT(&wait_q);
50005cd4:	00810793          	addi	a5,sp,8

	_pend_current_thread(&wait_q, timeout);
50005cd8:	00078513          	mv	a0,a5
50005cdc:	00060593          	mv	a1,a2
	if (timeout == K_NO_WAIT) {
		irq_unlock(key);
		return -EAGAIN;
	}

	_wait_q_t wait_q = _WAIT_Q_INIT(&wait_q);
50005ce0:	00f12423          	sw	a5,8(sp)
50005ce4:	00f12623          	sw	a5,12(sp)

	_pend_current_thread(&wait_q, timeout);
50005ce8:	7ac000ef          	jal	50006494 <_pend_current_thread>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
50005cec:	20d000ef          	jal	500066f8 <_update_time_slice_before_swap>
#endif

	return __swap(key);
50005cf0:	00090513          	mv	a0,s2
50005cf4:	e6cfa0ef          	jal	50000360 <__swap>
50005cf8:	00050413          	mv	s0,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50005cfc:	3004b4f3          	csrrc	s1,mstatus,s1
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50005d00:	fc14b4b3          	p.bclr	s1,s1,30,1
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = irq_lock();
	clear_event_registrations(events, last_registered, key);
50005d04:	00048613          	mv	a2,s1
50005d08:	00098593          	mv	a1,s3
50005d0c:	000a0513          	mv	a0,s4
50005d10:	cc5ff0ef          	jal	500059d4 <clear_event_registrations>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50005d14:	3004a4f3          	csrrs	s1,mstatus,s1
	irq_unlock(key);

	return swap_rc;
50005d18:	00040513          	mv	a0,s0
50005d1c:	0980006f          	j	50005db4 <k_poll+0x220>
}

static inline void set_event_ready(struct k_poll_event *event, u32_t state)
{
	event->poller = NULL;
	event->state |= state;
50005d20:	0047a503          	lw	a0,4(a5)
50005d24:	c8c515b3          	p.extractu	a1,a0,4,12
50005d28:	00be65b3          	or	a1,t3,a1
50005d2c:	c8c5a533          	p.insert	a0,a1,4,12
	}
}

static inline void set_event_ready(struct k_poll_event *event, u32_t state)
{
	event->poller = NULL;
50005d30:	0007a023          	sw	zero,0(a5)
	event->state |= state;
50005d34:	00a7a223          	sw	a0,4(a5)
		u32_t state;

		key = irq_lock();
		if (is_condition_met(&events[ii], &state)) {
			set_event_ready(&events[ii], state);
			clear_polling_state(_current);
50005d38:	00872503          	lw	a0,8(a4)
50005d3c:	00954583          	lbu	a1,9(a0)
50005d40:	c055b5b3          	p.bclr	a1,a1,0,5
50005d44:	00b504a3          	sb	a1,9(a0)
50005d48:	f01ff06f          	j	50005c48 <k_poll+0xb4>
		} else if (timeout != K_NO_WAIT && is_polling() && !in_use) {
50005d4c:	ee041ee3          	bnez	s0,50005c48 <k_poll+0xb4>
}

/* must be called with interrupts locked */
static inline int register_event(struct k_poll_event *event)
{
	switch (event->type) {
50005d50:	00252863          	p.beqimm	a0,2,50005d60 <k_poll+0x1cc>
50005d54:	00452663          	p.beqimm	a0,4,50005d60 <k_poll+0x1cc>
50005d58:	04153863          	p.bneimm	a0,1,50005da8 <k_poll+0x214>
50005d5c:	0180006f          	j	50005d74 <k_poll+0x1e0>
		}
		event->sem->poll_event = event;
		break;
	case K_POLL_TYPE_DATA_AVAILABLE:
		__ASSERT(event->queue, "invalid queue\n");
		if (event->queue->poll_event) {
50005d60:	0006a503          	lw	a0,0(a3)
50005d64:	01052e03          	lw	t3,16(a0)
50005d68:	020e1063          	bnez	t3,50005d88 <k_poll+0x1f4>
			return -EADDRINUSE;
		}
		event->queue->poll_event = event;
50005d6c:	00f52823          	sw	a5,16(a0)
50005d70:	0380006f          	j	50005da8 <k_poll+0x214>
		break;
	case K_POLL_TYPE_SIGNAL:
		__ASSERT(event->queue, "invalid poll signal\n");
		if (event->signal->poll_event) {
50005d74:	0006a503          	lw	a0,0(a3)
50005d78:	00052e03          	lw	t3,0(a0)
50005d7c:	000e1663          	bnez	t3,50005d88 <k_poll+0x1f4>
			return -EADDRINUSE;
		}
		event->signal->poll_event = event;
50005d80:	00f52023          	sw	a5,0(a0)
50005d84:	0240006f          	j	50005da8 <k_poll+0x214>
			} else if (rc == -EADDRINUSE) {
				/* setting in_use also prevents any further
				 * registrations by the current thread
				 */
				in_use = -EADDRINUSE;
				events[ii].state = K_POLL_STATE_EADDRINUSE;
50005d88:	0047a503          	lw	a0,4(a5)
50005d8c:	c8c82533          	p.insert	a0,a6,4,12
50005d90:	00a7a223          	sw	a0,4(a5)
50005d94:	0095c503          	lbu	a0,9(a1)
				++last_registered;
			} else if (rc == -EADDRINUSE) {
				/* setting in_use also prevents any further
				 * registrations by the current thread
				 */
				in_use = -EADDRINUSE;
50005d98:	fd000413          	li	s0,-48 # ffffffd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffd1>
50005d9c:	c0553533          	p.bclr	a0,a0,0,5
50005da0:	00a584a3          	sb	a0,9(a1)
50005da4:	ea5ff06f          	j	50005c48 <k_poll+0xb4>
			set_event_ready(&events[ii], state);
			clear_polling_state(_current);
		} else if (timeout != K_NO_WAIT && is_polling() && !in_use) {
			rc = register_event(&events[ii]);
			if (rc == 0) {
				events[ii].poller = &poller;
50005da8:	01d7a023          	sw	t4,0(a5)
				++last_registered;
50005dac:	00198993          	addi	s3,s3,1
50005db0:	e99ff06f          	j	50005c48 <k_poll+0xb4>
	key = irq_lock();
	clear_event_registrations(events, last_registered, key);
	irq_unlock(key);

	return swap_rc;
}
50005db4:	02c12083          	lw	ra,44(sp)
50005db8:	02812403          	lw	s0,40(sp)
50005dbc:	02412483          	lw	s1,36(sp)
50005dc0:	02012903          	lw	s2,32(sp)
50005dc4:	01c12983          	lw	s3,28(sp)
50005dc8:	01812a03          	lw	s4,24(sp)
50005dcc:	03010113          	addi	sp,sp,48
50005dd0:	00008067          	ret

50005dd4 <_handle_obj_poll_event>:
}

/* returns 1 if a reschedule must take place, 0 otherwise */
/* *obj_poll_event is guaranteed to not be NULL */
int _handle_obj_poll_event(struct k_poll_event **obj_poll_event, u32_t state)
{
50005dd4:	fe010113          	addi	sp,sp,-32
50005dd8:	00050793          	mv	a5,a0
	struct k_poll_event *poll_event = *obj_poll_event;
50005ddc:	00052503          	lw	a0,0(a0)
	int must_reschedule;

	*obj_poll_event = NULL;
	(void)_signal_poll_event(poll_event, state, &must_reschedule);
50005de0:	00c10613          	addi	a2,sp,12
int _handle_obj_poll_event(struct k_poll_event **obj_poll_event, u32_t state)
{
	struct k_poll_event *poll_event = *obj_poll_event;
	int must_reschedule;

	*obj_poll_event = NULL;
50005de4:	0007a023          	sw	zero,0(a5)
}

/* returns 1 if a reschedule must take place, 0 otherwise */
/* *obj_poll_event is guaranteed to not be NULL */
int _handle_obj_poll_event(struct k_poll_event **obj_poll_event, u32_t state)
{
50005de8:	00112e23          	sw	ra,28(sp)
	struct k_poll_event *poll_event = *obj_poll_event;
	int must_reschedule;

	*obj_poll_event = NULL;
	(void)_signal_poll_event(poll_event, state, &must_reschedule);
50005dec:	c65ff0ef          	jal	50005a50 <_signal_poll_event>
	return must_reschedule;
}
50005df0:	01c12083          	lw	ra,28(sp)
50005df4:	00c12503          	lw	a0,12(sp)
50005df8:	02010113          	addi	sp,sp,32
50005dfc:	00008067          	ret

50005e00 <_ready_thread>:
	 *   field of the node object type
	 * - list->tail->next = NULL.
	 */
	k_queue_append_list(queue, list->head, list->tail);
	sys_slist_init(list);
}
50005e00:	00954703          	lbu	a4,9(a0)
50005e04:	c02736b3          	p.bclr	a3,a4,0,2
50005e08:	01b77713          	andi	a4,a4,27
50005e0c:	00d504a3          	sb	a3,9(a0)
50005e10:	00071863          	bnez	a4,50005e20 <_ready_thread+0x20>
50005e14:	02052783          	lw	a5,32(a0)
50005e18:	01f7b463          	p.bneimm	a5,-1,50005e20 <_ready_thread+0x20>
50005e1c:	4d40006f          	j	500062f0 <_add_thread_to_ready_q>
50005e20:	00008067          	ret

50005e24 <handle_poll_event>:
50005e24:	01052783          	lw	a5,16(a0)
50005e28:	00078863          	beqz	a5,50005e38 <handle_poll_event+0x14>
50005e2c:	00800593          	li	a1,8 # 8 <CONFIG_BLUETOOTH_RX_PRIO>
50005e30:	01050513          	addi	a0,a0,16
50005e34:	fa1ff06f          	j	50005dd4 <_handle_obj_poll_event>
50005e38:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005e3c:	00008067          	ret

50005e40 <_Swap>:
50005e40:	ff010113          	addi	sp,sp,-16
50005e44:	00812423          	sw	s0,8(sp)
50005e48:	00050413          	mv	s0,a0
50005e4c:	00112623          	sw	ra,12(sp)
50005e50:	0a9000ef          	jal	500066f8 <_update_time_slice_before_swap>
50005e54:	00040513          	mv	a0,s0
50005e58:	00c12083          	lw	ra,12(sp)
50005e5c:	00812403          	lw	s0,8(sp)
50005e60:	01010113          	addi	sp,sp,16
50005e64:	cfcfa06f          	j	50000360 <__swap>

50005e68 <_must_switch_threads>:
50005e68:	510027b7          	lui	a5,0x51002
50005e6c:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
50005e70:	00a7d703          	lhu	a4,10(a5)
50005e74:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
50005e78:	02e7e063          	bltu	a5,a4,50005e98 <_must_switch_threads+0x30>
50005e7c:	ff010113          	addi	sp,sp,-16
50005e80:	00112623          	sw	ra,12(sp)
50005e84:	660000ef          	jal	500064e4 <__must_switch_threads>
50005e88:	00c12083          	lw	ra,12(sp)
50005e8c:	00a03533          	snez	a0,a0
50005e90:	01010113          	addi	sp,sp,16
50005e94:	00008067          	ret
50005e98:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005e9c:	00008067          	ret

50005ea0 <_unpend_first_thread>:
50005ea0:	510027b7          	lui	a5,0x51002
50005ea4:	3e87a783          	lw	a5,1000(a5) # 510023e8 <_handling_timeouts>
50005ea8:	00052703          	lw	a4,0(a0)
50005eac:	02078463          	beqz	a5,50005ed4 <_unpend_first_thread+0x34>
50005eb0:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005eb4:	04e50c63          	beq	a0,a4,50005f0c <_unpend_first_thread+0x6c>
50005eb8:	04070863          	beqz	a4,50005f08 <_unpend_first_thread+0x68>
50005ebc:	02072783          	lw	a5,32(a4)
50005ec0:	03e7b063          	p.bneimm	a5,-2,50005ee0 <_unpend_first_thread+0x40>
50005ec4:	00452783          	lw	a5,4(a0)
50005ec8:	04e78063          	beq	a5,a4,50005f08 <_unpend_first_thread+0x68>
50005ecc:	00072703          	lw	a4,0(a4)
50005ed0:	fe9ff06f          	j	50005eb8 <_unpend_first_thread+0x18>
50005ed4:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005ed8:	02e50a63          	beq	a0,a4,50005f0c <_unpend_first_thread+0x6c>
50005edc:	02070863          	beqz	a4,50005f0c <_unpend_first_thread+0x6c>
50005ee0:	00070793          	mv	a5,a4
50005ee4:	0007a683          	lw	a3,0(a5)
50005ee8:	00472703          	lw	a4,4(a4)
50005eec:	00d72023          	sw	a3,0(a4)
50005ef0:	0007a683          	lw	a3,0(a5)
50005ef4:	00e6a223          	sw	a4,4(a3)
50005ef8:	0097c703          	lbu	a4,9(a5)
50005efc:	c0173733          	p.bclr	a4,a4,0,1
50005f00:	00e784a3          	sb	a4,9(a5)
50005f04:	0080006f          	j	50005f0c <_unpend_first_thread+0x6c>
50005f08:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005f0c:	00078513          	mv	a0,a5
50005f10:	00008067          	ret

50005f14 <_abort_timeout>:
50005f14:	00050793          	mv	a5,a0
50005f18:	01052503          	lw	a0,16(a0)
50005f1c:	05f52063          	p.beqimm	a0,-1,50005f5c <_abort_timeout+0x48>
50005f20:	51002737          	lui	a4,0x51002
50005f24:	2d072703          	lw	a4,720(a4) # 510022d0 <_kernel+0x10>
50005f28:	00e78a63          	beq	a5,a4,50005f3c <_abort_timeout+0x28>
50005f2c:	0007a683          	lw	a3,0(a5)
50005f30:	0106a703          	lw	a4,16(a3)
50005f34:	00a70533          	add	a0,a4,a0
50005f38:	00a6a823          	sw	a0,16(a3)
50005f3c:	0007a683          	lw	a3,0(a5)
50005f40:	0047a703          	lw	a4,4(a5)
50005f44:	00d72023          	sw	a3,0(a4)
50005f48:	0007a683          	lw	a3,0(a5)
50005f4c:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50005f50:	00e6a223          	sw	a4,4(a3)
50005f54:	fff00713          	li	a4,-1
50005f58:	00e7a823          	sw	a4,16(a5)
50005f5c:	00008067          	ret

50005f60 <k_queue_init>:
50005f60:	00052423          	sw	zero,8(a0)
50005f64:	00052623          	sw	zero,12(a0)
50005f68:	00a52023          	sw	a0,0(a0)
50005f6c:	00a52223          	sw	a0,4(a0)
50005f70:	00052823          	sw	zero,16(a0)
50005f74:	00008067          	ret

50005f78 <k_queue_insert>:
50005f78:	fe010113          	addi	sp,sp,-32
50005f7c:	00812c23          	sw	s0,24(sp)
50005f80:	00912a23          	sw	s1,20(sp)
50005f84:	01212823          	sw	s2,16(sp)
50005f88:	01412423          	sw	s4,8(sp)
50005f8c:	00112e23          	sw	ra,28(sp)
50005f90:	01312623          	sw	s3,12(sp)
50005f94:	00050493          	mv	s1,a0
50005f98:	00058a13          	mv	s4,a1
50005f9c:	00060413          	mv	s0,a2
50005fa0:	00100913          	li	s2,1 # 1 <CONFIG_ARCH>
50005fa4:	30093973          	csrrc	s2,mstatus,s2
50005fa8:	fc193933          	p.bclr	s2,s2,30,1
50005fac:	ef5ff0ef          	jal	50005ea0 <_unpend_first_thread>
50005fb0:	02050a63          	beqz	a0,50005fe4 <k_queue_insert+0x6c>
50005fb4:	00050993          	mv	s3,a0
50005fb8:	01050513          	addi	a0,a0,16
50005fbc:	f59ff0ef          	jal	50005f14 <_abort_timeout>
50005fc0:	00098513          	mv	a0,s3
50005fc4:	e3dff0ef          	jal	50005e00 <_ready_thread>
50005fc8:	510027b7          	lui	a5,0x51002
50005fcc:	2c07a783          	lw	a5,704(a5) # 510022c0 <_kernel>
50005fd0:	0609a423          	sw	zero,104(s3)
50005fd4:	0089a623          	sw	s0,12(s3)
50005fd8:	08079663          	bnez	a5,50006064 <k_queue_insert+0xec>
50005fdc:	e8dff0ef          	jal	50005e68 <_must_switch_threads>
50005fe0:	05c0006f          	j	5000603c <k_queue_insert+0xc4>
50005fe4:	000a1e63          	bnez	s4,50006000 <k_queue_insert+0x88>
50005fe8:	0084a783          	lw	a5,8(s1)
50005fec:	00f42023          	sw	a5,0(s0)
50005ff0:	00c4a783          	lw	a5,12(s1)
50005ff4:	0084a423          	sw	s0,8(s1)
50005ff8:	02079e63          	bnez	a5,50006034 <k_queue_insert+0xbc>
50005ffc:	0280006f          	j	50006024 <k_queue_insert+0xac>
50006000:	000a2783          	lw	a5,0(s4)
50006004:	02079463          	bnez	a5,5000602c <k_queue_insert+0xb4>
50006008:	00c4a783          	lw	a5,12(s1)
5000600c:	00042023          	sw	zero,0(s0)
50006010:	00079863          	bnez	a5,50006020 <k_queue_insert+0xa8>
50006014:	0084a623          	sw	s0,12(s1)
50006018:	0084a423          	sw	s0,8(s1)
5000601c:	0180006f          	j	50006034 <k_queue_insert+0xbc>
50006020:	0087a023          	sw	s0,0(a5)
50006024:	0084a623          	sw	s0,12(s1)
50006028:	00c0006f          	j	50006034 <k_queue_insert+0xbc>
5000602c:	00f42023          	sw	a5,0(s0)
50006030:	008a2023          	sw	s0,0(s4)
50006034:	00048513          	mv	a0,s1
50006038:	dedff0ef          	jal	50005e24 <handle_poll_event>
5000603c:	02050463          	beqz	a0,50006064 <k_queue_insert+0xec>
50006040:	00090513          	mv	a0,s2
50006044:	01c12083          	lw	ra,28(sp)
50006048:	01812403          	lw	s0,24(sp)
5000604c:	01412483          	lw	s1,20(sp)
50006050:	01012903          	lw	s2,16(sp)
50006054:	00c12983          	lw	s3,12(sp)
50006058:	00812a03          	lw	s4,8(sp)
5000605c:	02010113          	addi	sp,sp,32
50006060:	de1ff06f          	j	50005e40 <_Swap>
50006064:	30092973          	csrrs	s2,mstatus,s2
50006068:	01c12083          	lw	ra,28(sp)
5000606c:	01812403          	lw	s0,24(sp)
50006070:	01412483          	lw	s1,20(sp)
50006074:	01012903          	lw	s2,16(sp)
50006078:	00c12983          	lw	s3,12(sp)
5000607c:	00812a03          	lw	s4,8(sp)
50006080:	02010113          	addi	sp,sp,32
50006084:	00008067          	ret

50006088 <k_queue_append>:
50006088:	00058613          	mv	a2,a1
5000608c:	00c52583          	lw	a1,12(a0)
50006090:	ee9ff06f          	j	50005f78 <k_queue_insert>

50006094 <k_queue_prepend>:
50006094:	00058613          	mv	a2,a1
50006098:	00000593          	li	a1,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000609c:	eddff06f          	j	50005f78 <k_queue_insert>

500060a0 <k_queue_append_list>:
500060a0:	fe010113          	addi	sp,sp,-32
500060a4:	00812c23          	sw	s0,24(sp)
500060a8:	00912a23          	sw	s1,20(sp)
500060ac:	01212823          	sw	s2,16(sp)
500060b0:	01512223          	sw	s5,4(sp)
500060b4:	00112e23          	sw	ra,28(sp)
500060b8:	01312623          	sw	s3,12(sp)
500060bc:	01412423          	sw	s4,8(sp)
500060c0:	00050493          	mv	s1,a0
500060c4:	00058913          	mv	s2,a1
500060c8:	00060a93          	mv	s5,a2
500060cc:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500060d0:	30043473          	csrrc	s0,mstatus,s0
500060d4:	00052a03          	lw	s4,0(a0)
500060d8:	fc143433          	p.bclr	s0,s0,30,1
500060dc:	03451c63          	bne	a0,s4,50006114 <k_queue_append_list+0x74>
500060e0:	00000a13          	li	s4,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500060e4:	0300006f          	j	50006114 <k_queue_append_list+0x74>
500060e8:	00048513          	mv	a0,s1
500060ec:	db5ff0ef          	jal	50005ea0 <_unpend_first_thread>
500060f0:	00050993          	mv	s3,a0
500060f4:	02050463          	beqz	a0,5000611c <k_queue_append_list+0x7c>
500060f8:	01098513          	addi	a0,s3,16
500060fc:	e19ff0ef          	jal	50005f14 <_abort_timeout>
50006100:	00098513          	mv	a0,s3
50006104:	cfdff0ef          	jal	50005e00 <_ready_thread>
50006108:	0129a623          	sw	s2,12(s3)
5000610c:	00092903          	lw	s2,0(s2)
50006110:	0609a423          	sw	zero,104(s3)
50006114:	fc091ae3          	bnez	s2,500060e8 <k_queue_append_list+0x48>
50006118:	0140006f          	j	5000612c <k_queue_append_list+0x8c>
5000611c:	00c4a783          	lw	a5,12(s1)
50006120:	08079063          	bnez	a5,500061a0 <k_queue_append_list+0x100>
50006124:	0124a423          	sw	s2,8(s1)
50006128:	0154a623          	sw	s5,12(s1)
5000612c:	000a0c63          	beqz	s4,50006144 <k_queue_append_list+0xa4>
50006130:	510027b7          	lui	a5,0x51002
50006134:	2c07a783          	lw	a5,704(a5) # 510022c0 <_kernel>
50006138:	04079063          	bnez	a5,50006178 <k_queue_append_list+0xd8>
5000613c:	d2dff0ef          	jal	50005e68 <_must_switch_threads>
50006140:	00c0006f          	j	5000614c <k_queue_append_list+0xac>
50006144:	00048513          	mv	a0,s1
50006148:	cddff0ef          	jal	50005e24 <handle_poll_event>
5000614c:	02050663          	beqz	a0,50006178 <k_queue_append_list+0xd8>
50006150:	00040513          	mv	a0,s0
50006154:	01c12083          	lw	ra,28(sp)
50006158:	01812403          	lw	s0,24(sp)
5000615c:	01412483          	lw	s1,20(sp)
50006160:	01012903          	lw	s2,16(sp)
50006164:	00c12983          	lw	s3,12(sp)
50006168:	00812a03          	lw	s4,8(sp)
5000616c:	00412a83          	lw	s5,4(sp)
50006170:	02010113          	addi	sp,sp,32
50006174:	ccdff06f          	j	50005e40 <_Swap>
50006178:	30042473          	csrrs	s0,mstatus,s0
5000617c:	01c12083          	lw	ra,28(sp)
50006180:	01812403          	lw	s0,24(sp)
50006184:	01412483          	lw	s1,20(sp)
50006188:	01012903          	lw	s2,16(sp)
5000618c:	00c12983          	lw	s3,12(sp)
50006190:	00812a03          	lw	s4,8(sp)
50006194:	00412a83          	lw	s5,4(sp)
50006198:	02010113          	addi	sp,sp,32
5000619c:	00008067          	ret
500061a0:	0127a023          	sw	s2,0(a5)
500061a4:	f85ff06f          	j	50006128 <k_queue_append_list+0x88>

500061a8 <k_queue_get>:

void *k_queue_get(struct k_queue *queue, s32_t timeout)
{
500061a8:	ff010113          	addi	sp,sp,-16
500061ac:	00812423          	sw	s0,8(sp)
500061b0:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500061b4:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500061b8:	30043473          	csrrc	s0,mstatus,s0
500061bc:	00852783          	lw	a5,8(a0)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
500061c0:	fc143433          	p.bclr	s0,s0,30,1
	unsigned int key;
	void *data;

	key = irq_lock();

	if (likely(!sys_slist_is_empty(&queue->data_q))) {
500061c4:	02078063          	beqz	a5,500061e4 <k_queue_get+0x3c>
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list)
{
	sys_snode_t *node = list->head;

	list->head = node->next;
500061c8:	0007a683          	lw	a3,0(a5)
	if (list->tail == node) {
500061cc:	00c52603          	lw	a2,12(a0)
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list)
{
	sys_snode_t *node = list->head;

	list->head = node->next;
500061d0:	00d52423          	sw	a3,8(a0)
	if (list->tail == node) {
500061d4:	00c79463          	bne	a5,a2,500061dc <k_queue_get+0x34>
		list->tail = list->head;
500061d8:	00d52623          	sw	a3,12(a0)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500061dc:	30042473          	csrrs	s0,mstatus,s0
		data = sys_slist_get_not_empty(&queue->data_q);
		irq_unlock(key);
		return data;
500061e0:	0340006f          	j	50006214 <k_queue_get+0x6c>
	}

	if (timeout == K_NO_WAIT) {
500061e4:	00059863          	bnez	a1,500061f4 <k_queue_get+0x4c>
500061e8:	30042473          	csrrs	s0,mstatus,s0
		irq_unlock(key);
		return NULL;
500061ec:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500061f0:	0240006f          	j	50006214 <k_queue_get+0x6c>
	}

	_pend_current_thread(&queue->wait_q, timeout);
500061f4:	2a0000ef          	jal	50006494 <_pend_current_thread>

	return _Swap(key) ? NULL : _current->base.swap_data;
500061f8:	00040513          	mv	a0,s0
500061fc:	c45ff0ef          	jal	50005e40 <_Swap>
50006200:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006204:	00051863          	bnez	a0,50006214 <k_queue_get+0x6c>
50006208:	510027b7          	lui	a5,0x51002
5000620c:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
50006210:	00c7a783          	lw	a5,12(a5)
}
50006214:	00c12083          	lw	ra,12(sp)
50006218:	00078513          	mv	a0,a5
5000621c:	00812403          	lw	s0,8(sp)
50006220:	01010113          	addi	sp,sp,16
50006224:	00008067          	ret

50006228 <_add_timeout>:
	__ASSERT(duration_in_ms >= 0, "");
	__ASSERT((prio >= 0) && (prio < CONFIG_NUM_PREEMPT_PRIORITIES), "");

	_time_slice_duration = duration_in_ms;
	_time_slice_elapsed = 0;
	_time_slice_prio_ceiling = prio;
50006228:	51002737          	lui	a4,0x51002
5000622c:	00a5a423          	sw	a0,8(a1)
50006230:	2c070793          	addi	a5,a4,704 # 510022c0 <_kernel>
50006234:	00c5a623          	sw	a2,12(a1)
50006238:	51002537          	lui	a0,0x51002
5000623c:	00c7a783          	lw	a5,12(a5)
50006240:	2cc50513          	addi	a0,a0,716 # 510022cc <_kernel+0xc>
50006244:	00d5a823          	sw	a3,16(a1)
50006248:	2c070713          	addi	a4,a4,704
5000624c:	02a79063          	bne	a5,a0,5000626c <_add_timeout+0x44>
50006250:	00a5a023          	sw	a0,0(a1)
50006254:	01072783          	lw	a5,16(a4)
50006258:	00f5a223          	sw	a5,4(a1)
5000625c:	01072783          	lw	a5,16(a4)
50006260:	00b7a023          	sw	a1,0(a5)
50006264:	00b72823          	sw	a1,16(a4)
50006268:	00008067          	ret
5000626c:	fe0782e3          	beqz	a5,50006250 <_add_timeout+0x28>
50006270:	01072803          	lw	a6,16(a4)
50006274:	0105a683          	lw	a3,16(a1)
50006278:	0107a603          	lw	a2,16(a5)
5000627c:	02d64463          	blt	a2,a3,500062a4 <_add_timeout+0x7c>
50006280:	0047a703          	lw	a4,4(a5)
50006284:	40d606b3          	sub	a3,a2,a3
50006288:	00d7a823          	sw	a3,16(a5)
5000628c:	00e5a223          	sw	a4,4(a1)
50006290:	00f5a023          	sw	a5,0(a1)
50006294:	0047a703          	lw	a4,4(a5)
50006298:	00b72023          	sw	a1,0(a4)
5000629c:	00b7a223          	sw	a1,4(a5)
500062a0:	00008067          	ret
500062a4:	40c686b3          	sub	a3,a3,a2
500062a8:	00d5a823          	sw	a3,16(a1)
500062ac:	fb0782e3          	beq	a5,a6,50006250 <_add_timeout+0x28>
500062b0:	0007a783          	lw	a5,0(a5)
500062b4:	fc0790e3          	bnez	a5,50006274 <_add_timeout+0x4c>
500062b8:	f99ff06f          	j	50006250 <_add_timeout+0x28>

500062bc <_get_ready_q_head>:
500062bc:	51002537          	lui	a0,0x51002
500062c0:	2c050713          	addi	a4,a0,704 # 510022c0 <_kernel>
500062c4:	01872703          	lw	a4,24(a4)
500062c8:	2c050513          	addi	a0,a0,704
500062cc:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500062d0:	00070663          	beqz	a4,500062dc <_get_ready_q_head+0x20>
500062d4:	100707b3          	p.ff1	a5,a4
500062d8:	00178793          	addi	a5,a5,1
500062dc:	00178793          	addi	a5,a5,1
500062e0:	00379793          	slli	a5,a5,0x3
500062e4:	00f50533          	add	a0,a0,a5
500062e8:	00c52503          	lw	a0,12(a0)
500062ec:	00008067          	ret

500062f0 <_add_thread_to_ready_q>:
500062f0:	00a50783          	lb	a5,10(a0)
500062f4:	51002637          	lui	a2,0x51002
500062f8:	01078813          	addi	a6,a5,16
500062fc:	40585713          	srai	a4,a6,0x5
50006300:	00470713          	addi	a4,a4,4
50006304:	2c060693          	addi	a3,a2,704 # 510022c0 <_kernel>
50006308:	00271713          	slli	a4,a4,0x2
5000630c:	00e68733          	add	a4,a3,a4
50006310:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50006314:	01278793          	addi	a5,a5,18
50006318:	010595b3          	sll	a1,a1,a6
5000631c:	00379793          	slli	a5,a5,0x3
50006320:	00872803          	lw	a6,8(a4)
50006324:	00f687b3          	add	a5,a3,a5
50006328:	0105e5b3          	or	a1,a1,a6
5000632c:	00b72423          	sw	a1,8(a4)
50006330:	00c78713          	addi	a4,a5,12
50006334:	00e52023          	sw	a4,0(a0)
50006338:	0107a703          	lw	a4,16(a5)
5000633c:	00e52223          	sw	a4,4(a0)
50006340:	0107a703          	lw	a4,16(a5)
50006344:	00a72023          	sw	a0,0(a4)
50006348:	00a7a823          	sw	a0,16(a5)
5000634c:	0146a783          	lw	a5,20(a3)
50006350:	00a78703          	lb	a4,10(a5)
50006354:	00a50683          	lb	a3,10(a0)
50006358:	2c060613          	addi	a2,a2,704
5000635c:	00e6d463          	ble	a4,a3,50006364 <_add_thread_to_ready_q+0x74>
50006360:	00050793          	mv	a5,a0
50006364:	00f62a23          	sw	a5,20(a2)
50006368:	00008067          	ret

5000636c <_remove_thread_from_ready_q>:
5000636c:	ff010113          	addi	sp,sp,-16
50006370:	00812423          	sw	s0,8(sp)
50006374:	00112623          	sw	ra,12(sp)
50006378:	00052603          	lw	a2,0(a0)
5000637c:	00452683          	lw	a3,4(a0)
50006380:	00a50783          	lb	a5,10(a0)
50006384:	00c6a023          	sw	a2,0(a3)
50006388:	00052603          	lw	a2,0(a0)
5000638c:	51002437          	lui	s0,0x51002
50006390:	01278793          	addi	a5,a5,18
50006394:	00d62223          	sw	a3,4(a2)
50006398:	00379793          	slli	a5,a5,0x3
5000639c:	2c040693          	addi	a3,s0,704 # 510022c0 <_kernel>
500063a0:	00f687b3          	add	a5,a3,a5
500063a4:	00c78693          	addi	a3,a5,12
500063a8:	00c7a783          	lw	a5,12(a5)
500063ac:	00050713          	mv	a4,a0
500063b0:	2c040413          	addi	s0,s0,704
500063b4:	02d79a63          	bne	a5,a3,500063e8 <_remove_thread_from_ready_q+0x7c>
500063b8:	00a50683          	lb	a3,10(a0)
500063bc:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
500063c0:	01068693          	addi	a3,a3,16
500063c4:	4056d793          	srai	a5,a3,0x5
500063c8:	00478793          	addi	a5,a5,4
500063cc:	00279793          	slli	a5,a5,0x2
500063d0:	00f407b3          	add	a5,s0,a5
500063d4:	00d616b3          	sll	a3,a2,a3
500063d8:	fff6c693          	not	a3,a3
500063dc:	0087a603          	lw	a2,8(a5)
500063e0:	00c6f6b3          	and	a3,a3,a2
500063e4:	00d7a423          	sw	a3,8(a5)
500063e8:	01442503          	lw	a0,20(s0)
500063ec:	00a71463          	bne	a4,a0,500063f4 <_remove_thread_from_ready_q+0x88>
500063f0:	ecdff0ef          	jal	500062bc <_get_ready_q_head>
500063f4:	00c12083          	lw	ra,12(sp)
500063f8:	00a42a23          	sw	a0,20(s0)
500063fc:	00812403          	lw	s0,8(sp)
50006400:	01010113          	addi	sp,sp,16
50006404:	00008067          	ret

50006408 <_pend_thread>:
50006408:	0005a783          	lw	a5,0(a1)
5000640c:	04f58063          	beq	a1,a5,5000644c <_pend_thread+0x44>
50006410:	02078e63          	beqz	a5,5000644c <_pend_thread+0x44>
50006414:	00a50683          	lb	a3,10(a0)
50006418:	00a78703          	lb	a4,10(a5)
5000641c:	02e6d063          	ble	a4,a3,5000643c <_pend_thread+0x34>
50006420:	0047a703          	lw	a4,4(a5)
50006424:	00e52223          	sw	a4,4(a0)
50006428:	00f52023          	sw	a5,0(a0)
5000642c:	0047a703          	lw	a4,4(a5)
50006430:	00a72023          	sw	a0,0(a4)
50006434:	00a7a223          	sw	a0,4(a5)
50006438:	02c0006f          	j	50006464 <_pend_thread+0x5c>
5000643c:	0045a703          	lw	a4,4(a1)
50006440:	00e78663          	beq	a5,a4,5000644c <_pend_thread+0x44>
50006444:	0007a783          	lw	a5,0(a5)
50006448:	fc9ff06f          	j	50006410 <_pend_thread+0x8>
5000644c:	00b52023          	sw	a1,0(a0)
50006450:	0045a783          	lw	a5,4(a1)
50006454:	00f52223          	sw	a5,4(a0)
50006458:	0045a783          	lw	a5,4(a1)
5000645c:	00a7a023          	sw	a0,0(a5)
50006460:	00a5a223          	sw	a0,4(a1)
50006464:	00954783          	lbu	a5,9(a0)
50006468:	c017c7b3          	p.bset	a5,a5,0,1
5000646c:	00f504a3          	sb	a5,9(a0)
50006470:	03f62063          	p.beqimm	a2,-1,50006490 <_pend_thread+0x88>
50006474:	00960613          	addi	a2,a2,9
50006478:	00a00693          	li	a3,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
5000647c:	02d656b3          	divu	a3,a2,a3
50006480:	00058613          	mv	a2,a1
50006484:	01050593          	addi	a1,a0,16
50006488:	00168693          	addi	a3,a3,1
5000648c:	d9dff06f          	j	50006228 <_add_timeout>
50006490:	00008067          	ret

50006494 <_pend_current_thread>:
50006494:	ff010113          	addi	sp,sp,-16
50006498:	00812423          	sw	s0,8(sp)
5000649c:	51002437          	lui	s0,0x51002
500064a0:	2c040413          	addi	s0,s0,704 # 510022c0 <_kernel>
500064a4:	00912223          	sw	s1,4(sp)
500064a8:	01212023          	sw	s2,0(sp)
500064ac:	00050493          	mv	s1,a0
500064b0:	00058913          	mv	s2,a1
500064b4:	00842503          	lw	a0,8(s0)
500064b8:	00112623          	sw	ra,12(sp)
500064bc:	eb1ff0ef          	jal	5000636c <_remove_thread_from_ready_q>
500064c0:	00090613          	mv	a2,s2
500064c4:	00012903          	lw	s2,0(sp)
500064c8:	00048593          	mv	a1,s1
500064cc:	00842503          	lw	a0,8(s0)
500064d0:	00c12083          	lw	ra,12(sp)
500064d4:	00812403          	lw	s0,8(sp)
500064d8:	00412483          	lw	s1,4(sp)
500064dc:	01010113          	addi	sp,sp,16
500064e0:	f29ff06f          	j	50006408 <_pend_thread>

500064e4 <__must_switch_threads>:
500064e4:	510027b7          	lui	a5,0x51002
500064e8:	2c078713          	addi	a4,a5,704 # 510022c0 <_kernel>
500064ec:	01872703          	lw	a4,24(a4)
500064f0:	2c078793          	addi	a5,a5,704
500064f4:	00000693          	li	a3,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500064f8:	00070663          	beqz	a4,50006504 <__must_switch_threads+0x20>
500064fc:	10070733          	p.ff1	a4,a4
50006500:	00170693          	addi	a3,a4,1
50006504:	0087a783          	lw	a5,8(a5)
50006508:	00a78503          	lb	a0,10(a5)
5000650c:	fef68713          	addi	a4,a3,-17
50006510:	00a72533          	slt	a0,a4,a0
50006514:	00008067          	ret

50006518 <_reschedule_threads>:
50006518:	510027b7          	lui	a5,0x51002
5000651c:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
50006520:	ff010113          	addi	sp,sp,-16
50006524:	00a7d703          	lhu	a4,10(a5)
50006528:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
5000652c:	00812423          	sw	s0,8(sp)
50006530:	00112623          	sw	ra,12(sp)
50006534:	00050413          	mv	s0,a0
50006538:	00e7e663          	bltu	a5,a4,50006544 <_reschedule_threads+0x2c>
5000653c:	fa9ff0ef          	jal	500064e4 <__must_switch_threads>
50006540:	00051e63          	bnez	a0,5000655c <_reschedule_threads+0x44>
50006544:	fc143433          	p.bclr	s0,s0,30,1
50006548:	30042473          	csrrs	s0,mstatus,s0
5000654c:	00c12083          	lw	ra,12(sp)
50006550:	00812403          	lw	s0,8(sp)
50006554:	01010113          	addi	sp,sp,16
50006558:	00008067          	ret
5000655c:	510027b7          	lui	a5,0x51002
50006560:	00040513          	mv	a0,s0
50006564:	00c12083          	lw	ra,12(sp)
50006568:	00812403          	lw	s0,8(sp)
5000656c:	01010113          	addi	sp,sp,16
50006570:	3e07a623          	sw	zero,1004(a5) # 510023ec <_time_slice_elapsed>
50006574:	dedf906f          	j	50000360 <__swap>

50006578 <k_sched_unlock>:
50006578:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
5000657c:	30053573          	csrrc	a0,mstatus,a0
50006580:	510027b7          	lui	a5,0x51002
50006584:	2c87a703          	lw	a4,712(a5) # 510022c8 <_kernel+0x8>
50006588:	fc153533          	p.bclr	a0,a0,30,1
5000658c:	00b74783          	lbu	a5,11(a4)
50006590:	00178793          	addi	a5,a5,1
50006594:	00f705a3          	sb	a5,11(a4)
50006598:	f81ff06f          	j	50006518 <_reschedule_threads>

5000659c <_move_thread_to_end_of_prio_q>:
5000659c:	ff010113          	addi	sp,sp,-16
500065a0:	00812423          	sw	s0,8(sp)
500065a4:	00112623          	sw	ra,12(sp)
500065a8:	00a50703          	lb	a4,10(a0)
500065ac:	51002437          	lui	s0,0x51002
500065b0:	01270713          	addi	a4,a4,18
500065b4:	2c040693          	addi	a3,s0,704 # 510022c0 <_kernel>
500065b8:	00371713          	slli	a4,a4,0x3
500065bc:	00e68733          	add	a4,a3,a4
500065c0:	01072603          	lw	a2,16(a4)
500065c4:	04c50663          	beq	a0,a2,50006610 <_move_thread_to_end_of_prio_q+0x74>
500065c8:	00052583          	lw	a1,0(a0)
500065cc:	00452603          	lw	a2,4(a0)
500065d0:	00b62023          	sw	a1,0(a2)
500065d4:	00052583          	lw	a1,0(a0)
500065d8:	00c70693          	addi	a3,a4,12
500065dc:	00c5a223          	sw	a2,4(a1)
500065e0:	00d52023          	sw	a3,0(a0)
500065e4:	01072683          	lw	a3,16(a4)
500065e8:	00d52223          	sw	a3,4(a0)
500065ec:	01072683          	lw	a3,16(a4)
500065f0:	00a6a023          	sw	a0,0(a3)
500065f4:	2c040413          	addi	s0,s0,704
500065f8:	00050793          	mv	a5,a0
500065fc:	00a72823          	sw	a0,16(a4)
50006600:	01442503          	lw	a0,20(s0)
50006604:	00a79463          	bne	a5,a0,5000660c <_move_thread_to_end_of_prio_q+0x70>
50006608:	cb5ff0ef          	jal	500062bc <_get_ready_q_head>
5000660c:	00a42a23          	sw	a0,20(s0)
50006610:	00c12083          	lw	ra,12(sp)
50006614:	00812403          	lw	s0,8(sp)
50006618:	01010113          	addi	sp,sp,16
5000661c:	00008067          	ret

50006620 <k_yield>:
50006620:	ff010113          	addi	sp,sp,-16
50006624:	00812423          	sw	s0,8(sp)
50006628:	00112623          	sw	ra,12(sp)
5000662c:	00912223          	sw	s1,4(sp)
50006630:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50006634:	30043473          	csrrc	s0,mstatus,s0
50006638:	510024b7          	lui	s1,0x51002
5000663c:	2c048493          	addi	s1,s1,704 # 510022c0 <_kernel>
50006640:	0084a503          	lw	a0,8(s1)
50006644:	f59ff0ef          	jal	5000659c <_move_thread_to_end_of_prio_q>
50006648:	0084a783          	lw	a5,8(s1)
5000664c:	0144a483          	lw	s1,20(s1)
50006650:	fc143433          	p.bclr	s0,s0,30,1
50006654:	00979e63          	bne	a5,s1,50006670 <k_yield+0x50>
50006658:	30042473          	csrrs	s0,mstatus,s0
5000665c:	00c12083          	lw	ra,12(sp)
50006660:	00812403          	lw	s0,8(sp)
50006664:	00412483          	lw	s1,4(sp)
50006668:	01010113          	addi	sp,sp,16
5000666c:	00008067          	ret
50006670:	510027b7          	lui	a5,0x51002
50006674:	00040513          	mv	a0,s0
50006678:	00c12083          	lw	ra,12(sp)
5000667c:	00812403          	lw	s0,8(sp)
50006680:	00412483          	lw	s1,4(sp)
50006684:	01010113          	addi	sp,sp,16
50006688:	3e07a623          	sw	zero,1004(a5) # 510023ec <_time_slice_elapsed>
5000668c:	cd5f906f          	j	50000360 <__swap>

50006690 <k_current_get>:
50006690:	510027b7          	lui	a5,0x51002
50006694:	2c87a503          	lw	a0,712(a5) # 510022c8 <_kernel+0x8>
50006698:	00008067          	ret

5000669c <_is_thread_time_slicing>:
	 * Should not be the idle thread
	 * Priority should be higher than time slice priority ceiling
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
5000669c:	51002737          	lui	a4,0x51002
500066a0:	d3072703          	lw	a4,-720(a4) # 51001d30 <_time_slice_duration>
	_time_slice_elapsed = 0;
	_time_slice_prio_ceiling = prio;
}

int _is_thread_time_slicing(struct k_thread *thread)
{
500066a4:	00050793          	mv	a5,a0
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
	    || _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
		return 0;
500066a8:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
	 * Should not be the idle thread
	 * Priority should be higher than time slice priority ceiling
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
500066ac:	04e05463          	blez	a4,500066f4 <_is_thread_time_slicing+0x58>
500066b0:	51002737          	lui	a4,0x51002
500066b4:	cf072703          	lw	a4,-784(a4) # 51001cf0 <_idle_thread>
500066b8:	02e78e63          	beq	a5,a4,500066f4 <_is_thread_time_slicing+0x58>
	    || _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
500066bc:	51002737          	lui	a4,0x51002
500066c0:	00a78783          	lb	a5,10(a5)
500066c4:	d2c72703          	lw	a4,-724(a4) # 51001d2c <_time_slice_prio_ceiling>
500066c8:	02e7c663          	blt	a5,a4,500066f4 <_is_thread_time_slicing+0x58>
 * @return 1 if multiple nodes, 0 otherwise
 */

static inline int sys_dlist_has_multiple_nodes(sys_dlist_t *list)
{
	return list->head != list->tail;
500066cc:	01278513          	addi	a0,a5,18
500066d0:	510027b7          	lui	a5,0x51002
500066d4:	2c078793          	addi	a5,a5,704 # 510022c0 <_kernel>
500066d8:	00351513          	slli	a0,a0,0x3
500066dc:	00a78533          	add	a0,a5,a0
500066e0:	00c52783          	lw	a5,12(a0)
500066e4:	01052503          	lw	a0,16(a0)
500066e8:	40a78533          	sub	a0,a5,a0
500066ec:	00a03533          	snez	a0,a0
	}

	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];

	return sys_dlist_has_multiple_nodes(q);
500066f0:	00008067          	ret
}
500066f4:	00008067          	ret

500066f8 <_update_time_slice_before_swap>:
	if (!remaining || (_time_slice_duration < remaining)) {
		_set_time(_time_slice_duration);
	}
#endif
	/* Restart time slice count at new thread switch */
	_time_slice_elapsed = 0;
500066f8:	510027b7          	lui	a5,0x51002
500066fc:	3e07a623          	sw	zero,1004(a5) # 510023ec <_time_slice_elapsed>
50006700:	00008067          	ret

50006704 <_ready_thread>:

	_abort_thread_timeout(thread);

	_ready_thread(thread);
	_set_thread_return_value(thread, 0);
}
50006704:	00954703          	lbu	a4,9(a0)
50006708:	c02736b3          	p.bclr	a3,a4,0,2
5000670c:	01b77713          	andi	a4,a4,27
50006710:	00d504a3          	sb	a3,9(a0)
50006714:	00071863          	bnez	a4,50006724 <_ready_thread+0x20>
50006718:	02052783          	lw	a5,32(a0)
5000671c:	01f7b463          	p.bneimm	a5,-1,50006724 <_ready_thread+0x20>
50006720:	bd1ff06f          	j	500062f0 <_add_thread_to_ready_q>
50006724:	00008067          	ret

50006728 <_unpend_first_thread>:
50006728:	510027b7          	lui	a5,0x51002
5000672c:	3e87a783          	lw	a5,1000(a5) # 510023e8 <_handling_timeouts>
50006730:	00052703          	lw	a4,0(a0)
50006734:	02078463          	beqz	a5,5000675c <_unpend_first_thread+0x34>
50006738:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
5000673c:	04e50c63          	beq	a0,a4,50006794 <_unpend_first_thread+0x6c>
50006740:	04070863          	beqz	a4,50006790 <_unpend_first_thread+0x68>
50006744:	02072783          	lw	a5,32(a4)
50006748:	03e7b063          	p.bneimm	a5,-2,50006768 <_unpend_first_thread+0x40>
5000674c:	00452783          	lw	a5,4(a0)
50006750:	04e78063          	beq	a5,a4,50006790 <_unpend_first_thread+0x68>
50006754:	00072703          	lw	a4,0(a4)
50006758:	fe9ff06f          	j	50006740 <_unpend_first_thread+0x18>
5000675c:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006760:	02e50a63          	beq	a0,a4,50006794 <_unpend_first_thread+0x6c>
50006764:	02070863          	beqz	a4,50006794 <_unpend_first_thread+0x6c>
50006768:	00070793          	mv	a5,a4
5000676c:	0007a683          	lw	a3,0(a5)
50006770:	00472703          	lw	a4,4(a4)
50006774:	00d72023          	sw	a3,0(a4)
50006778:	0007a683          	lw	a3,0(a5)
5000677c:	00e6a223          	sw	a4,4(a3)
50006780:	0097c703          	lbu	a4,9(a5)
50006784:	c0173733          	p.bclr	a4,a4,0,1
50006788:	00e784a3          	sb	a4,9(a5)
5000678c:	0080006f          	j	50006794 <_unpend_first_thread+0x6c>
50006790:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006794:	00078513          	mv	a0,a5
50006798:	00008067          	ret

5000679c <_abort_timeout>:
5000679c:	00050793          	mv	a5,a0
500067a0:	01052503          	lw	a0,16(a0)
500067a4:	05f52063          	p.beqimm	a0,-1,500067e4 <_abort_timeout+0x48>
500067a8:	51002737          	lui	a4,0x51002
500067ac:	2d072703          	lw	a4,720(a4) # 510022d0 <_kernel+0x10>
500067b0:	00e78a63          	beq	a5,a4,500067c4 <_abort_timeout+0x28>
500067b4:	0007a683          	lw	a3,0(a5)
500067b8:	0106a703          	lw	a4,16(a3)
500067bc:	00a70533          	add	a0,a4,a0
500067c0:	00a6a823          	sw	a0,16(a3)
500067c4:	0007a683          	lw	a3,0(a5)
500067c8:	0047a703          	lw	a4,4(a5)
500067cc:	00d72023          	sw	a3,0(a4)
500067d0:	0007a683          	lw	a3,0(a5)
500067d4:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
500067d8:	00e6a223          	sw	a4,4(a3)
500067dc:	fff00713          	li	a4,-1
500067e0:	00e7a823          	sw	a4,16(a5)
500067e4:	00008067          	ret

500067e8 <k_sem_init>:
500067e8:	00b52423          	sw	a1,8(a0)
500067ec:	00c52623          	sw	a2,12(a0)
500067f0:	00a52023          	sw	a0,0(a0)
500067f4:	00a52223          	sw	a0,4(a0)
500067f8:	00052823          	sw	zero,16(a0)
500067fc:	00008067          	ret

50006800 <k_sem_give>:

void k_sem_give(struct k_sem *sem)
{
50006800:	ff010113          	addi	sp,sp,-16
50006804:	00812423          	sw	s0,8(sp)
50006808:	00912223          	sw	s1,4(sp)
5000680c:	00112623          	sw	ra,12(sp)
50006810:	01212023          	sw	s2,0(sp)
50006814:	00050493          	mv	s1,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006818:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
5000681c:	30043473          	csrrc	s0,mstatus,s0
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50006820:	fc143433          	p.bclr	s0,s0,30,1
}

/* returns 1 if _Swap() will need to be invoked, 0 otherwise */
static int do_sem_give(struct k_sem *sem)
{
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
50006824:	f05ff0ef          	jal	50006728 <_unpend_first_thread>

	if (!thread) {
50006828:	04051a63          	bnez	a0,5000687c <k_sem_give+0x7c>
#endif
}

static inline void increment_count_up_to_limit(struct k_sem *sem)
{
	sem->count += (sem->count != sem->limit);
5000682c:	0084a703          	lw	a4,8(s1)
50006830:	00c4a783          	lw	a5,12(s1)
50006834:	40e787b3          	sub	a5,a5,a4
50006838:	00f037b3          	snez	a5,a5
5000683c:	00e787b3          	add	a5,a5,a4
50006840:	00f4a423          	sw	a5,8(s1)
{
#ifdef CONFIG_POLL
	u32_t state = K_POLL_STATE_SEM_AVAILABLE;

	return sem->poll_event ?
	       _handle_obj_poll_event(&sem->poll_event, state) : 0;
50006844:	0104a783          	lw	a5,16(s1)
50006848:	06078a63          	beqz	a5,500068bc <k_sem_give+0xbc>
5000684c:	00400593          	li	a1,4 # 4 <__NANO_ESF_gp_OFFSET>
50006850:	01048513          	addi	a0,s1,16
50006854:	d80ff0ef          	jal	50005dd4 <_handle_obj_poll_event>
{
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
50006858:	06050263          	beqz	a0,500068bc <k_sem_give+0xbc>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
5000685c:	e9dff0ef          	jal	500066f8 <_update_time_slice_before_swap>
		_Swap(key);
	} else {
		irq_unlock(key);
	}
}
50006860:	00012903          	lw	s2,0(sp)
#endif

	return __swap(key);
50006864:	00040513          	mv	a0,s0
50006868:	00c12083          	lw	ra,12(sp)
5000686c:	00812403          	lw	s0,8(sp)
50006870:	00412483          	lw	s1,4(sp)
50006874:	01010113          	addi	sp,sp,16
50006878:	ae9f906f          	j	50000360 <__swap>
5000687c:	00050913          	mv	s2,a0
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
50006880:	01050513          	addi	a0,a0,16
50006884:	f19ff0ef          	jal	5000679c <_abort_timeout>
	if (!thread) {
		increment_count_up_to_limit(sem);
		return handle_poll_event(sem);
	}
	(void)_abort_thread_timeout(thread);
	_ready_thread(thread);
50006888:	00090513          	mv	a0,s2
5000688c:	e79ff0ef          	jal	50006704 <_ready_thread>
	_set_thread_return_value(thread, 0);

	return !_is_in_isr() && _must_switch_threads();
50006890:	510027b7          	lui	a5,0x51002
50006894:	2c07a703          	lw	a4,704(a5) # 510022c0 <_kernel>
}

static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
50006898:	06092423          	sw	zero,104(s2)
5000689c:	02071063          	bnez	a4,500068bc <k_sem_give+0xbc>
500068a0:	2c078793          	addi	a5,a5,704
500068a4:	0087a783          	lw	a5,8(a5)
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
500068a8:	00a7d703          	lhu	a4,10(a5)
500068ac:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
500068b0:	00e7e663          	bltu	a5,a4,500068bc <k_sem_give+0xbc>
500068b4:	c31ff0ef          	jal	500064e4 <__must_switch_threads>
500068b8:	fa1ff06f          	j	50006858 <k_sem_give+0x58>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500068bc:	30042473          	csrrs	s0,mstatus,s0
	if (do_sem_give(sem)) {
		_Swap(key);
	} else {
		irq_unlock(key);
	}
}
500068c0:	00c12083          	lw	ra,12(sp)
500068c4:	00812403          	lw	s0,8(sp)
500068c8:	00412483          	lw	s1,4(sp)
500068cc:	00012903          	lw	s2,0(sp)
500068d0:	01010113          	addi	sp,sp,16
500068d4:	00008067          	ret

500068d8 <k_sem_take>:

int k_sem_take(struct k_sem *sem, s32_t timeout)
{
500068d8:	ff010113          	addi	sp,sp,-16
500068dc:	00812423          	sw	s0,8(sp)
500068e0:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500068e4:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500068e8:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
500068ec:	00852783          	lw	a5,8(a0)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
500068f0:	fc143433          	p.bclr	s0,s0,30,1
500068f4:	00078c63          	beqz	a5,5000690c <k_sem_take+0x34>
		sem->count--;
500068f8:	fff78793          	addi	a5,a5,-1
500068fc:	00f52423          	sw	a5,8(a0)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006900:	30042473          	csrrs	s0,mstatus,s0
		irq_unlock(key);
		return 0;
50006904:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006908:	0300006f          	j	50006938 <k_sem_take+0x60>
	}

	if (timeout == K_NO_WAIT) {
5000690c:	00059863          	bnez	a1,5000691c <k_sem_take+0x44>
50006910:	30042473          	csrrs	s0,mstatus,s0
		irq_unlock(key);
		return -EBUSY;
50006914:	ff000513          	li	a0,-16 # fffffff0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff1>
50006918:	0200006f          	j	50006938 <k_sem_take+0x60>
	}

	_pend_current_thread(&sem->wait_q, timeout);
5000691c:	b79ff0ef          	jal	50006494 <_pend_current_thread>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
50006920:	dd9ff0ef          	jal	500066f8 <_update_time_slice_before_swap>
#endif

	return __swap(key);
50006924:	00040513          	mv	a0,s0

	return _Swap(key);
}
50006928:	00c12083          	lw	ra,12(sp)
5000692c:	00812403          	lw	s0,8(sp)
50006930:	01010113          	addi	sp,sp,16
50006934:	a2df906f          	j	50000360 <__swap>
50006938:	00c12083          	lw	ra,12(sp)
5000693c:	00812403          	lw	s0,8(sp)
50006940:	01010113          	addi	sp,sp,16
50006944:	00008067          	ret

50006948 <_tick_get>:
}

u32_t k_uptime_delta_32(s64_t *reftime)
{
	return (u32_t)k_uptime_delta(reftime);
}
50006948:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
5000694c:	3007b7f3          	csrrc	a5,mstatus,a5
50006950:	51002737          	lui	a4,0x51002
50006954:	3f072503          	lw	a0,1008(a4) # 510023f0 <_sys_clock_tick_count>
50006958:	fc17b7b3          	p.bclr	a5,a5,30,1
5000695c:	3f472583          	lw	a1,1012(a4)
50006960:	3007a7f3          	csrrs	a5,mstatus,a5
50006964:	00008067          	ret

50006968 <k_uptime_get>:
50006968:	ff010113          	addi	sp,sp,-16
5000696c:	00112623          	sw	ra,12(sp)
50006970:	fd9ff0ef          	jal	50006948 <_tick_get>
50006974:	00a00793          	li	a5,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50006978:	02f53733          	mulhu	a4,a0,a5
5000697c:	00c12083          	lw	ra,12(sp)
50006980:	01010113          	addi	sp,sp,16
50006984:	42f58733          	p.mac	a4,a1,a5
50006988:	00070593          	mv	a1,a4
5000698c:	02f50533          	mul	a0,a0,a5
50006990:	00008067          	ret

50006994 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(s32_t ticks)
{
50006994:	fd010113          	addi	sp,sp,-48
50006998:	01612823          	sw	s6,16(sp)
5000699c:	02112623          	sw	ra,44(sp)
500069a0:	02812423          	sw	s0,40(sp)
500069a4:	02912223          	sw	s1,36(sp)
500069a8:	03212023          	sw	s2,32(sp)
500069ac:	01312e23          	sw	s3,28(sp)
500069b0:	01412c23          	sw	s4,24(sp)
500069b4:	01512a23          	sw	s5,20(sp)
500069b8:	00050b13          	mv	s6,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500069bc:	00100693          	li	a3,1 # 1 <CONFIG_ARCH>
500069c0:	3006b7f3          	csrrc	a5,mstatus,a3

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
500069c4:	51002637          	lui	a2,0x51002
500069c8:	3f062503          	lw	a0,1008(a2) # 510023f0 <_sys_clock_tick_count>
500069cc:	3f462583          	lw	a1,1012(a2)
500069d0:	00ab0833          	add	a6,s6,a0
500069d4:	41fb5713          	srai	a4,s6,0x1f
500069d8:	016838b3          	sltu	a7,a6,s6
500069dc:	00b70733          	add	a4,a4,a1
500069e0:	00e885b3          	add	a1,a7,a4
500069e4:	3f062823          	sw	a6,1008(a2)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500069e8:	fc17b7b3          	p.bclr	a5,a5,30,1
500069ec:	3eb62a23          	sw	a1,1012(a2)
500069f0:	3007a7f3          	csrrs	a5,mstatus,a5
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
500069f4:	00810613          	addi	a2,sp,8
500069f8:	00c12423          	sw	a2,8(sp)
	list->tail = (sys_dnode_t *)list;
500069fc:	00c12623          	sw	a2,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006a00:	3006b773          	csrrc	a4,mstatus,a3
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
50006a04:	510024b7          	lui	s1,0x51002
50006a08:	2c048793          	addi	a5,s1,704 # 510022c0 <_kernel>
50006a0c:	510025b7          	lui	a1,0x51002
50006a10:	00c7a783          	lw	a5,12(a5)
50006a14:	2cc58593          	addi	a1,a1,716 # 510022cc <_kernel+0xc>
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50006a18:	fc173733          	p.bclr	a4,a4,30,1
50006a1c:	2c048493          	addi	s1,s1,704
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50006a20:	00b78463          	beq	a5,a1,50006a28 <_nano_sys_clock_tick_announce+0x94>
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
50006a24:	00079663          	bnez	a5,50006a30 <_nano_sys_clock_tick_announce+0x9c>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006a28:	30072773          	csrrs	a4,mstatus,a4
50006a2c:	14c0006f          	j	50006b78 <_nano_sys_clock_tick_announce+0x1e4>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
50006a30:	0107a503          	lw	a0,16(a5)
50006a34:	41650533          	sub	a0,a0,s6
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
50006a38:	510029b7          	lui	s3,0x51002
	if (!head) {
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
50006a3c:	00a7a823          	sw	a0,16(a5)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
50006a40:	3ed9a423          	sw	a3,1000(s3) # 510023e8 <_handling_timeouts>
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
50006a44:	ffe00813          	li	a6,-2 # fffffffe <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffff>
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
50006a48:	0107a503          	lw	a0,16(a5)
50006a4c:	04051663          	bnez	a0,50006a98 <_nano_sys_clock_tick_announce+0x104>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50006a50:	0007a883          	lw	a7,0(a5)
50006a54:	0047a503          	lw	a0,4(a5)
50006a58:	01152023          	sw	a7,0(a0)
	node->next->prev = node->prev;
50006a5c:	0007a883          	lw	a7,0(a5)
50006a60:	00a8a223          	sw	a0,4(a7)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
50006a64:	00812503          	lw	a0,8(sp)
50006a68:	00a7a023          	sw	a0,0(a5)
	node->prev = list;

	list->head->prev = node;
50006a6c:	00812503          	lw	a0,8(sp)
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
	node->prev = list;
50006a70:	00c7a223          	sw	a2,4(a5)

	list->head->prev = node;
	list->head = node;
50006a74:	00f12423          	sw	a5,8(sp)
static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
	node->prev = list;

	list->head->prev = node;
50006a78:	00f52223          	sw	a5,4(a0)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
50006a7c:	0107a823          	sw	a6,16(a5)
50006a80:	30072773          	csrrs	a4,mstatus,a4
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006a84:	3006b773          	csrrc	a4,mstatus,a3
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
50006a88:	00c4a783          	lw	a5,12(s1)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50006a8c:	fc173733          	p.bclr	a4,a4,30,1
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50006a90:	00b78463          	beq	a5,a1,50006a98 <_nano_sys_clock_tick_announce+0x104>
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
50006a94:	fa079ae3          	bnez	a5,50006a48 <_nano_sys_clock_tick_announce+0xb4>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006a98:	30072773          	csrrs	a4,mstatus,a4
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
50006a9c:	00812503          	lw	a0,8(sp)
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50006aa0:	00810793          	addi	a5,sp,8
50006aa4:	00f51663          	bne	a0,a5,50006ab0 <_nano_sys_clock_tick_announce+0x11c>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
50006aa8:	3e09a423          	sw	zero,1000(s3)
50006aac:	0cc0006f          	j	50006b78 <_nano_sys_clock_tick_announce+0x1e4>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
50006ab0:	fe050ce3          	beqz	a0,50006aa8 <_nano_sys_clock_tick_announce+0x114>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
50006ab4:	00c12783          	lw	a5,12(sp)
50006ab8:	00000413          	li	s0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006abc:	00f50463          	beq	a0,a5,50006ac4 <_nano_sys_clock_tick_announce+0x130>
50006ac0:	00052403          	lw	s0,0(a0)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006ac4:	00100a13          	li	s4,1 # 1 <CONFIG_ARCH>
static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
50006ac8:	fff00a93          	li	s5,-1
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50006acc:	00052703          	lw	a4,0(a0)
50006ad0:	00452783          	lw	a5,4(a0)
50006ad4:	00e7a023          	sw	a4,0(a5)
	node->next->prev = node->prev;
50006ad8:	00052703          	lw	a4,0(a0)
50006adc:	00f72223          	sw	a5,4(a4)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
50006ae0:	00852703          	lw	a4,8(a0)
50006ae4:	300a3973          	csrrc	s2,mstatus,s4
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50006ae8:	fc193933          	p.bclr	s2,s2,30,1
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
50006aec:	01552823          	sw	s5,16(a0)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
50006af0:	04070a63          	beqz	a4,50006b44 <_nano_sys_clock_tick_announce+0x1b0>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
50006af4:	00c52783          	lw	a5,12(a0)
50006af8:	02078463          	beqz	a5,50006b20 <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50006afc:	00072683          	lw	a3,0(a4)
50006b00:	00472783          	lw	a5,4(a4)
50006b04:	00d7a023          	sw	a3,0(a5)
	node->next->prev = node->prev;
50006b08:	00072683          	lw	a3,0(a4)
50006b0c:	00f6a223          	sw	a5,4(a3)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
50006b10:	00974783          	lbu	a5,9(a4)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
50006b14:	00072e23          	sw	zero,28(a4)
50006b18:	c017b7b3          	p.bclr	a5,a5,0,1
50006b1c:	00f704a3          	sb	a5,9(a4)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
50006b20:	00974783          	lbu	a5,9(a4)
50006b24:	c027b6b3          	p.bclr	a3,a5,0,2
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
50006b28:	01b7f793          	andi	a5,a5,27
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
50006b2c:	00d704a3          	sb	a3,9(a4)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
50006b30:	00079663          	bnez	a5,50006b3c <_nano_sys_clock_tick_announce+0x1a8>
50006b34:	02072783          	lw	a5,32(a4)
50006b38:	09f7a663          	p.beqimm	a5,-1,50006bc4 <_nano_sys_clock_tick_announce+0x230>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006b3c:	30092973          	csrrs	s2,mstatus,s2
50006b40:	0140006f          	j	50006b54 <_nano_sys_clock_tick_announce+0x1c0>
50006b44:	30092973          	csrrs	s2,mstatus,s2
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
50006b48:	01452783          	lw	a5,20(a0)
50006b4c:	00078463          	beqz	a5,50006b54 <_nano_sys_clock_tick_announce+0x1c0>
			timeout->func(timeout);
50006b50:	000780e7          	jalr	a5
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
50006b54:	f4040ae3          	beqz	s0,50006aa8 <_nano_sys_clock_tick_announce+0x114>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
50006b58:	00c12503          	lw	a0,12(sp)
50006b5c:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006b60:	00a41863          	bne	s0,a0,50006b70 <_nano_sys_clock_tick_announce+0x1dc>
50006b64:	00040513          	mv	a0,s0
50006b68:	00078413          	mv	s0,a5
50006b6c:	f61ff06f          	j	50006acc <_nano_sys_clock_tick_announce+0x138>
50006b70:	00042783          	lw	a5,0(s0)
50006b74:	ff1ff06f          	j	50006b64 <_nano_sys_clock_tick_announce+0x1d0>
static void handle_time_slicing(s32_t ticks)
{
#ifdef CONFIG_TICKLESS_KERNEL
	next_ts = 0;
#endif
	if (!_is_thread_time_slicing(_current)) {
50006b78:	0084a503          	lw	a0,8(s1)
50006b7c:	b21ff0ef          	jal	5000669c <_is_thread_time_slicing>
50006b80:	04050863          	beqz	a0,50006bd0 <_nano_sys_clock_tick_announce+0x23c>
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
50006b84:	51002737          	lui	a4,0x51002
50006b88:	3ec72783          	lw	a5,1004(a4) # 510023ec <_time_slice_elapsed>
50006b8c:	00a00693          	li	a3,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50006b90:	42db07b3          	p.mac	a5,s6,a3
	if (_time_slice_elapsed >= _time_slice_duration) {
50006b94:	510026b7          	lui	a3,0x51002
50006b98:	d306a683          	lw	a3,-720(a3) # 51001d30 <_time_slice_duration>
#endif
	if (!_is_thread_time_slicing(_current)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
50006b9c:	3ef72623          	sw	a5,1004(a4)
	if (_time_slice_elapsed >= _time_slice_duration) {
50006ba0:	02d7c863          	blt	a5,a3,50006bd0 <_nano_sys_clock_tick_announce+0x23c>

		unsigned int key;

		_time_slice_elapsed = 0;
50006ba4:	3e072623          	sw	zero,1004(a4)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006ba8:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50006bac:	30043473          	csrrc	s0,mstatus,s0

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
50006bb0:	0084a503          	lw	a0,8(s1)
50006bb4:	9e9ff0ef          	jal	5000659c <_move_thread_to_end_of_prio_q>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006bb8:	fc143433          	p.bclr	s0,s0,30,1
50006bbc:	30042473          	csrrs	s0,mstatus,s0
	if ((!remaining && next_to) || (next_to < remaining)) {
		/* Clears current program if next_to = 0 and remaining > 0 */
		_set_time(next_to);
	}
#endif
}
50006bc0:	0100006f          	j	50006bd0 <_nano_sys_clock_tick_announce+0x23c>

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
50006bc4:	00070513          	mv	a0,a4
50006bc8:	f28ff0ef          	jal	500062f0 <_add_thread_to_ready_q>
50006bcc:	f71ff06f          	j	50006b3c <_nano_sys_clock_tick_announce+0x1a8>
50006bd0:	02c12083          	lw	ra,44(sp)
50006bd4:	02812403          	lw	s0,40(sp)
50006bd8:	02412483          	lw	s1,36(sp)
50006bdc:	02012903          	lw	s2,32(sp)
50006be0:	01c12983          	lw	s3,28(sp)
50006be4:	01812a03          	lw	s4,24(sp)
50006be8:	01412a83          	lw	s5,20(sp)
50006bec:	01012b03          	lw	s6,16(sp)
50006bf0:	03010113          	addi	sp,sp,48
50006bf4:	00008067          	ret

50006bf8 <k_sys_work_q_init>:

static int k_sys_work_q_init(struct device *dev)
{
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
50006bf8:	510045b7          	lui	a1,0x51004
50006bfc:	51002537          	lui	a0,0x51002
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
50006c00:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
50006c04:	3f850513          	addi	a0,a0,1016 # 510023f8 <k_sys_work_q>
50006c08:	fff00693          	li	a3,-1
50006c0c:	40000613          	li	a2,1024 # 400 <CONFIG_BLUETOOTH_RX_STACK_SIZE>
50006c10:	bd058593          	addi	a1,a1,-1072 # 51003bd0 <sys_work_q_stack>
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
50006c14:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
50006c18:	4cc000ef          	jal	500070e4 <k_work_q_start>
		       sys_work_q_stack,
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);

	return 0;
}
50006c1c:	00c12083          	lw	ra,12(sp)
50006c20:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006c24:	01010113          	addi	sp,sp,16
50006c28:	00008067          	ret

50006c2c <_is_thread_ready>:
{
	unsigned int  key = irq_lock();

	_k_thread_single_resume(thread);

	_reschedule_threads(key);
50006c2c:	00954783          	lbu	a5,9(a0)
50006c30:	f457b7b3          	p.bclr	a5,a5,26,5
50006c34:	00079a63          	bnez	a5,50006c48 <_is_thread_ready+0x1c>
50006c38:	02052503          	lw	a0,32(a0)
50006c3c:	00150513          	addi	a0,a0,1
50006c40:	00153513          	seqz	a0,a0
50006c44:	00008067          	ret
50006c48:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006c4c:	00008067          	ret

50006c50 <start_thread>:
50006c50:	ff010113          	addi	sp,sp,-16
50006c54:	00812423          	sw	s0,8(sp)
50006c58:	00912223          	sw	s1,4(sp)
50006c5c:	00112623          	sw	ra,12(sp)
50006c60:	00050493          	mv	s1,a0
50006c64:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50006c68:	30043473          	csrrc	s0,mstatus,s0
50006c6c:	00954783          	lbu	a5,9(a0)
50006c70:	fc143433          	p.bclr	s0,s0,30,1
50006c74:	c027b7b3          	p.bclr	a5,a5,0,2
50006c78:	00f504a3          	sb	a5,9(a0)
50006c7c:	fb1ff0ef          	jal	50006c2c <_is_thread_ready>
50006c80:	04050263          	beqz	a0,50006cc4 <start_thread+0x74>
50006c84:	00048513          	mv	a0,s1
50006c88:	e68ff0ef          	jal	500062f0 <_add_thread_to_ready_q>
50006c8c:	510027b7          	lui	a5,0x51002
50006c90:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
50006c94:	00a7d703          	lhu	a4,10(a5)
50006c98:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
50006c9c:	02e7e463          	bltu	a5,a4,50006cc4 <start_thread+0x74>
50006ca0:	845ff0ef          	jal	500064e4 <__must_switch_threads>
50006ca4:	02050063          	beqz	a0,50006cc4 <start_thread+0x74>
50006ca8:	a51ff0ef          	jal	500066f8 <_update_time_slice_before_swap>
50006cac:	00040513          	mv	a0,s0
50006cb0:	00c12083          	lw	ra,12(sp)
50006cb4:	00812403          	lw	s0,8(sp)
50006cb8:	00412483          	lw	s1,4(sp)
50006cbc:	01010113          	addi	sp,sp,16
50006cc0:	ea0f906f          	j	50000360 <__swap>
50006cc4:	30042473          	csrrs	s0,mstatus,s0
50006cc8:	00c12083          	lw	ra,12(sp)
50006ccc:	00812403          	lw	s0,8(sp)
50006cd0:	00412483          	lw	s1,4(sp)
50006cd4:	01010113          	addi	sp,sp,16
50006cd8:	00008067          	ret

50006cdc <_abort_timeout>:
50006cdc:	00050793          	mv	a5,a0
50006ce0:	01052503          	lw	a0,16(a0)
50006ce4:	05f52063          	p.beqimm	a0,-1,50006d24 <_abort_timeout+0x48>
50006ce8:	51002737          	lui	a4,0x51002
50006cec:	2d072703          	lw	a4,720(a4) # 510022d0 <_kernel+0x10>
50006cf0:	00e78a63          	beq	a5,a4,50006d04 <_abort_timeout+0x28>
50006cf4:	0007a683          	lw	a3,0(a5)
50006cf8:	0106a703          	lw	a4,16(a3)
50006cfc:	00a70533          	add	a0,a4,a0
50006d00:	00a6a823          	sw	a0,16(a3)
50006d04:	0007a683          	lw	a3,0(a5)
50006d08:	0047a703          	lw	a4,4(a5)
50006d0c:	00d72023          	sw	a3,0(a4)
50006d10:	0007a683          	lw	a3,0(a5)
50006d14:	00000513          	li	a0,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50006d18:	00e6a223          	sw	a4,4(a3)
50006d1c:	fff00713          	li	a4,-1
50006d20:	00e7a823          	sw	a4,16(a5)
50006d24:	00008067          	ret

50006d28 <schedule_new_thread.part.14>:
50006d28:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50006d2c:	30073773          	csrrc	a4,mstatus,a4
50006d30:	00a00793          	li	a5,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50006d34:	00958593          	addi	a1,a1,9
50006d38:	02f5d5b3          	divu	a1,a1,a5
50006d3c:	510026b7          	lui	a3,0x51002
50006d40:	2c068793          	addi	a5,a3,704 # 510022c0 <_kernel>
50006d44:	51002837          	lui	a6,0x51002
50006d48:	00c7a783          	lw	a5,12(a5)
50006d4c:	2cc80813          	addi	a6,a6,716 # 510022cc <_kernel+0xc>
50006d50:	fc173733          	p.bclr	a4,a4,30,1
50006d54:	00a52c23          	sw	a0,24(a0)
50006d58:	00052e23          	sw	zero,28(a0)
50006d5c:	2c068693          	addi	a3,a3,704
50006d60:	00158593          	addi	a1,a1,1
50006d64:	02b52023          	sw	a1,32(a0)
50006d68:	03079063          	bne	a5,a6,50006d88 <schedule_new_thread.part.14+0x60>
50006d6c:	01052823          	sw	a6,16(a0)
50006d70:	0106a603          	lw	a2,16(a3)
50006d74:	01050793          	addi	a5,a0,16
50006d78:	00c52a23          	sw	a2,20(a0)
50006d7c:	00f62023          	sw	a5,0(a2)
50006d80:	00f6a823          	sw	a5,16(a3)
50006d84:	0580006f          	j	50006ddc <schedule_new_thread.part.14+0xb4>
50006d88:	fe0782e3          	beqz	a5,50006d6c <schedule_new_thread.part.14+0x44>
50006d8c:	0106a883          	lw	a7,16(a3)
50006d90:	02052603          	lw	a2,32(a0)
50006d94:	0107a583          	lw	a1,16(a5)
50006d98:	02c5c663          	blt	a1,a2,50006dc4 <schedule_new_thread.part.14+0x9c>
50006d9c:	40c58633          	sub	a2,a1,a2
50006da0:	00c7a823          	sw	a2,16(a5)
50006da4:	0047a603          	lw	a2,4(a5)
50006da8:	00c52a23          	sw	a2,20(a0)
50006dac:	00f52823          	sw	a5,16(a0)
50006db0:	01050693          	addi	a3,a0,16
50006db4:	0047a603          	lw	a2,4(a5)
50006db8:	00d62023          	sw	a3,0(a2)
50006dbc:	00d7a223          	sw	a3,4(a5)
50006dc0:	01c0006f          	j	50006ddc <schedule_new_thread.part.14+0xb4>
50006dc4:	40b60633          	sub	a2,a2,a1
50006dc8:	02c52023          	sw	a2,32(a0)
50006dcc:	fb1780e3          	beq	a5,a7,50006d6c <schedule_new_thread.part.14+0x44>
50006dd0:	0007a783          	lw	a5,0(a5)
50006dd4:	fa079ee3          	bnez	a5,50006d90 <schedule_new_thread.part.14+0x68>
50006dd8:	f95ff06f          	j	50006d6c <schedule_new_thread.part.14+0x44>
50006ddc:	30072773          	csrrs	a4,mstatus,a4
50006de0:	00008067          	ret

50006de4 <k_is_in_isr>:
50006de4:	510027b7          	lui	a5,0x51002
50006de8:	2c07a503          	lw	a0,704(a5) # 510022c0 <_kernel>
50006dec:	00a03533          	snez	a0,a0
50006df0:	00008067          	ret

50006df4 <_is_thread_essential>:
50006df4:	510027b7          	lui	a5,0x51002
50006df8:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
50006dfc:	0087c503          	lbu	a0,8(a5)
50006e00:	fc153533          	p.bclr	a0,a0,30,1
50006e04:	00008067          	ret

50006e08 <_thread_entry>:
50006e08:	ff010113          	addi	sp,sp,-16
50006e0c:	00112623          	sw	ra,12(sp)
50006e10:	00050793          	mv	a5,a0
50006e14:	00058513          	mv	a0,a1
50006e18:	00060593          	mv	a1,a2
50006e1c:	00068613          	mv	a2,a3
50006e20:	000780e7          	jalr	a5
50006e24:	fd1ff0ef          	jal	50006df4 <_is_thread_essential>
50006e28:	02050663          	beqz	a0,50006e54 <_thread_entry+0x4c>
50006e2c:	510025b7          	lui	a1,0x51002
50006e30:	51001537          	lui	a0,0x51001
50006e34:	a9c58593          	addi	a1,a1,-1380 # 51001a9c <config_levels+0x3c>
50006e38:	0c100613          	li	a2,193 # c1 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x41>
50006e3c:	dd450513          	addi	a0,a0,-556 # 51000dd4 <k256+0x6a8>
50006e40:	8e4fb0ef          	jal	50001f24 <printk>
50006e44:	510015b7          	lui	a1,0x51001
50006e48:	70c58593          	addi	a1,a1,1804 # 5100170c <_default_esf>
50006e4c:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
50006e50:	e08fe0ef          	jal	50005458 <_NanoFatalErrorHandler>
50006e54:	510027b7          	lui	a5,0x51002
50006e58:	2c87a503          	lw	a0,712(a5) # 510022c8 <_kernel+0x8>
50006e5c:	1e4000ef          	jal	50007040 <k_thread_abort>

50006e60 <k_thread_create>:
50006e60:	fe010113          	addi	sp,sp,-32
50006e64:	02012303          	lw	t1,32(sp)
50006e68:	00612023          	sw	t1,0(sp)
50006e6c:	00812c23          	sw	s0,24(sp)
50006e70:	00112e23          	sw	ra,28(sp)
50006e74:	00050413          	mv	s0,a0
50006e78:	f9cfe0ef          	jal	50005614 <_new_thread>
50006e7c:	02412783          	lw	a5,36(sp)
50006e80:	00079863          	bnez	a5,50006e90 <k_thread_create+0x30>
50006e84:	00040513          	mv	a0,s0
50006e88:	dc9ff0ef          	jal	50006c50 <start_thread>
50006e8c:	0100006f          	j	50006e9c <k_thread_create+0x3c>
50006e90:	02412583          	lw	a1,36(sp)
50006e94:	00040513          	mv	a0,s0
50006e98:	e91ff0ef          	jal	50006d28 <schedule_new_thread.part.14>
50006e9c:	01c12083          	lw	ra,28(sp)
50006ea0:	00040513          	mv	a0,s0
50006ea4:	01812403          	lw	s0,24(sp)
50006ea8:	02010113          	addi	sp,sp,32
50006eac:	00008067          	ret

50006eb0 <_k_thread_single_abort>:
}

void _k_thread_single_abort(struct k_thread *thread)
{
50006eb0:	ff010113          	addi	sp,sp,-16
	if (thread->fn_abort != NULL) {
50006eb4:	06052783          	lw	a5,96(a0)

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
50006eb8:	00812423          	sw	s0,8(sp)
50006ebc:	00112623          	sw	ra,12(sp)
50006ec0:	00050413          	mv	s0,a0
	if (thread->fn_abort != NULL) {
50006ec4:	00078463          	beqz	a5,50006ecc <_k_thread_single_abort+0x1c>
		thread->fn_abort();
50006ec8:	000780e7          	jalr	a5
	}

	if (_is_thread_ready(thread)) {
50006ecc:	00040513          	mv	a0,s0
50006ed0:	d5dff0ef          	jal	50006c2c <_is_thread_ready>
50006ed4:	00050863          	beqz	a0,50006ee4 <_k_thread_single_abort+0x34>
		_remove_thread_from_ready_q(thread);
50006ed8:	00040513          	mv	a0,s0
50006edc:	c90ff0ef          	jal	5000636c <_remove_thread_from_ready_q>
50006ee0:	0400006f          	j	50006f20 <_k_thread_single_abort+0x70>
	} else {
		if (_is_thread_pending(thread)) {
50006ee4:	00944783          	lbu	a5,9(s0)
50006ee8:	0027f793          	andi	a5,a5,2
50006eec:	02078263          	beqz	a5,50006f10 <_k_thread_single_abort+0x60>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50006ef0:	00042703          	lw	a4,0(s0)
50006ef4:	00442783          	lw	a5,4(s0)
50006ef8:	00e7a023          	sw	a4,0(a5)
	node->next->prev = node->prev;
50006efc:	00042703          	lw	a4,0(s0)
50006f00:	00f72223          	sw	a5,4(a4)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
50006f04:	00944783          	lbu	a5,9(s0)
50006f08:	c017b7b3          	p.bclr	a5,a5,0,1
50006f0c:	00f404a3          	sb	a5,9(s0)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
50006f10:	02042783          	lw	a5,32(s0)
50006f14:	01f7a663          	p.beqimm	a5,-1,50006f20 <_k_thread_single_abort+0x70>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
50006f18:	01040513          	addi	a0,s0,16
50006f1c:	dc1ff0ef          	jal	50006cdc <_abort_timeout>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
50006f20:	00944783          	lbu	a5,9(s0)
50006f24:	c037c7b3          	p.bset	a5,a5,0,3
50006f28:	00f404a3          	sb	a5,9(s0)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
50006f2c:	00c12083          	lw	ra,12(sp)
50006f30:	00812403          	lw	s0,8(sp)
50006f34:	01010113          	addi	sp,sp,16
50006f38:	00008067          	ret

50006f3c <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50006f3c:	fd010113          	addi	sp,sp,-48
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50006f40:	510027b7          	lui	a5,0x51002
	_mark_thread_as_dead(thread);
}

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50006f44:	02912223          	sw	s1,36(sp)
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50006f48:	510024b7          	lui	s1,0x51002
	_mark_thread_as_dead(thread);
}

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50006f4c:	02812423          	sw	s0,40(sp)
50006f50:	01312e23          	sw	s3,28(sp)
50006f54:	02112623          	sw	ra,44(sp)
50006f58:	03212023          	sw	s2,32(sp)
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50006f5c:	b1478413          	addi	s0,a5,-1260 # 51001b14 <__device_APPLICATION_start>
50006f60:	b1478993          	addi	s3,a5,-1260
50006f64:	b1448493          	addi	s1,s1,-1260 # 51001b14 <__device_APPLICATION_start>
50006f68:	00048913          	mv	s2,s1
50006f6c:	04947063          	bleu	s1,s0,50006fac <_init_static_threads+0x70>
		_new_thread(
50006f70:	00042503          	lw	a0,0(s0)
50006f74:	02042303          	lw	t1,32(s0)
50006f78:	01442783          	lw	a5,20(s0)
50006f7c:	01c42883          	lw	a7,28(s0)
50006f80:	01842803          	lw	a6,24(s0)
50006f84:	01042703          	lw	a4,16(s0)
50006f88:	00c42683          	lw	a3,12(s0)
50006f8c:	00842603          	lw	a2,8(s0)
50006f90:	00442583          	lw	a1,4(s0)
50006f94:	00612023          	sw	t1,0(sp)
50006f98:	e7cfe0ef          	jal	50005614 <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->init_thread->init_data = thread_data;
50006f9c:	00042783          	lw	a5,0(s0)
50006fa0:	0487ae23          	sw	s0,92(a5)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50006fa4:	03040413          	addi	s0,s0,48
50006fa8:	fc1ff06f          	j	50006f68 <_init_static_threads+0x2c>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
50006fac:	510027b7          	lui	a5,0x51002
50006fb0:	2c87a703          	lw	a4,712(a5) # 510022c8 <_kernel+0x8>
50006fb4:	00b74783          	lbu	a5,11(a4)
50006fb8:	fff78793          	addi	a5,a5,-1
50006fbc:	00f705a3          	sb	a5,11(a4)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50006fc0:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
50006fc4:	3004b4f3          	csrrc	s1,mstatus,s1
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50006fc8:	fc14b4b3          	p.bclr	s1,s1,30,1
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
50006fcc:	00098413          	mv	s0,s3
50006fd0:	03247463          	bleu	s2,s0,50006ff8 <_init_static_threads+0xbc>
		if (thread_data->init_delay != K_FOREVER) {
50006fd4:	02442583          	lw	a1,36(s0)
50006fd8:	01f5ac63          	p.beqimm	a1,-1,50006ff0 <_init_static_threads+0xb4>
			schedule_new_thread(thread_data->init_thread,
50006fdc:	00042503          	lw	a0,0(s0)

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
50006fe0:	00059663          	bnez	a1,50006fec <_init_static_threads+0xb0>
		start_thread(thread);
50006fe4:	c6dff0ef          	jal	50006c50 <start_thread>
50006fe8:	0080006f          	j	50006ff0 <_init_static_threads+0xb4>
50006fec:	d3dff0ef          	jal	50006d28 <schedule_new_thread.part.14>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
50006ff0:	03040413          	addi	s0,s0,48
50006ff4:	fddff06f          	j	50006fd0 <_init_static_threads+0x94>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50006ff8:	3004a4f3          	csrrs	s1,mstatus,s1
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
50006ffc:	02c12083          	lw	ra,44(sp)
50007000:	02812403          	lw	s0,40(sp)
50007004:	02412483          	lw	s1,36(sp)
50007008:	02012903          	lw	s2,32(sp)
5000700c:	01c12983          	lw	s3,28(sp)
50007010:	03010113          	addi	sp,sp,48
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
50007014:	d64ff06f          	j	50006578 <k_sched_unlock>

50007018 <_init_thread_base>:
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
50007018:	fff00793          	li	a5,-1
void _init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
5000701c:	00d50423          	sb	a3,8(a0)
	thread_base->thread_state = (u8_t)initial_state;
50007020:	00c504a3          	sb	a2,9(a0)

	thread_base->prio = priority;
50007024:	00b50523          	sb	a1,10(a0)

	thread_base->sched_locked = 0;
50007028:	000505a3          	sb	zero,11(a0)
5000702c:	02f52023          	sw	a5,32(a0)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
50007030:	00052e23          	sw	zero,28(a0)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
50007034:	00052c23          	sw	zero,24(a0)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
50007038:	02052223          	sw	zero,36(a0)
5000703c:	00008067          	ret

50007040 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
50007040:	ff010113          	addi	sp,sp,-16
50007044:	00812423          	sw	s0,8(sp)
50007048:	00912223          	sw	s1,4(sp)
5000704c:	00112623          	sw	ra,12(sp)
50007050:	00050493          	mv	s1,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50007054:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50007058:	30043473          	csrrc	s0,mstatus,s0
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
5000705c:	e55ff0ef          	jal	50006eb0 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
50007060:	510027b7          	lui	a5,0x51002
50007064:	2c87a783          	lw	a5,712(a5) # 510022c8 <_kernel+0x8>
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50007068:	fc143433          	p.bclr	s0,s0,30,1
5000706c:	00f49863          	bne	s1,a5,5000707c <k_thread_abort+0x3c>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
50007070:	e88ff0ef          	jal	500066f8 <_update_time_slice_before_swap>
#endif

	return __swap(key);
50007074:	00040513          	mv	a0,s0
50007078:	ae8f90ef          	jal	50000360 <__swap>
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
5000707c:	00040513          	mv	a0,s0
}
50007080:	00c12083          	lw	ra,12(sp)
50007084:	00812403          	lw	s0,8(sp)
50007088:	00412483          	lw	s1,4(sp)
5000708c:	01010113          	addi	sp,sp,16
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
50007090:	c88ff06f          	j	50006518 <_reschedule_threads>

50007094 <work_q_main>:
#include <kernel_structs.h>
#include <wait_q.h>
#include <errno.h>

static void work_q_main(void *work_q_ptr, void *p2, void *p3)
{
50007094:	ff010113          	addi	sp,sp,-16
50007098:	00912223          	sw	s1,4(sp)
5000709c:	00112623          	sw	ra,12(sp)
500070a0:	00812423          	sw	s0,8(sp)
500070a4:	01212023          	sw	s2,0(sp)
500070a8:	00050493          	mv	s1,a0

	while (1) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_fifo_get(&work_q->fifo, K_FOREVER);
500070ac:	fff00593          	li	a1,-1
500070b0:	00048513          	mv	a0,s1
500070b4:	8f4ff0ef          	jal	500061a8 <k_queue_get>

		handler = work->handler;
500070b8:	00452903          	lw	s2,4(a0)

	while (1) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_fifo_get(&work_q->fifo, K_FOREVER);
500070bc:	00050413          	mv	s0,a0
static inline int atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
500070c0:	ffe00593          	li	a1,-2 # fffffffe <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffff>
500070c4:	00850513          	addi	a0,a0,8
500070c8:	e70fe0ef          	jal	50005738 <atomic_and>

		handler = work->handler;

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
500070cc:	fc153533          	p.bclr	a0,a0,30,1
500070d0:	00050663          	beqz	a0,500070dc <work_q_main+0x48>
					       K_WORK_STATE_PENDING)) {
			handler(work);
500070d4:	00040513          	mv	a0,s0
500070d8:	000900e7          	jalr	s2
		}

		/* Make sure we don't hog up the CPU if the FIFO never (or
		 * very rarely) gets empty.
		 */
		k_yield();
500070dc:	d44ff0ef          	jal	50006620 <k_yield>
	}
500070e0:	fcdff06f          	j	500070ac <work_q_main+0x18>

500070e4 <k_work_q_start>:
}

void k_work_q_start(struct k_work_q *work_q, char *stack,
		    size_t stack_size, int prio)
{
500070e4:	fd010113          	addi	sp,sp,-48
500070e8:	02112623          	sw	ra,44(sp)
500070ec:	02812423          	sw	s0,40(sp)
500070f0:	02912223          	sw	s1,36(sp)
500070f4:	03212023          	sw	s2,32(sp)
500070f8:	01312e23          	sw	s3,28(sp)
500070fc:	00050913          	mv	s2,a0
50007100:	00068993          	mv	s3,a3
50007104:	00058413          	mv	s0,a1
50007108:	00060493          	mv	s1,a2
	k_fifo_init(&work_q->fifo);
5000710c:	e55fe0ef          	jal	50005f60 <k_queue_init>

	k_thread_create(&work_q->thread, stack, stack_size, work_q_main,
50007110:	500076b7          	lui	a3,0x50007
50007114:	00012223          	sw	zero,4(sp)
50007118:	00012023          	sw	zero,0(sp)
5000711c:	00098893          	mv	a7,s3
50007120:	00090713          	mv	a4,s2
50007124:	00048613          	mv	a2,s1
50007128:	00040593          	mv	a1,s0
5000712c:	01490513          	addi	a0,s2,20
50007130:	00000813          	li	a6,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50007134:	00000793          	li	a5,0 # 0 <CONFIG_BLUETOOTH_DEVICE_APPEARANCE>
50007138:	09468693          	addi	a3,a3,148 # 50007094 <work_q_main>
5000713c:	d25ff0ef          	jal	50006e60 <k_thread_create>
			work_q, 0, 0, prio, 0, 0);
}
50007140:	02c12083          	lw	ra,44(sp)
50007144:	02812403          	lw	s0,40(sp)
50007148:	02412483          	lw	s1,36(sp)
5000714c:	02012903          	lw	s2,32(sp)
50007150:	01c12983          	lw	s3,28(sp)
50007154:	03010113          	addi	sp,sp,48
50007158:	00008067          	ret

5000715c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
5000715c:	ff010113          	addi	sp,sp,-16
50007160:	00812423          	sw	s0,8(sp)
50007164:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50007168:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
5000716c:	300437f3          	csrrc	a5,mstatus,s0
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
50007170:	a38fe0ef          	jal	500053a8 <k_cpu_idle>
50007174:	ff9ff06f          	j	5000716c <idle+0x10>

50007178 <_OffsetAbsSyms>:
 * are aligned accordingly.
 */
GEN_ABSOLUTE_SYM(__NANO_ESF_SIZEOF, STACK_ROUND_UP(sizeof(NANO_ESF)));

/* size of the struct tcs structure sans save area for floating point regs */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
50007178:	00008067          	ret
