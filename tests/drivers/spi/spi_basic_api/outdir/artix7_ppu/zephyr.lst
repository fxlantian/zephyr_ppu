
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

50000000 <vinit>:
50000000:	00000013          	nop
50000004:	00000013          	nop
50000008:	00000013          	nop
5000000c:	00000013          	nop
50000010:	00000013          	nop
50000014:	00000013          	nop
50000018:	00000013          	nop
5000001c:	00000013          	nop
50000020:	00000013          	nop
50000024:	00000013          	nop
50000028:	00000013          	nop
5000002c:	00000013          	nop
50000030:	00000013          	nop
50000034:	00000013          	nop
50000038:	00000013          	nop
5000003c:	0580006f          	j	50000094 <__irq_wrapper>
50000040:	0540006f          	j	50000094 <__irq_wrapper>
50000044:	0500006f          	j	50000094 <__irq_wrapper>
50000048:	04c0006f          	j	50000094 <__irq_wrapper>
5000004c:	0480006f          	j	50000094 <__irq_wrapper>
50000050:	0440006f          	j	50000094 <__irq_wrapper>
50000054:	0400006f          	j	50000094 <__irq_wrapper>
50000058:	03c0006f          	j	50000094 <__irq_wrapper>
5000005c:	0380006f          	j	50000094 <__irq_wrapper>
50000060:	0340006f          	j	50000094 <__irq_wrapper>
50000064:	0300006f          	j	50000094 <__irq_wrapper>
50000068:	02c0006f          	j	50000094 <__irq_wrapper>
5000006c:	0280006f          	j	50000094 <__irq_wrapper>
50000070:	0240006f          	j	50000094 <__irq_wrapper>
50000074:	0200006f          	j	50000094 <__irq_wrapper>
50000078:	01c0006f          	j	50000094 <__irq_wrapper>
5000007c:	0180006f          	j	50000094 <__irq_wrapper>
50000080:	0100006f          	j	50000090 <__reset>
50000084:	0100006f          	j	50000094 <__irq_wrapper>
50000088:	00c0006f          	j	50000094 <__irq_wrapper>
5000008c:	0080006f          	j	50000094 <__irq_wrapper>

Disassembly of section reset:

50000090 <__reset>:
50000090:	045010ef          	jal	500018d4 <__start>

Disassembly of section exceptions:

50000094 <__irq_wrapper>:
50000094:	f9010113          	addi	sp,sp,-112
50000098:	00112023          	sw	ra,0(sp)
5000009c:	00312223          	sw	gp,4(sp)
500000a0:	00412423          	sw	tp,8(sp)
500000a4:	00512623          	sw	t0,12(sp)
500000a8:	00612823          	sw	t1,16(sp)
500000ac:	00712a23          	sw	t2,20(sp)
500000b0:	01c12c23          	sw	t3,24(sp)
500000b4:	01d12e23          	sw	t4,28(sp)
500000b8:	03e12023          	sw	t5,32(sp)
500000bc:	03f12223          	sw	t6,36(sp)
500000c0:	02a12423          	sw	a0,40(sp)
500000c4:	02b12623          	sw	a1,44(sp)
500000c8:	02c12823          	sw	a2,48(sp)
500000cc:	02d12a23          	sw	a3,52(sp)
500000d0:	02e12c23          	sw	a4,56(sp)
500000d4:	02f12e23          	sw	a5,60(sp)
500000d8:	05012023          	sw	a6,64(sp)
500000dc:	05112223          	sw	a7,68(sp)
500000e0:	341022f3          	csrr	t0,mepc
500000e4:	04512423          	sw	t0,72(sp)
500000e8:	7c0022f3          	csrr	t0,0x7c0
500000ec:	04512623          	sw	t0,76(sp)
500000f0:	1c8000ef          	jal	500002b8 <__soc_save_context>
500000f4:	250000ef          	jal	50000344 <__soc_is_irq>
500000f8:	00000313          	li	t1,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500000fc:	02051a63          	bnez	a0,50000130 <is_interrupt>
50000100:	04812283          	lw	t0,72(sp)
50000104:	00428293          	addi	t0,t0,4
50000108:	04512423          	sw	t0,72(sp)
5000010c:	342022f3          	csrr	t0,mcause
50000110:	01f00393          	li	t2,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
50000114:	0072f2b3          	and	t0,t0,t2
50000118:	00b00313          	li	t1,11 # b <___thread_base_t_sched_locked_OFFSET>
5000011c:	0a628463          	beq	t0,t1,500001c4 <reschedule>
50000120:	00010513          	mv	a0,sp
50000124:	00000097          	auipc	ra,0x0
50000128:	13008093          	addi	ra,ra,304 # 50000254 <no_reschedule>
5000012c:	15d0106f          	j	50001a88 <_Fault>

50000130 <is_interrupt>:
50000130:	00010293          	mv	t0,sp
50000134:	01001397          	auipc	t2,0x1001
50000138:	9e838393          	addi	t2,t2,-1560 # 51000b1c <_kernel>
5000013c:	0043a103          	lw	sp,4(t2)
50000140:	ff010113          	addi	sp,sp,-16
50000144:	00512023          	sw	t0,0(sp)

50000148 <on_irq_stack>:
50000148:	0003ae03          	lw	t3,0(t2)
5000014c:	001e0e13          	addi	t3,t3,1
50000150:	01c3a023          	sw	t3,0(t2)
50000154:	00030863          	beqz	t1,50000164 <call_irq>
50000158:	00000097          	auipc	ra,0x0
5000015c:	03808093          	addi	ra,ra,56 # 50000190 <on_thread_stack>
50000160:	2710106f          	j	50001bd0 <_irq_do_offload>

50000164 <call_irq>:
50000164:	34202573          	csrr	a0,mcause
50000168:	01f00293          	li	t0,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
5000016c:	00557533          	and	a0,a0,t0
50000170:	1b0000ef          	jal	50000320 <__soc_handle_irq>
50000174:	01000297          	auipc	t0,0x1000
50000178:	ec828293          	addi	t0,t0,-312 # 5100003c <__devconfig_end>
5000017c:	00351513          	slli	a0,a0,0x3
50000180:	00a282b3          	add	t0,t0,a0
50000184:	0002a503          	lw	a0,0(t0)
50000188:	0042a303          	lw	t1,4(t0)
5000018c:	000300e7          	jalr	t1

50000190 <on_thread_stack>:
50000190:	01001317          	auipc	t1,0x1001
50000194:	98c30313          	addi	t1,t1,-1652 # 51000b1c <_kernel>
50000198:	00032383          	lw	t2,0(t1)
5000019c:	fff38393          	addi	t2,t2,-1
500001a0:	00732023          	sw	t2,0(t1)
500001a4:	00012283          	lw	t0,0(sp)
500001a8:	00028113          	mv	sp,t0
500001ac:	00832383          	lw	t2,8(t1)
500001b0:	00a3de03          	lhu	t3,10(t2)
500001b4:	08000e93          	li	t4,128 # 80 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN>
500001b8:	09de7e63          	bleu	t4,t3,50000254 <no_reschedule>
500001bc:	01432e03          	lw	t3,20(t1)
500001c0:	087e0a63          	beq	t3,t2,50000254 <no_reschedule>

500001c4 <reschedule>:
500001c4:	110020ef          	jal	500022d4 <_update_time_slice_before_swap>
500001c8:	01001297          	auipc	t0,0x1001
500001cc:	95428293          	addi	t0,t0,-1708 # 51000b1c <_kernel>
500001d0:	0082a303          	lw	t1,8(t0)
500001d4:	02832623          	sw	s0,44(t1)
500001d8:	02932823          	sw	s1,48(t1)
500001dc:	03232a23          	sw	s2,52(t1)
500001e0:	03332c23          	sw	s3,56(t1)
500001e4:	03432e23          	sw	s4,60(t1)
500001e8:	05532023          	sw	s5,64(t1)
500001ec:	05632223          	sw	s6,68(t1)
500001f0:	05732423          	sw	s7,72(t1)
500001f4:	05832623          	sw	s8,76(t1)
500001f8:	05932823          	sw	s9,80(t1)
500001fc:	05a32a23          	sw	s10,84(t1)
50000200:	05b32c23          	sw	s11,88(t1)
50000204:	02232423          	sw	sp,40(t1)
50000208:	01000397          	auipc	t2,0x1000
5000020c:	75438393          	addi	t2,t2,1876 # 5100095c <_k_neg_eagain>
50000210:	0003ae03          	lw	t3,0(t2)
50000214:	07c32423          	sw	t3,104(t1)
50000218:	0142a303          	lw	t1,20(t0)
5000021c:	0062a423          	sw	t1,8(t0)
50000220:	02832103          	lw	sp,40(t1)
50000224:	02c32403          	lw	s0,44(t1)
50000228:	03032483          	lw	s1,48(t1)
5000022c:	03432903          	lw	s2,52(t1)
50000230:	03832983          	lw	s3,56(t1)
50000234:	03c32a03          	lw	s4,60(t1)
50000238:	04032a83          	lw	s5,64(t1)
5000023c:	04432b03          	lw	s6,68(t1)
50000240:	04832b83          	lw	s7,72(t1)
50000244:	04c32c03          	lw	s8,76(t1)
50000248:	05032c83          	lw	s9,80(t1)
5000024c:	05432d03          	lw	s10,84(t1)
50000250:	05832d83          	lw	s11,88(t1)

50000254 <no_reschedule>:
50000254:	098000ef          	jal	500002ec <__soc_restore_context>
50000258:	04812283          	lw	t0,72(sp)
5000025c:	34129073          	csrw	mepc,t0
50000260:	04c12283          	lw	t0,76(sp)
50000264:	7c029073          	csrw	0x7c0,t0
50000268:	00012083          	lw	ra,0(sp)
5000026c:	00412183          	lw	gp,4(sp)
50000270:	00812203          	lw	tp,8(sp)
50000274:	00c12283          	lw	t0,12(sp)
50000278:	01012303          	lw	t1,16(sp)
5000027c:	01412383          	lw	t2,20(sp)
50000280:	01812e03          	lw	t3,24(sp)
50000284:	01c12e83          	lw	t4,28(sp)
50000288:	02012f03          	lw	t5,32(sp)
5000028c:	02412f83          	lw	t6,36(sp)
50000290:	02812503          	lw	a0,40(sp)
50000294:	02c12583          	lw	a1,44(sp)
50000298:	03012603          	lw	a2,48(sp)
5000029c:	03412683          	lw	a3,52(sp)
500002a0:	03812703          	lw	a4,56(sp)
500002a4:	03c12783          	lw	a5,60(sp)
500002a8:	04012803          	lw	a6,64(sp)
500002ac:	04412883          	lw	a7,68(sp)
500002b0:	07010113          	addi	sp,sp,112
500002b4:	10000073          	eret

500002b8 <__soc_save_context>:
500002b8:	7b0022f3          	csrr	t0,0x7b0
500002bc:	7b102373          	csrr	t1,0x7b1
500002c0:	7b2023f3          	csrr	t2,0x7b2
500002c4:	04512823          	sw	t0,80(sp)
500002c8:	04612a23          	sw	t1,84(sp)
500002cc:	04712c23          	sw	t2,88(sp)
500002d0:	7b4022f3          	csrr	t0,0x7b4
500002d4:	7b502373          	csrr	t1,0x7b5
500002d8:	7b6023f3          	csrr	t2,0x7b6
500002dc:	04512e23          	sw	t0,92(sp)
500002e0:	06612023          	sw	t1,96(sp)
500002e4:	06712223          	sw	t2,100(sp)
500002e8:	00008067          	ret

500002ec <__soc_restore_context>:
500002ec:	05012283          	lw	t0,80(sp)
500002f0:	05412303          	lw	t1,84(sp)
500002f4:	05812383          	lw	t2,88(sp)
500002f8:	7b029073          	csrw	0x7b0,t0
500002fc:	7b131073          	csrw	0x7b1,t1
50000300:	7b239073          	csrw	0x7b2,t2
50000304:	05c12283          	lw	t0,92(sp)
50000308:	06012303          	lw	t1,96(sp)
5000030c:	06412383          	lw	t2,100(sp)
50000310:	7b429073          	csrw	0x7b4,t0
50000314:	7b531073          	csrw	0x7b5,t1
50000318:	7b639073          	csrw	0x7b6,t2
5000031c:	00008067          	ret

50000320 <__soc_handle_irq>:
50000320:	1a104337          	lui	t1,0x1a104
50000324:	00c30313          	addi	t1,t1,12 # 1a10400c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f8c>
50000328:	00100393          	li	t2,1 # 1 <CONFIG_ARCH>
5000032c:	00a39e33          	sll	t3,t2,a0
50000330:	01c32023          	sw	t3,0(t1)
50000334:	1a104337          	lui	t1,0x1a104
50000338:	01c30313          	addi	t1,t1,28 # 1a10401c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f9c>
5000033c:	01c32023          	sw	t3,0(t1)
50000340:	00008067          	ret

50000344 <__soc_is_irq>:
50000344:	342022f3          	csrr	t0,mcause
50000348:	01f2f293          	andi	t0,t0,31
5000034c:	00f00313          	li	t1,15 # f <CONFIG_NUM_PREEMPT_PRIORITIES>
50000350:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000354:	0062c463          	blt	t0,t1,5000035c <not_interrupt>
50000358:	00150513          	addi	a0,a0,1

5000035c <not_interrupt>:
5000035c:	00008067          	ret

50000360 <__swap>:
50000360:	00000073          	ecall
50000364:	01000297          	auipc	t0,0x1000
50000368:	7b828293          	addi	t0,t0,1976 # 51000b1c <_kernel>
5000036c:	0082a303          	lw	t1,8(t0)
50000370:	06832383          	lw	t2,104(t1)
50000374:	00157513          	andi	a0,a0,1
50000378:	300522f3          	csrrs	t0,mstatus,a0
5000037c:	00038513          	mv	a0,t2
50000380:	00008067          	ret

Disassembly of section text:

50000384 <unit_test_noop>:
 * Unit test / setup function / teardown function that does
 * nothing, successfully. Can be used as a parameter to
 * ztest_unit_test_setup_teardown().
 */
static inline void unit_test_noop(void)
{
50000384:	00008067          	ret

50000388 <test_main>:
void test_spi_cpol(void);
void test_spi_cpha(void);
void test_spi_cpol_cpha(void);

void test_main(void)
{
50000388:	fb010113          	addi	sp,sp,-80
	ztest_test_suite(spi_test,
5000038c:	04000613          	li	a2,64 # 40 <__NANO_ESF_a6_OFFSET>
50000390:	00000593          	li	a1,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000394:	00010513          	mv	a0,sp
void test_spi_cpol(void);
void test_spi_cpha(void);
void test_spi_cpol_cpha(void);

void test_main(void)
{
50000398:	04112623          	sw	ra,76(sp)
	ztest_test_suite(spi_test,
5000039c:	354000ef          	jal	500006f0 <memset>
500003a0:	51000737          	lui	a4,0x51000
500003a4:	14c70713          	addi	a4,a4,332 # 5100014c <__devconfig_end+0x110>
500003a8:	00e12823          	sw	a4,16(sp)
500003ac:	510007b7          	lui	a5,0x51000
500003b0:	50000737          	lui	a4,0x50000
500003b4:	13c78793          	addi	a5,a5,316 # 5100013c <__devconfig_end+0x100>
500003b8:	5ec70713          	addi	a4,a4,1516 # 500005ec <test_spi_cpha>
500003bc:	00f12023          	sw	a5,0(sp)
500003c0:	00e12a23          	sw	a4,20(sp)
500003c4:	500007b7          	lui	a5,0x50000
500003c8:	51000737          	lui	a4,0x51000
500003cc:	58478793          	addi	a5,a5,1412 # 50000584 <test_spi_cpol>
500003d0:	15c70713          	addi	a4,a4,348 # 5100015c <__devconfig_end+0x120>
500003d4:	00f12223          	sw	a5,4(sp)
500003d8:	02e12023          	sw	a4,32(sp)
500003dc:	500007b7          	lui	a5,0x50000
500003e0:	50000737          	lui	a4,0x50000
			 ztest_unit_test(test_spi_cpol),
			 ztest_unit_test(test_spi_cpha),
			 ztest_unit_test(test_spi_cpol_cpha));
	ztest_run_test_suite(spi_test);
500003e4:	51000537          	lui	a0,0x51000
void test_spi_cpha(void);
void test_spi_cpol_cpha(void);

void test_main(void)
{
	ztest_test_suite(spi_test,
500003e8:	38478793          	addi	a5,a5,900 # 50000384 <unit_test_noop>
500003ec:	65470713          	addi	a4,a4,1620 # 50000654 <test_spi_cpol_cpha>
			 ztest_unit_test(test_spi_cpol),
			 ztest_unit_test(test_spi_cpha),
			 ztest_unit_test(test_spi_cpol_cpha));
	ztest_run_test_suite(spi_test);
500003f0:	00010593          	mv	a1,sp
500003f4:	17050513          	addi	a0,a0,368 # 51000170 <__devconfig_end+0x134>
void test_spi_cpha(void);
void test_spi_cpol_cpha(void);

void test_main(void)
{
	ztest_test_suite(spi_test,
500003f8:	00f12423          	sw	a5,8(sp)
500003fc:	00f12623          	sw	a5,12(sp)
50000400:	00f12c23          	sw	a5,24(sp)
50000404:	00f12e23          	sw	a5,28(sp)
50000408:	02e12223          	sw	a4,36(sp)
5000040c:	02f12423          	sw	a5,40(sp)
50000410:	02f12623          	sw	a5,44(sp)
			 ztest_unit_test(test_spi_cpol),
			 ztest_unit_test(test_spi_cpha),
			 ztest_unit_test(test_spi_cpol_cpha));
	ztest_run_test_suite(spi_test);
50000414:	2a4010ef          	jal	500016b8 <_ztest_run_test_suite>
}
50000418:	04c12083          	lw	ra,76(sp)
5000041c:	05010113          	addi	sp,sp,80
50000420:	00008067          	ret

50000424 <test_spi>:

static char *wbuf = "Hello world";
static char rbuf[16] = {};

static int test_spi(u32_t mode)
{
50000424:	fe010113          	addi	sp,sp,-32
50000428:	01212823          	sw	s2,16(sp)
5000042c:	00050913          	mv	s2,a0
	struct device *spi_dev = device_get_binding(SPI_DEV_NAME);
50000430:	51000537          	lui	a0,0x51000
50000434:	17c50513          	addi	a0,a0,380 # 5100017c <__devconfig_end+0x140>

static char *wbuf = "Hello world";
static char rbuf[16] = {};

static int test_spi(u32_t mode)
{
50000438:	00812c23          	sw	s0,24(sp)
5000043c:	00912a23          	sw	s1,20(sp)
50000440:	00112e23          	sw	ra,28(sp)
50000444:	01312623          	sw	s3,12(sp)
	struct device *spi_dev = device_get_binding(SPI_DEV_NAME);
	u32_t len = strlen(wbuf);
50000448:	510004b7          	lui	s1,0x51000
static char *wbuf = "Hello world";
static char rbuf[16] = {};

static int test_spi(u32_t mode)
{
	struct device *spi_dev = device_get_binding(SPI_DEV_NAME);
5000044c:	005010ef          	jal	50001c50 <device_get_binding>
50000450:	00050413          	mv	s0,a0
	u32_t len = strlen(wbuf);
50000454:	18448513          	addi	a0,s1,388 # 51000184 <__devconfig_end+0x148>
50000458:	264000ef          	jal	500006bc <strlen>

	if (!spi_dev) {
5000045c:	00041863          	bnez	s0,5000046c <test_spi+0x48>
		TC_PRINT("Cannot get SPI device\n");
50000460:	51000537          	lui	a0,0x51000
50000464:	19050513          	addi	a0,a0,400 # 51000190 <__devconfig_end+0x154>
50000468:	0340006f          	j	5000049c <test_spi+0x78>
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
5000046c:	00442783          	lw	a5,4(s0)
		return TC_FAIL;
	}

	spi_conf.config = mode | SPI_MODE_LOOP;
50000470:	510015b7          	lui	a1,0x51001
50000474:	c0294933          	p.bset	s2,s2,0,2
50000478:	0007a783          	lw	a5,0(a5)
5000047c:	00050993          	mv	s3,a0
50000480:	9325ac23          	sw	s2,-1736(a1) # 51000938 <spi_conf>
50000484:	00040513          	mv	a0,s0
50000488:	93858593          	addi	a1,a1,-1736
5000048c:	000780e7          	jalr	a5
	/* 1. verify spi_configure() */
	if (spi_configure(spi_dev, &spi_conf)) {
50000490:	00050c63          	beqz	a0,500004a8 <test_spi+0x84>
		TC_PRINT("SPI config failed\n");
50000494:	51000537          	lui	a0,0x51000
50000498:	1a850513          	addi	a0,a0,424 # 510001a8 <__devconfig_end+0x16c>
5000049c:	120010ef          	jal	500015bc <printk>
		return TC_FAIL;
500004a0:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
500004a4:	0c40006f          	j	50000568 <test_spi+0x144>
 */
static inline int spi_slave_select(struct device *dev, u32_t slave)
{
	const struct spi_driver_api *api = dev->driver_api;

	if (!api->slave_select) {
500004a8:	00442783          	lw	a5,4(s0)
500004ac:	0047a783          	lw	a5,4(a5)
500004b0:	02078063          	beqz	a5,500004d0 <test_spi+0xac>
		return 0;
	}

	return api->slave_select(dev, slave);
500004b4:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
500004b8:	00040513          	mv	a0,s0
500004bc:	000780e7          	jalr	a5
	}

	/* 2. verify spi_slave_select() */
	if (spi_slave_select(spi_dev, SPI_SLAVE)) {
500004c0:	00050863          	beqz	a0,500004d0 <test_spi+0xac>
		TC_PRINT("SPI slave select failed\n");
500004c4:	51000537          	lui	a0,0x51000
500004c8:	1bc50513          	addi	a0,a0,444 # 510001bc <__devconfig_end+0x180>
500004cc:	fd1ff06f          	j	5000049c <test_spi+0x78>
 */
static inline int spi_write(struct device *dev, const void *buf, u32_t len)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, buf, len, NULL, 0);
500004d0:	00442783          	lw	a5,4(s0)
500004d4:	0087a783          	lw	a5,8(a5)
500004d8:	00000713          	li	a4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500004dc:	00000693          	li	a3,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500004e0:	00098613          	mv	a2,s3
500004e4:	18448593          	addi	a1,s1,388
500004e8:	00040513          	mv	a0,s0
500004ec:	000780e7          	jalr	a5
		return TC_FAIL;
	}

	/* 3. verify spi_write() */
	if (spi_write(spi_dev, wbuf, len) != 0) {
500004f0:	00050863          	beqz	a0,50000500 <test_spi+0xdc>
		TC_PRINT("SPI write failed\n");
500004f4:	51000537          	lui	a0,0x51000
500004f8:	1d850513          	addi	a0,a0,472 # 510001d8 <__devconfig_end+0x19c>
500004fc:	fa1ff06f          	j	5000049c <test_spi+0x78>
		return TC_FAIL;
	}

	/* 4. verify spi_transceive() */
	TC_PRINT("SPI sent: %s\n", wbuf);
50000500:	510005b7          	lui	a1,0x51000
50000504:	51000537          	lui	a0,0x51000
50000508:	18458593          	addi	a1,a1,388 # 51000184 <__devconfig_end+0x148>
5000050c:	1ec50513          	addi	a0,a0,492 # 510001ec <__devconfig_end+0x1b0>
50000510:	0ac010ef          	jal	500015bc <printk>
			  const void *tx_buf, u32_t tx_buf_len,
			  void *rx_buf, u32_t rx_buf_len)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
50000514:	51001937          	lui	s2,0x51001
50000518:	00442783          	lw	a5,4(s0)
5000051c:	0087a783          	lw	a5,8(a5)
50000520:	00098713          	mv	a4,s3
50000524:	99490693          	addi	a3,s2,-1644 # 51000994 <rbuf>
50000528:	00098613          	mv	a2,s3
5000052c:	18448593          	addi	a1,s1,388
50000530:	00040513          	mv	a0,s0
50000534:	000780e7          	jalr	a5
	if (spi_transceive(spi_dev, wbuf, len, rbuf, len) != 0) {
50000538:	00050863          	beqz	a0,50000548 <test_spi+0x124>
		TC_PRINT("SPI transceive failed\n");
5000053c:	51000537          	lui	a0,0x51000
50000540:	1fc50513          	addi	a0,a0,508 # 510001fc <__devconfig_end+0x1c0>
50000544:	f59ff06f          	j	5000049c <test_spi+0x78>
		return TC_FAIL;
	}

	TC_PRINT("SPI transceived: %s\n", rbuf);
50000548:	51000537          	lui	a0,0x51000
5000054c:	99490593          	addi	a1,s2,-1644
50000550:	21450513          	addi	a0,a0,532 # 51000214 <__devconfig_end+0x1d8>
50000554:	068010ef          	jal	500015bc <printk>

	if (!strcmp(wbuf, rbuf)) {
50000558:	99490593          	addi	a1,s2,-1644
5000055c:	18448513          	addi	a0,s1,388
50000560:	174000ef          	jal	500006d4 <strcmp>
	struct device *spi_dev = device_get_binding(SPI_DEV_NAME);
	u32_t len = strlen(wbuf);

	if (!spi_dev) {
		TC_PRINT("Cannot get SPI device\n");
		return TC_FAIL;
50000564:	00a03533          	snez	a0,a0
	if (!strcmp(wbuf, rbuf)) {
		return TC_PASS;
	} else {
		return TC_FAIL;
	}
}
50000568:	01c12083          	lw	ra,28(sp)
5000056c:	01812403          	lw	s0,24(sp)
50000570:	01412483          	lw	s1,20(sp)
50000574:	01012903          	lw	s2,16(sp)
50000578:	00c12983          	lw	s3,12(sp)
5000057c:	02010113          	addi	sp,sp,32
50000580:	00008067          	ret

50000584 <test_spi_cpol>:

void test_spi_cpol(void)
{
	TC_PRINT("Test SPI_MODE_CPOL\n");
50000584:	51000537          	lui	a0,0x51000
		return TC_FAIL;
	}
}

void test_spi_cpol(void)
{
50000588:	ff010113          	addi	sp,sp,-16
	TC_PRINT("Test SPI_MODE_CPOL\n");
5000058c:	22c50513          	addi	a0,a0,556 # 5100022c <__devconfig_end+0x1f0>
		return TC_FAIL;
	}
}

void test_spi_cpol(void)
{
50000590:	00112623          	sw	ra,12(sp)
	TC_PRINT("Test SPI_MODE_CPOL\n");
50000594:	028010ef          	jal	500015bc <printk>
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPOL) == TC_PASS, NULL);
50000598:	08100513          	li	a0,129 # 81 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x1>
5000059c:	e89ff0ef          	jal	50000424 <test_spi>
#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline void _zassert(int cond, const char *msg, const char *default_msg,
			   const char *file, int line, const char *func)
{
	if (!(cond)) {
500005a0:	04050063          	beqz	a0,500005e0 <test_spi_cpol+0x5c>
		PRINT("\n    Assertion failed at %s:%d: %s: %s %s\n",
500005a4:	510007b7          	lui	a5,0x51000
500005a8:	51000737          	lui	a4,0x51000
500005ac:	510006b7          	lui	a3,0x51000
500005b0:	510005b7          	lui	a1,0x51000
500005b4:	51000537          	lui	a0,0x51000
500005b8:	24078793          	addi	a5,a5,576 # 51000240 <__devconfig_end+0x204>
500005bc:	79870713          	addi	a4,a4,1944 # 51000798 <_default_esf+0x290>
500005c0:	3d068693          	addi	a3,a3,976 # 510003d0 <__func__.2272>
500005c4:	05800613          	li	a2,88 # 58 <__NANO_ESF_lpcount0_OFFSET>
500005c8:	27c58593          	addi	a1,a1,636 # 5100027c <__devconfig_end+0x240>
500005cc:	2c050513          	addi	a0,a0,704 # 510002c0 <__devconfig_end+0x284>
500005d0:	7ed000ef          	jal	500015bc <printk>
}
500005d4:	00c12083          	lw	ra,12(sp)
500005d8:	01010113          	addi	sp,sp,16
		      file, line, func, msg, default_msg);
		ztest_test_fail();
500005dc:	0ac0106f          	j	50001688 <ztest_test_fail>
500005e0:	00c12083          	lw	ra,12(sp)
500005e4:	01010113          	addi	sp,sp,16
500005e8:	00008067          	ret

500005ec <test_spi_cpha>:

void test_spi_cpha(void)
{
	TC_PRINT("Test SPI_MODE_CPHA\n");
500005ec:	51000537          	lui	a0,0x51000
	TC_PRINT("Test SPI_MODE_CPOL\n");
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPOL) == TC_PASS, NULL);
}

void test_spi_cpha(void)
{
500005f0:	ff010113          	addi	sp,sp,-16
	TC_PRINT("Test SPI_MODE_CPHA\n");
500005f4:	2ec50513          	addi	a0,a0,748 # 510002ec <__devconfig_end+0x2b0>
	TC_PRINT("Test SPI_MODE_CPOL\n");
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPOL) == TC_PASS, NULL);
}

void test_spi_cpha(void)
{
500005f8:	00112623          	sw	ra,12(sp)
	TC_PRINT("Test SPI_MODE_CPHA\n");
500005fc:	7c1000ef          	jal	500015bc <printk>
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPHA) == TC_PASS, NULL);
50000600:	08200513          	li	a0,130 # 82 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x2>
50000604:	e21ff0ef          	jal	50000424 <test_spi>
#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline void _zassert(int cond, const char *msg, const char *default_msg,
			   const char *file, int line, const char *func)
{
	if (!(cond)) {
50000608:	04050063          	beqz	a0,50000648 <test_spi_cpha+0x5c>
		PRINT("\n    Assertion failed at %s:%d: %s: %s %s\n",
5000060c:	510007b7          	lui	a5,0x51000
50000610:	51000737          	lui	a4,0x51000
50000614:	510006b7          	lui	a3,0x51000
50000618:	510005b7          	lui	a1,0x51000
5000061c:	51000537          	lui	a0,0x51000
50000620:	30078793          	addi	a5,a5,768 # 51000300 <__devconfig_end+0x2c4>
50000624:	79870713          	addi	a4,a4,1944 # 51000798 <_default_esf+0x290>
50000628:	3c068693          	addi	a3,a3,960 # 510003c0 <__func__.2276>
5000062c:	05e00613          	li	a2,94 # 5e <__NANO_ESF_lpstart1_OFFSET+0x2>
50000630:	27c58593          	addi	a1,a1,636 # 5100027c <__devconfig_end+0x240>
50000634:	2c050513          	addi	a0,a0,704 # 510002c0 <__devconfig_end+0x284>
50000638:	785000ef          	jal	500015bc <printk>
}
5000063c:	00c12083          	lw	ra,12(sp)
50000640:	01010113          	addi	sp,sp,16
		      file, line, func, msg, default_msg);
		ztest_test_fail();
50000644:	0440106f          	j	50001688 <ztest_test_fail>
50000648:	00c12083          	lw	ra,12(sp)
5000064c:	01010113          	addi	sp,sp,16
50000650:	00008067          	ret

50000654 <test_spi_cpol_cpha>:

void test_spi_cpol_cpha(void)
{
	TC_PRINT("Test SPI_MODE_CPOL | SPI_MODE_CPHA\n");
50000654:	51000537          	lui	a0,0x51000
	TC_PRINT("Test SPI_MODE_CPHA\n");
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPHA) == TC_PASS, NULL);
}

void test_spi_cpol_cpha(void)
{
50000658:	ff010113          	addi	sp,sp,-16
	TC_PRINT("Test SPI_MODE_CPOL | SPI_MODE_CPHA\n");
5000065c:	33c50513          	addi	a0,a0,828 # 5100033c <__devconfig_end+0x300>
	TC_PRINT("Test SPI_MODE_CPHA\n");
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPHA) == TC_PASS, NULL);
}

void test_spi_cpol_cpha(void)
{
50000660:	00112623          	sw	ra,12(sp)
	TC_PRINT("Test SPI_MODE_CPOL | SPI_MODE_CPHA\n");
50000664:	759000ef          	jal	500015bc <printk>
	zassert_true(test_spi(SPI_WORD(8) | SPI_MODE_CPOL | SPI_MODE_CPHA)
50000668:	08300513          	li	a0,131 # 83 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x3>
5000066c:	db9ff0ef          	jal	50000424 <test_spi>
#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline void _zassert(int cond, const char *msg, const char *default_msg,
			   const char *file, int line, const char *func)
{
	if (!(cond)) {
50000670:	04050063          	beqz	a0,500006b0 <test_spi_cpol_cpha+0x5c>
		PRINT("\n    Assertion failed at %s:%d: %s: %s %s\n",
50000674:	510007b7          	lui	a5,0x51000
50000678:	51000737          	lui	a4,0x51000
5000067c:	510006b7          	lui	a3,0x51000
50000680:	510005b7          	lui	a1,0x51000
50000684:	51000537          	lui	a0,0x51000
50000688:	36078793          	addi	a5,a5,864 # 51000360 <__devconfig_end+0x324>
5000068c:	79870713          	addi	a4,a4,1944 # 51000798 <_default_esf+0x290>
50000690:	3ac68693          	addi	a3,a3,940 # 510003ac <__func__.2280>
50000694:	06500613          	li	a2,101 # 65 <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0x1>
50000698:	27c58593          	addi	a1,a1,636 # 5100027c <__devconfig_end+0x240>
5000069c:	2c050513          	addi	a0,a0,704 # 510002c0 <__devconfig_end+0x284>
500006a0:	71d000ef          	jal	500015bc <printk>
					== TC_PASS, NULL);
}
500006a4:	00c12083          	lw	ra,12(sp)
500006a8:	01010113          	addi	sp,sp,16
		      file, line, func, msg, default_msg);
		ztest_test_fail();
500006ac:	7dd0006f          	j	50001688 <ztest_test_fail>
500006b0:	00c12083          	lw	ra,12(sp)
500006b4:	01010113          	addi	sp,sp,16
500006b8:	00008067          	ret

500006bc <strlen>:
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
500006bc:	00050713          	mv	a4,a0
500006c0:	00050793          	mv	a5,a0
500006c4:	40e78533          	sub	a0,a5,a4
500006c8:	0017c68b          	p.lbu	a3,1(a5!)
500006cc:	fe069ce3          	bnez	a3,500006c4 <strlen+0x8>
500006d0:	00008067          	ret

500006d4 <strcmp>:
500006d4:	0015478b          	p.lbu	a5,1(a0!)
500006d8:	0015c70b          	p.lbu	a4,1(a1!)
500006dc:	00e79663          	bne	a5,a4,500006e8 <strcmp+0x14>
500006e0:	fe079ae3          	bnez	a5,500006d4 <strcmp>
500006e4:	00078713          	mv	a4,a5
500006e8:	40e78533          	sub	a0,a5,a4
500006ec:	00008067          	ret

500006f0 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
500006f0:	0ff5f693          	andi	a3,a1,255

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
500006f4:	00050793          	mv	a5,a0
500006f8:	00160713          	addi	a4,a2,1
	unsigned char c_byte = (unsigned char)c;

	while (((unsigned int)d_byte) & 0x3) {
500006fc:	fa27b833          	p.bclr	a6,a5,29,2
50000700:	00080e63          	beqz	a6,5000071c <memset+0x2c>
50000704:	fff70713          	addi	a4,a4,-1
50000708:	00071463          	bnez	a4,50000710 <memset+0x20>
5000070c:	00008067          	ret
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
50000710:	00d780ab          	p.sb	a3,1(a5!)
		n--;
50000714:	fff60613          	addi	a2,a2,-1
50000718:	fe5ff06f          	j	500006fc <memset+0xc>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
5000071c:	ee85b5b3          	p.bclr	a1,a1,23,8

	c_word |= c_word << 8;
50000720:	00859713          	slli	a4,a1,0x8
50000724:	00e5e5b3          	or	a1,a1,a4
	c_word |= c_word << 16;
50000728:	01059713          	slli	a4,a1,0x10
5000072c:	00e5e5b3          	or	a1,a1,a4

	while (n >= sizeof(unsigned int)) {
50000730:	00265713          	srli	a4,a2,0x2
50000734:	00078813          	mv	a6,a5
50000738:	00170713          	addi	a4,a4,1
5000073c:	fff70713          	addi	a4,a4,-1
50000740:	02071063          	bnez	a4,50000760 <memset+0x70>
50000744:	00265713          	srli	a4,a2,0x2
50000748:	00271593          	slli	a1,a4,0x2
5000074c:	00b787b3          	add	a5,a5,a1
50000750:	ffc00593          	li	a1,-4 # fffffffc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffffd>
50000754:	42b70633          	p.mac	a2,a4,a1
50000758:	00160613          	addi	a2,a2,1
5000075c:	0100006f          	j	5000076c <memset+0x7c>
		*(d_word++) = c_word;
50000760:	00b8222b          	p.sw	a1,4(a6!)
50000764:	fd9ff06f          	j	5000073c <memset+0x4c>
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
		*(d_byte++) = c_byte;
50000768:	00d780ab          	p.sb	a3,1(a5!)
5000076c:	fff60613          	addi	a2,a2,-1
50000770:	fe061ce3          	bnez	a2,50000768 <memset+0x78>
		n--;
	}

	return buf;
}
50000774:	00008067          	ret

50000778 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
50000778:	ff010113          	addi	sp,sp,-16
5000077c:	00812423          	sw	s0,8(sp)
50000780:	51001437          	lui	s0,0x51001
50000784:	00912223          	sw	s1,4(sp)
50000788:	00112623          	sw	ra,12(sp)
5000078c:	00050493          	mv	s1,a0
50000790:	97040413          	addi	s0,s0,-1680 # 51000970 <__bss_start>
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
50000794:	00a53c63          	p.bneimm	a0,10,500007ac <console_out+0x34>
		uart_poll_out(uart_console_dev, '\r');
50000798:	00042503          	lw	a0,0(s0)
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
5000079c:	00d00593          	li	a1,13 # d <_DEVICE_STRUCT_SIZE+0x1>
500007a0:	00452783          	lw	a5,4(a0)
500007a4:	0047a783          	lw	a5,4(a5)
500007a8:	000780e7          	jalr	a5
	}
	uart_poll_out(uart_console_dev, c);
500007ac:	00042503          	lw	a0,0(s0)
500007b0:	0ff4f593          	andi	a1,s1,255
500007b4:	00452783          	lw	a5,4(a0)
500007b8:	0047a783          	lw	a5,4(a5)
500007bc:	000780e7          	jalr	a5

	return c;
}
500007c0:	00c12083          	lw	ra,12(sp)
500007c4:	00048513          	mv	a0,s1
500007c8:	00812403          	lw	s0,8(sp)
500007cc:	00412483          	lw	s1,4(sp)
500007d0:	01010113          	addi	sp,sp,16
500007d4:	00008067          	ret

500007d8 <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
500007d8:	50000537          	lui	a0,0x50000
500007dc:	77850513          	addi	a0,a0,1912 # 50000778 <console_out>
500007e0:	20d0006f          	j	500011ec <__printk_hook_install>

500007e4 <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500007e4:	51000537          	lui	a0,0x51000
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
500007e8:	ff010113          	addi	sp,sp,-16

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500007ec:	3e050513          	addi	a0,a0,992 # 510003e0 <__func__.2272+0x10>
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
500007f0:	00112623          	sw	ra,12(sp)

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
500007f4:	45c010ef          	jal	50001c50 <device_get_binding>
500007f8:	510017b7          	lui	a5,0x51001
500007fc:	96a7a823          	sw	a0,-1680(a5) # 51000970 <__bss_start>
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
50000800:	fd9ff0ef          	jal	500007d8 <uart_console_hook_install>

	return 0;
}
50000804:	00c12083          	lw	ra,12(sp)
50000808:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
5000080c:	01010113          	addi	sp,sp,16
50000810:	00008067          	ret

50000814 <uart_ns16550_init>:
 *
 * @return 0 if successful, failed otherwise
 */
static int uart_ns16550_init(struct device *dev)
{
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
50000814:	00852883          	lw	a7,8(a0)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50000818:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
5000081c:	30073773          	csrrc	a4,mstatus,a4
	dev_data->iir_cache = 0;
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
50000820:	0048a603          	lw	a2,4(a7)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50000824:	fc173733          	p.bclr	a4,a4,30,1
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
50000828:	06060a63          	beqz	a2,5000089c <uart_ns16550_init+0x88>
}
#endif

static void set_baud_rate(struct device *dev, u32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
5000082c:	00052783          	lw	a5,0(a0)
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
50000830:	0087a783          	lw	a5,8(a5)
50000834:	0007a783          	lw	a5,0(a5)
50000838:	06078263          	beqz	a5,5000089c <uart_ns16550_init+0x88>
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
5000083c:	02c7d7b3          	divu	a5,a5,a2
#endif

static void set_baud_rate(struct device *dev, u32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
50000840:	00852303          	lw	t1,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000844:	00032683          	lw	a3,0(t1)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000848:	f8000e13          	li	t3,-128 # ffffff80 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffff81>
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
5000084c:	00c68693          	addi	a3,a3,12
50000850:	0006c583          	lbu	a1,0(a3)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000854:	01c68023          	sb	t3,0(a3)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
50000858:	0ff5f593          	andi	a1,a1,255
	u32_t divisor; /* baud rate divisor */
	u8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
5000085c:	0047d813          	srli	a6,a5,0x4

		/* set the DLAB to access the baud rate divisor registers */
		lcr_cache = INBYTE(LCR(dev));
		OUTBYTE(LCR(dev), LCR_DLAB);
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
50000860:	0ff87693          	andi	a3,a6,255
50000864:	00852803          	lw	a6,8(a0)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
50000868:	00082803          	lw	a6,0(a6)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
5000086c:	00c7d793          	srli	a5,a5,0xc
50000870:	00d80023          	sb	a3,0(a6)
50000874:	00852683          	lw	a3,8(a0)
50000878:	0006a683          	lw	a3,0(a3)
5000087c:	0ff7f793          	andi	a5,a5,255
50000880:	00468693          	addi	a3,a3,4
50000884:	00f68023          	sb	a5,0(a3)

		/* restore the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), lcr_cache);
50000888:	00852783          	lw	a5,8(a0)
5000088c:	0007a783          	lw	a5,0(a5)
50000890:	00c78793          	addi	a5,a5,12
50000894:	00b78023          	sb	a1,0(a5)

		dev_data->baud_rate = baud_rate;
50000898:	00c32223          	sw	a2,4(t1)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
5000089c:	00852783          	lw	a5,8(a0)
500008a0:	0007a783          	lw	a5,0(a5)
500008a4:	00300693          	li	a3,3 # 3 <CONFIG_ARCH+0x2>
500008a8:	00c78793          	addi	a5,a5,12
500008ac:	00d78023          	sb	a3,0(a5)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
500008b0:	0088c783          	lbu	a5,8(a7)
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
500008b4:	00b00693          	li	a3,11 # b <___thread_base_t_sched_locked_OFFSET>
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
500008b8:	fc17b7b3          	p.bclr	a5,a5,30,1
500008bc:	00078463          	beqz	a5,500008c4 <uart_ns16550_init+0xb0>
		mdc |= MCR_AFCE;
500008c0:	02b00693          	li	a3,43 # 2b <CONFIG_KERNEL_INIT_PRIORITY_DEFAULT+0x3>

	OUTBYTE(MDC(dev), mdc);
500008c4:	00852783          	lw	a5,8(a0)
500008c8:	0007a783          	lw	a5,0(a5)
500008cc:	01078793          	addi	a5,a5,16
500008d0:	00d78023          	sb	a3,0(a5)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
500008d4:	00852783          	lw	a5,8(a0)
500008d8:	0007a783          	lw	a5,0(a5)
500008dc:	fa700693          	li	a3,-89 # ffffffa7 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffa8>
500008e0:	00878793          	addi	a5,a5,8
500008e4:	00d78023          	sb	a3,0(a5)
		| FCR_FIFO_64
#endif
		);

	/* clear the port */
	INBYTE(RDR(dev));
500008e8:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
500008ec:	00052783          	lw	a5,0(a0)
500008f0:	0047868b          	p.lb	a3,4(a5!)
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
500008f4:	00078023          	sb	zero,0(a5)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500008f8:	30072773          	csrrs	a4,mstatus,a4
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
}
500008fc:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000900:	00008067          	ret

50000904 <uart_ns16550_poll_in>:
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
50000904:	00852503          	lw	a0,8(a0)
50000908:	00052703          	lw	a4,0(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
5000090c:	01470793          	addi	a5,a4,20
50000910:	0007c783          	lbu	a5,0(a5)
50000914:	fc17b7b3          	p.bclr	a5,a5,30,1
50000918:	00078a63          	beqz	a5,5000092c <uart_ns16550_poll_in+0x28>
5000091c:	00074783          	lbu	a5,0(a4)
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));

	return 0;
50000920:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
50000924:	00f58023          	sb	a5,0(a1)

	return 0;
50000928:	00008067          	ret
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
		return (-1);
5000092c:	fff00513          	li	a0,-1

	/* got a character */
	*c = INBYTE(RDR(dev));

	return 0;
}
50000930:	00008067          	ret

50000934 <uart_ns16550_poll_out>:
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
50000934:	00852503          	lw	a0,8(a0)
50000938:	00052703          	lw	a4,0(a0)
5000093c:	01470693          	addi	a3,a4,20
50000940:	0006c783          	lbu	a5,0(a3)
50000944:	0407f793          	andi	a5,a5,64
50000948:	fe078ce3          	beqz	a5,50000940 <uart_ns16550_poll_out+0xc>
}

static inline void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
5000094c:	00b70023          	sb	a1,0(a4)
		;

	OUTBYTE(THR(dev), c);

	return c;
}
50000950:	00058513          	mv	a0,a1
50000954:	00008067          	ret

50000958 <uart_ns16550_err_check>:
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
50000958:	00852503          	lw	a0,8(a0)
	*(volatile u32_t *)addr = data;
}

static inline u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
5000095c:	00052783          	lw	a5,0(a0)
50000960:	01478793          	addi	a5,a5,20
50000964:	0007c503          	lbu	a0,0(a5)
50000968:	01e57513          	andi	a0,a0,30
}
5000096c:	00155513          	srli	a0,a0,0x1
50000970:	00008067          	ret

50000974 <ppu_timer_irq_handler>:
static void ppu_timer_irq_handler(void *unused)
{
	ARG_UNUSED(unused);

	/* Reset counter */
	timer->val = 0;
50000974:	1a1037b7          	lui	a5,0x1a103
50000978:	0007a023          	sw	zero,0(a5) # 1a103000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17153f80>

	accumulated_cycle_count += sys_clock_hw_cycles_per_tick;
5000097c:	510017b7          	lui	a5,0x51001
50000980:	97478793          	addi	a5,a5,-1676 # 51000974 <accumulated_cycle_count>
50000984:	510016b7          	lui	a3,0x51001
50000988:	0007a703          	lw	a4,0(a5)
5000098c:	9686a683          	lw	a3,-1688(a3) # 51000968 <sys_clock_hw_cycles_per_tick>
50000990:	00d70733          	add	a4,a4,a3
50000994:	00e7a023          	sw	a4,0(a5)

	_sys_clock_tick_announce();
50000998:	510017b7          	lui	a5,0x51001
5000099c:	9647a503          	lw	a0,-1692(a5) # 51000964 <_sys_idle_elapsed_ticks>
500009a0:	36d0106f          	j	5000250c <_nano_sys_clock_tick_announce>

500009a4 <_sys_clock_driver_init>:
#ifdef CONFIG_TICKLESS_IDLE
#error "Tickless idle not yet implemented for ppu timer"
#endif

int _sys_clock_driver_init(struct device *device)
{
500009a4:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(device);
	IRQ_CONNECT(PPU_TIMER_A_CMP_IRQ, 0,
		    ppu_timer_irq_handler, NULL, 0);
	irq_enable(PPU_TIMER_A_CMP_IRQ);
500009a8:	01d00513          	li	a0,29 # 1d <__NANO_ESF_t4_OFFSET+0x1>
#ifdef CONFIG_TICKLESS_IDLE
#error "Tickless idle not yet implemented for ppu timer"
#endif

int _sys_clock_driver_init(struct device *device)
{
500009ac:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(device);
	IRQ_CONNECT(PPU_TIMER_A_CMP_IRQ, 0,
		    ppu_timer_irq_handler, NULL, 0);
	irq_enable(PPU_TIMER_A_CMP_IRQ);
500009b0:	6b5000ef          	jal	50001864 <_arch_irq_enable>
	/*
	 * Initialize timer.
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
500009b4:	1a1037b7          	lui	a5,0x1a103
500009b8:	0007a023          	sw	zero,0(a5) # 1a103000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17153f80>
	timer->cmp = sys_clock_hw_cycles_per_tick;
500009bc:	51001737          	lui	a4,0x51001
500009c0:	96872703          	lw	a4,-1688(a4) # 51000968 <sys_clock_hw_cycles_per_tick>
	timer->ctrl = TIMER_CTRL_EN;

	return 0;
}
500009c4:	00c12083          	lw	ra,12(sp)
	 * Initialize timer.
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
	timer->cmp = sys_clock_hw_cycles_per_tick;
500009c8:	00e7a423          	sw	a4,8(a5)
	timer->ctrl = TIMER_CTRL_EN;
500009cc:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>

	return 0;
}
500009d0:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
	 * Reset counter and set timer to generate interrupt
	 * every sys_clock_hw_cycles_per_tick
	 */
	timer->val = 0;
	timer->cmp = sys_clock_hw_cycles_per_tick;
	timer->ctrl = TIMER_CTRL_EN;
500009d4:	00e7a223          	sw	a4,4(a5)

	return 0;
}
500009d8:	01010113          	addi	sp,sp,16
500009dc:	00008067          	ret

500009e0 <spi_ppu_configure>:
}

static int spi_ppu_configure(struct device *dev, struct spi_config *config)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
500009e0:	00052783          	lw	a5,0(a0)
    k_sem_give(&data->device_sync_sem);
}

static int spi_ppu_configure(struct device *dev, struct spi_config *config)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
500009e4:	00852683          	lw	a3,8(a0)
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
500009e8:	0087a783          	lw	a5,8(a5)
500009ec:	0007a603          	lw	a2,0(a5)

    spi->clk_div = SPI_PPU_CLK_DIVIDER(config->max_sys_freq);   //set the clock divider
500009f0:	0045a783          	lw	a5,4(a1)
500009f4:	00179713          	slli	a4,a5,0x1
500009f8:	02faf7b7          	lui	a5,0x2faf
500009fc:	08078793          	addi	a5,a5,128 # 2faf080 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC>
50000a00:	02e7d7b3          	divu	a5,a5,a4
    data->dfs = SPI_WORD_SIZE_GET(config->config);

    return 0;
}
50000a04:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
static int spi_ppu_configure(struct device *dev, struct spi_config *config)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);

    spi->clk_div = SPI_PPU_CLK_DIVIDER(config->max_sys_freq);   //set the clock divider
50000a08:	fff78793          	addi	a5,a5,-1
50000a0c:	1007d7b3          	p.exthz	a5,a5
50000a10:	00f62223          	sw	a5,4(a2)
    data->dfs = SPI_WORD_SIZE_GET(config->config);
50000a14:	0005a783          	lw	a5,0(a1)
50000a18:	ce4797b3          	p.extractu	a5,a5,7,4
50000a1c:	00f6a823          	sw	a5,16(a3)

    return 0;
}
50000a20:	00008067          	ret

50000a24 <spi_ppu_transceive>:
}

static int spi_ppu_transceive(struct device *dev,
                      const void *tx_buf, u32_t tx_buf_len,
                      void *rx_buf, u32_t rx_buf_len)
{
50000a24:	fd010113          	addi	sp,sp,-48
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
    
    if(!tx_buf_len && !rx_buf_len) {
50000a28:	04061063          	bnez	a2,50000a68 <spi_ppu_transceive+0x44>
        return -1;
50000a2c:	fff00793          	li	a5,-1
                      void *rx_buf, u32_t rx_buf_len)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
    
    if(!tx_buf_len && !rx_buf_len) {
50000a30:	32070a63          	beqz	a4,50000d64 <spi_ppu_transceive+0x340>
}

static void spi_ppu_recieve(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000a34:	00052783          	lw	a5,0(a0)

    volatile int reg_data = 0;
50000a38:	00012c23          	sw	zero,24(sp)
}

static void spi_ppu_recieve(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000a3c:	0087a783          	lw	a5,8(a5)
50000a40:	0007a783          	lw	a5,0(a5)

    volatile int reg_data = 0;
    volatile int datalen = 0;
50000a44:	00012e23          	sw	zero,28(sp)
    volatile int num_words = 0;
50000a48:	02012023          	sw	zero,32(sp)
    volatile int i = 0;
50000a4c:	02012223          	sw	zero,36(sp)

    reg_data = spi->spi_len;
50000a50:	0107a683          	lw	a3,16(a5)
    }
}

static void spi_ppu_recieve(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
50000a54:	00852703          	lw	a4,8(a0)
    volatile int reg_data = 0;
    volatile int datalen = 0;
    volatile int num_words = 0;
    volatile int i = 0;

    reg_data = spi->spi_len;
50000a58:	00d12c23          	sw	a3,24(sp)

    if(data->rx_len && data->rx_buf)
50000a5c:	02072683          	lw	a3,32(a4)
50000a60:	22069e63          	bnez	a3,50000c9c <spi_ppu_transceive+0x278>
50000a64:	2fc0006f          	j	50000d60 <spi_ppu_transceive+0x33c>
}

static void spi_ppu_transmit(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000a68:	00052783          	lw	a5,0(a0)

    volatile int reg_data = 0;
50000a6c:	00012423          	sw	zero,8(sp)
}

static void spi_ppu_transmit(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000a70:	0087a783          	lw	a5,8(a5)
50000a74:	0007a783          	lw	a5,0(a5)

    volatile int reg_data = 0;
    volatile int datalen = 0;
50000a78:	00012623          	sw	zero,12(sp)
    return 0;
}

static void spi_ppu_transmit(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
50000a7c:	00852683          	lw	a3,8(a0)
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);

    volatile int reg_data = 0;
    volatile int datalen = 0;
    volatile int num_words = 0;
50000a80:	00012823          	sw	zero,16(sp)
    volatile int i = 0;
    volatile unsigned char prime_addr[8] = {0};

    //when spi_write() or spi_transcieve(), put the first 8 byte data to cmd and addr registers to send out,
    //so that the csn will not go back up between cmd, addr, and data.
    while(data->tx_len && (i < 64)) {
50000a84:	03f00e93          	li	t4,63 # 3f <CONFIG_UART_CONSOLE_INIT_PRIORITY+0x3>
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);

    volatile int reg_data = 0;
    volatile int datalen = 0;
    volatile int num_words = 0;
    volatile int i = 0;
50000a88:	00012a23          	sw	zero,20(sp)
    volatile unsigned char prime_addr[8] = {0};
50000a8c:	02012423          	sw	zero,40(sp)
50000a90:	02012623          	sw	zero,44(sp)

    //when spi_write() or spi_transcieve(), put the first 8 byte data to cmd and addr registers to send out,
    //so that the csn will not go back up between cmd, addr, and data.
    while(data->tx_len && (i < 64)) {
50000a94:	0186a603          	lw	a2,24(a3)
50000a98:	06060463          	beqz	a2,50000b00 <spi_ppu_transceive+0xdc>
50000a9c:	01412583          	lw	a1,20(sp)
50000aa0:	06bec063          	blt	t4,a1,50000b00 <spi_ppu_transceive+0xdc>

        int temp = data->dfs;
50000aa4:	0106a803          	lw	a6,16(a3)
50000aa8:	00080313          	mv	t1,a6
50000aac:	00180893          	addi	a7,a6,1
50000ab0:	fff88893          	addi	a7,a7,-1
50000ab4:	00089e63          	bnez	a7,50000ad0 <spi_ppu_transceive+0xac>
        while(temp) {
            prime_addr[i + temp - 1] = (*(u8_t *)(data->tx_buf++));
            temp--;
        }
        i += data->dfs;
50000ab8:	01412583          	lw	a1,20(sp)
50000abc:	010585b3          	add	a1,a1,a6
        
        if(data->tx_len-- == 0) {                   //clear tx_len
50000ac0:	fff60613          	addi	a2,a2,-1
        int temp = data->dfs;
        while(temp) {
            prime_addr[i + temp - 1] = (*(u8_t *)(data->tx_buf++));
            temp--;
        }
        i += data->dfs;
50000ac4:	00b12a23          	sw	a1,20(sp)
        
        if(data->tx_len-- == 0) {                   //clear tx_len
50000ac8:	00c6ac23          	sw	a2,24(a3)
50000acc:	fc9ff06f          	j	50000a94 <spi_ppu_transceive+0x70>
    //so that the csn will not go back up between cmd, addr, and data.
    while(data->tx_len && (i < 64)) {

        int temp = data->dfs;
        while(temp) {
            prime_addr[i + temp - 1] = (*(u8_t *)(data->tx_buf++));
50000ad0:	0146ae03          	lw	t3,20(a3)
50000ad4:	001e0f13          	addi	t5,t3,1
50000ad8:	01412583          	lw	a1,20(sp)
50000adc:	006585b3          	add	a1,a1,t1
50000ae0:	01e6aa23          	sw	t5,20(a3)
50000ae4:	fff58593          	addi	a1,a1,-1
50000ae8:	000e4e03          	lbu	t3,0(t3)
50000aec:	03010f13          	addi	t5,sp,48
50000af0:	00bf05b3          	add	a1,t5,a1
50000af4:	ffc58c23          	sb	t3,-8(a1)
            temp--;
50000af8:	fff30313          	addi	t1,t1,-1
50000afc:	fb5ff06f          	j	50000ab0 <spi_ppu_transceive+0x8c>
            data->tx_buf = NULL;
        }
    }

    //set the command register and address register
    spi->spi_cmd = ((prime_addr[0] & 0xFF) << 24) | ((prime_addr[1] & 0xFF) << 16) | ((prime_addr[2] & 0xFF) << 8) | (prime_addr[3] & 0xFF);
50000b00:	02814e03          	lbu	t3,40(sp)
50000b04:	02914883          	lbu	a7,41(sp)
50000b08:	02a14803          	lbu	a6,42(sp)
50000b0c:	02b14583          	lbu	a1,43(sp)
50000b10:	0ff8f893          	andi	a7,a7,255
50000b14:	0ff5f313          	andi	t1,a1,255
50000b18:	01089893          	slli	a7,a7,0x10
50000b1c:	018e1593          	slli	a1,t3,0x18
50000b20:	0115e5b3          	or	a1,a1,a7
50000b24:	0ff87813          	andi	a6,a6,255
50000b28:	0065e5b3          	or	a1,a1,t1
50000b2c:	00881813          	slli	a6,a6,0x8
50000b30:	0105e5b3          	or	a1,a1,a6
50000b34:	00b7a423          	sw	a1,8(a5)
    spi->spi_adr = ((prime_addr[4] & 0xFF) << 24) | ((prime_addr[5] & 0xFF) << 16) | ((prime_addr[6] & 0xFF) << 8) | (prime_addr[7] & 0xFF);
50000b38:	02c14e03          	lbu	t3,44(sp)
50000b3c:	02d14883          	lbu	a7,45(sp)
50000b40:	02e14803          	lbu	a6,46(sp)
50000b44:	02f14583          	lbu	a1,47(sp)
50000b48:	0ff8f893          	andi	a7,a7,255
50000b4c:	0ff5f313          	andi	t1,a1,255
50000b50:	01089893          	slli	a7,a7,0x10
50000b54:	018e1593          	slli	a1,t3,0x18
50000b58:	0ff87813          	andi	a6,a6,255
50000b5c:	0115e5b3          	or	a1,a1,a7
50000b60:	00881813          	slli	a6,a6,0x8
50000b64:	0065e5b3          	or	a1,a1,t1
50000b68:	0105e5b3          	or	a1,a1,a6
50000b6c:	00b7a623          	sw	a1,12(a5)

    if(i <= 32) {                                                 //if i <= 32, put the data in cmd register
50000b70:	01412803          	lw	a6,20(sp)
50000b74:	02000593          	li	a1,32 # 20 <CONFIG_NUM_IRQS>
50000b78:	0105c663          	blt	a1,a6,50000b84 <spi_ppu_transceive+0x160>
        spi->spi_len = i;
50000b7c:	01412583          	lw	a1,20(sp)
50000b80:	0200006f          	j	50000ba0 <spi_ppu_transceive+0x17c>
    } else {
        spi->spi_len = 0x20 | (((i - 32) << 8) & 0x3F00);   //if 32<=i<=64, put low 4 byte data in cmd register, high 4 byte or less data in addr register
50000b84:	01412583          	lw	a1,20(sp)
50000b88:	fe058593          	addi	a1,a1,-32
50000b8c:	00859813          	slli	a6,a1,0x8
50000b90:	000045b7          	lui	a1,0x4
50000b94:	f0058593          	addi	a1,a1,-256 # 3f00 <CONFIG_ISR_STACK_SIZE+0x3700>
50000b98:	00b875b3          	and	a1,a6,a1
50000b9c:	c055c5b3          	p.bset	a1,a1,0,5
50000ba0:	00b7a823          	sw	a1,16(a5)
    }
    spi->spi_dum = 0x00;                                         //set the dummy cycles to 0 initially
50000ba4:	0007aa23          	sw	zero,20(a5)


    //if data waiting to send out is less than 8 byte, or there is no need to wait to recieve data after that, start transaction here.
    if((!data->tx_len) && (!data->rx_len)) {
50000ba8:	02061263          	bnez	a2,50000bcc <spi_ppu_transceive+0x1a8>
50000bac:	0206a683          	lw	a3,32(a3)
50000bb0:	0e069263          	bnez	a3,50000c94 <spi_ppu_transceive+0x270>
        spi->status = SPI_START_TRANSACTION(SPI_CMD_WR, SPI_CSN0);
50000bb4:	10200693          	li	a3,258 # 102 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x82>
50000bb8:	00d7a023          	sw	a3,0(a5)
        while((spi->status & 0xFFFF) != 1);
50000bbc:	0007a683          	lw	a3,0(a5)
50000bc0:	df06b6b3          	p.bclr	a3,a3,15,16
50000bc4:	fe16bce3          	p.bneimm	a3,1,50000bbc <spi_ppu_transceive+0x198>
50000bc8:	0cc0006f          	j	50000c94 <spi_ppu_transceive+0x270>
        return;
    }

    if(data->tx_len)
    {
        reg_data = spi->spi_len;
50000bcc:	0107a583          	lw	a1,16(a5)
50000bd0:	00b12423          	sw	a1,8(sp)
        datalen = data->tx_len * data->dfs;
50000bd4:	0106a583          	lw	a1,16(a3)
50000bd8:	02b60633          	mul	a2,a2,a1
50000bdc:	00c12623          	sw	a2,12(sp)
        spi->spi_len = ((datalen << 16) & 0xFFFF0000) | (reg_data & 0xFFFF);  //set data length
50000be0:	00c12583          	lw	a1,12(sp)
50000be4:	00812603          	lw	a2,8(sp)
50000be8:	01059593          	slli	a1,a1,0x10
50000bec:	10065633          	p.exthz	a2,a2
50000bf0:	00c5e633          	or	a2,a1,a2
50000bf4:	00c7a823          	sw	a2,16(a5)
 
        num_words = (datalen >> 5) & 0x7FF;
50000bf8:	00c12603          	lw	a2,12(sp)
50000bfc:	40565613          	srai	a2,a2,0x5
50000c00:	e8b63633          	p.bclr	a2,a2,20,11
50000c04:	00c12823          	sw	a2,16(sp)
        if((datalen & 0x1F) != 0)
50000c08:	00c12603          	lw	a2,12(sp)
50000c0c:	f4563633          	p.bclr	a2,a2,26,5
50000c10:	00060863          	beqz	a2,50000c20 <spi_ppu_transceive+0x1fc>
            num_words++;
50000c14:	01012603          	lw	a2,16(sp)
50000c18:	00160613          	addi	a2,a2,1
50000c1c:	00c12823          	sw	a2,16(sp)

        volatile int *tx_data = (volatile int *)(data->tx_buf);           //get the data buffer
        spi->status = SPI_START_TRANSACTION(SPI_CMD_WR, SPI_CSN0);            //start transaction
50000c20:	10200613          	li	a2,258 # 102 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x82>
 
        num_words = (datalen >> 5) & 0x7FF;
        if((datalen & 0x1F) != 0)
            num_words++;

        volatile int *tx_data = (volatile int *)(data->tx_buf);           //get the data buffer
50000c24:	0146a803          	lw	a6,20(a3)
        spi->status = SPI_START_TRANSACTION(SPI_CMD_WR, SPI_CSN0);            //start transaction

        for(i = 0; i < num_words; i++) {
            while(((spi->status >> 24) & 0xFF) >= 8);
50000c28:	00700893          	li	a7,7 # 7 <__NANO_ESF_gp_OFFSET+0x3>
        num_words = (datalen >> 5) & 0x7FF;
        if((datalen & 0x1F) != 0)
            num_words++;

        volatile int *tx_data = (volatile int *)(data->tx_buf);           //get the data buffer
        spi->status = SPI_START_TRANSACTION(SPI_CMD_WR, SPI_CSN0);            //start transaction
50000c2c:	00c7a023          	sw	a2,0(a5)

        for(i = 0; i < num_words; i++) {
50000c30:	00012a23          	sw	zero,20(sp)
50000c34:	03010613          	addi	a2,sp,48
50000c38:	01412583          	lw	a1,20(sp)
50000c3c:	fe062603          	lw	a2,-32(a2)
50000c40:	02c5d863          	ble	a2,a1,50000c70 <spi_ppu_transceive+0x24c>
            while(((spi->status >> 24) & 0xFF) >= 8);
50000c44:	0007a603          	lw	a2,0(a5)
50000c48:	01865613          	srli	a2,a2,0x18
50000c4c:	fec8ece3          	bltu	a7,a2,50000c44 <spi_ppu_transceive+0x220>
            spi->tx_fifo = tx_data[i];                                        //fill the tx fifo
50000c50:	01412603          	lw	a2,20(sp)
50000c54:	00261613          	slli	a2,a2,0x2
50000c58:	20c87603          	p.lw	a2,a2(a6)
50000c5c:	00c7ac23          	sw	a2,24(a5)
            num_words++;

        volatile int *tx_data = (volatile int *)(data->tx_buf);           //get the data buffer
        spi->status = SPI_START_TRANSACTION(SPI_CMD_WR, SPI_CSN0);            //start transaction

        for(i = 0; i < num_words; i++) {
50000c60:	01412603          	lw	a2,20(sp)
50000c64:	00160613          	addi	a2,a2,1
50000c68:	00c12a23          	sw	a2,20(sp)
50000c6c:	fc9ff06f          	j	50000c34 <spi_ppu_transceive+0x210>
            while(((spi->status >> 24) & 0xFF) >= 8);
            spi->tx_fifo = tx_data[i];                                        //fill the tx fifo
        }
        while((spi->status & 0xFFFF) != 1);
50000c70:	0007a603          	lw	a2,0(a5)
50000c74:	df063633          	p.bclr	a2,a2,15,16
50000c78:	fe163ce3          	p.bneimm	a2,1,50000c70 <spi_ppu_transceive+0x24c>

        spi->spi_cmd = 0x00;
50000c7c:	0007a423          	sw	zero,8(a5)
        spi->spi_adr = 0x00;
50000c80:	0007a623          	sw	zero,12(a5)
        spi->spi_len = 0x00;
50000c84:	0007a823          	sw	zero,16(a5)
        spi->spi_dum = 0x00;                                     //clear registers
50000c88:	0007aa23          	sw	zero,20(a5)
       
        data->tx_len = 0;
50000c8c:	0006ac23          	sw	zero,24(a3)
        data->tx_buf = NULL;
50000c90:	0006aa23          	sw	zero,20(a3)
    k_sem_take(&data->device_sync_sem, K_FOREVER);
#else
    if(tx_buf_len) {            //send data
        spi_ppu_transmit(dev);
    }
    if(rx_buf_len){             //recieve data
50000c94:	0c070663          	beqz	a4,50000d60 <spi_ppu_transceive+0x33c>
50000c98:	d9dff06f          	j	50000a34 <spi_ppu_transceive+0x10>
    volatile int num_words = 0;
    volatile int i = 0;

    reg_data = spi->spi_len;

    if(data->rx_len && data->rx_buf)
50000c9c:	01c72583          	lw	a1,28(a4)
50000ca0:	0c058063          	beqz	a1,50000d60 <spi_ppu_transceive+0x33c>
    {
        datalen = data->rx_len * data->dfs;
50000ca4:	01072603          	lw	a2,16(a4)
50000ca8:	02c686b3          	mul	a3,a3,a2
50000cac:	00d12e23          	sw	a3,28(sp)
        spi->spi_len = ((datalen << 16) & 0xFFFF0000) | (reg_data & 0xFFFF);
50000cb0:	03010693          	addi	a3,sp,48
50000cb4:	01c12603          	lw	a2,28(sp)
50000cb8:	fe86a683          	lw	a3,-24(a3)
50000cbc:	01061613          	slli	a2,a2,0x10
50000cc0:	1006d6b3          	p.exthz	a3,a3
50000cc4:	00d666b3          	or	a3,a2,a3
50000cc8:	00d7a823          	sw	a3,16(a5)

        num_words = (datalen >> 5) & 0x7FF;
50000ccc:	01c12683          	lw	a3,28(sp)
50000cd0:	4056d693          	srai	a3,a3,0x5
50000cd4:	e8b6b6b3          	p.bclr	a3,a3,20,11
50000cd8:	02d12023          	sw	a3,32(sp)
        if((datalen & 0x1F) != 0)
50000cdc:	01c12683          	lw	a3,28(sp)
50000ce0:	f456b6b3          	p.bclr	a3,a3,26,5
50000ce4:	00068863          	beqz	a3,50000cf4 <spi_ppu_transceive+0x2d0>
            num_words++;
50000ce8:	02012683          	lw	a3,32(sp)
50000cec:	00168693          	addi	a3,a3,1
50000cf0:	02d12023          	sw	a3,32(sp)

        volatile int *rx_data = (volatile int *)(data->rx_buf);
        spi->status = SPI_START_TRANSACTION(SPI_CMD_RD, SPI_CSN0);
50000cf4:	10100693          	li	a3,257 # 101 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x81>
50000cf8:	00d7a023          	sw	a3,0(a5)

        for(i = 0; i < num_words; i++) {
50000cfc:	02012223          	sw	zero,36(sp)
50000d00:	02412603          	lw	a2,36(sp)
50000d04:	02012683          	lw	a3,32(sp)
50000d08:	02d65a63          	ble	a3,a2,50000d3c <spi_ppu_transceive+0x318>
            while(((spi->status >> 16) & 0xFF) == 0);
50000d0c:	0007a683          	lw	a3,0(a5)
50000d10:	4106d693          	srai	a3,a3,0x10
50000d14:	ee86b6b3          	p.bclr	a3,a3,23,8
50000d18:	fe068ae3          	beqz	a3,50000d0c <spi_ppu_transceive+0x2e8>
            rx_data[i] = spi->rx_fifo;                 //get data from rx fifo                    
50000d1c:	02412683          	lw	a3,36(sp)
50000d20:	00269693          	slli	a3,a3,0x2
50000d24:	0207a603          	lw	a2,32(a5)
50000d28:	00c5e6a3          	p.sw	a2,a3(a1)
            num_words++;

        volatile int *rx_data = (volatile int *)(data->rx_buf);
        spi->status = SPI_START_TRANSACTION(SPI_CMD_RD, SPI_CSN0);

        for(i = 0; i < num_words; i++) {
50000d2c:	02412683          	lw	a3,36(sp)
50000d30:	00168693          	addi	a3,a3,1
50000d34:	02d12223          	sw	a3,36(sp)
50000d38:	fc9ff06f          	j	50000d00 <spi_ppu_transceive+0x2dc>
            while(((spi->status >> 16) & 0xFF) == 0);
            rx_data[i] = spi->rx_fifo;                 //get data from rx fifo                    
        }
        while((spi->status & 0xFFFF) != 1);
50000d3c:	0007a683          	lw	a3,0(a5)
50000d40:	df06b6b3          	p.bclr	a3,a3,15,16
50000d44:	fe16bce3          	p.bneimm	a3,1,50000d3c <spi_ppu_transceive+0x318>
            
        spi->spi_cmd = 0x00;
50000d48:	0007a423          	sw	zero,8(a5)
        spi->spi_adr = 0x00;
50000d4c:	0007a623          	sw	zero,12(a5)
        spi->spi_len = 0x00;
50000d50:	0007a823          	sw	zero,16(a5)
        spi->spi_dum = 0x00;
50000d54:	0007aa23          	sw	zero,20(a5)

        data->rx_len = 0;
50000d58:	02072023          	sw	zero,32(a4)
        data->rx_buf = NULL;
50000d5c:	00072e23          	sw	zero,28(a4)
    }
    if(rx_buf_len){             //recieve data
        spi_ppu_recieve(dev);
    }
#endif
    return 0; 
50000d60:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
}
50000d64:	00078513          	mv	a0,a5
50000d68:	03010113          	addi	sp,sp,48
50000d6c:	00008067          	ret

50000d70 <spi_ppu_init>:

#ifdef CONFIG_SPI_PPU_INTERRUPT
    cfg->irq_config();
#endif
    return 0;
}
50000d70:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000d74:	00008067          	ret

50000d78 <spi_ppu_irq_config_func_0>:
    IRQ_CONNECT(PPU_SPI_0_0_IRQ,
                CONFIG_SPI_0_IRQ_PRI,
                spi_ppu_isr,
                DEVICE_GET(spi_ppu_0),
                0);
    irq_enable(PPU_SPI_0_0_IRQ);
50000d78:	01a00513          	li	a0,26 # 1a <__NANO_ESF_t3_OFFSET+0x2>
50000d7c:	2e90006f          	j	50001864 <_arch_irq_enable>

50000d80 <spi_ppu_isr>:

static void spi_ppu_transmit(struct device *dev);
static void spi_ppu_recieve(struct device *dev);

static void spi_ppu_isr(struct device *dev)
{
50000d80:	00050793          	mv	a5,a0
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000d84:	0007a783          	lw	a5,0(a5)
static void spi_ppu_transmit(struct device *dev);
static void spi_ppu_recieve(struct device *dev);

static void spi_ppu_isr(struct device *dev)
{
    struct spi_ppu_data *data = DEV_SPI_DATA(dev);
50000d88:	00852503          	lw	a0,8(a0)
    volatile struct spi_ppu_t *spi = DEV_SPI(dev);
50000d8c:	0087a783          	lw	a5,8(a5)
50000d90:	0007a683          	lw	a3,0(a5)
    int status = 0;

    PPU_ICP |= 1 << 26; 
50000d94:	1a1047b7          	lui	a5,0x1a104
50000d98:	00c78793          	addi	a5,a5,12 # 1a10400c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f8c>
50000d9c:	0007a703          	lw	a4,0(a5)
50000da0:	c1a74733          	p.bset	a4,a4,0,26
50000da4:	00e7a023          	sw	a4,0(a5)
    status = spi->int_sta;
50000da8:	0286a683          	lw	a3,40(a3)

    k_sem_give(&data->device_sync_sem);
50000dac:	62c0106f          	j	500023d8 <k_sem_give>

50000db0 <gpio_ppu_irq_handler>:

static void gpio_ppu_irq_handler(void *arg)
{
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000db0:	00052783          	lw	a5,0(a0)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
50000db4:	ff010113          	addi	sp,sp,-16
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000db8:	0087a783          	lw	a5,8(a5)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
50000dbc:	00912223          	sw	s1,4(sp)
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000dc0:	0007a483          	lw	s1,0(a5)
50000dc4:	00852783          	lw	a5,8(a0)
	((volatile struct gpio_ppu_t *)(DEV_GPIO_CFG(dev))->gpio_base_addr)
#define DEV_GPIO_DATA(dev)					\
	((struct gpio_ppu_data *)(dev)->driver_data)

static void gpio_ppu_irq_handler(void *arg)
{
50000dc8:	00812423          	sw	s0,8(sp)
50000dcc:	0007a403          	lw	s0,0(a5)
50000dd0:	00112623          	sw	ra,12(sp)
50000dd4:	01212023          	sw	s2,0(sp)
	struct device *dev = (struct device *)arg;
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	_gpio_fire_callbacks(&data->cb, dev, gpio->intstatus);
50000dd8:	0184a483          	lw	s1,24(s1)
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
50000ddc:	02040863          	beqz	s0,50000e0c <gpio_ppu_irq_handler+0x5c>
50000de0:	00050913          	mv	s2,a0
		if (cb->pin_mask & pins) {
50000de4:	00842783          	lw	a5,8(s0)
50000de8:	00f4f7b3          	and	a5,s1,a5
50000dec:	00078c63          	beqz	a5,50000e04 <gpio_ppu_irq_handler+0x54>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
50000df0:	00442783          	lw	a5,4(s0)
50000df4:	00048613          	mv	a2,s1
50000df8:	00040593          	mv	a1,s0
50000dfc:	00090513          	mv	a0,s2
50000e00:	000780e7          	jalr	a5
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
50000e04:	00042403          	lw	s0,0(s0)
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
50000e08:	fc041ee3          	bnez	s0,50000de4 <gpio_ppu_irq_handler+0x34>
}
50000e0c:	00c12083          	lw	ra,12(sp)
50000e10:	00812403          	lw	s0,8(sp)
50000e14:	00412483          	lw	s1,4(sp)
50000e18:	00012903          	lw	s2,0(sp)
50000e1c:	01010113          	addi	sp,sp,16
50000e20:	00008067          	ret

50000e24 <gpio_ppu_config>:
static int gpio_ppu_config(struct device *dev,
			       int access_op,
			       u32_t pin,
			       int flags)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000e24:	00052783          	lw	a5,0(a0)
50000e28:	0087a783          	lw	a5,8(a5)
50000e2c:	0007a783          	lw	a5,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50000e30:	00058663          	beqz	a1,50000e3c <gpio_ppu_config+0x18>
		return -ENOTSUP;
50000e34:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
50000e38:	00008067          	ret

	if (pin > 31)
50000e3c:	01f00713          	li	a4,31 # 1f <CONFIG_KERNEL_INIT_PRIORITY_OBJECTS+0x1>
50000e40:	00c77663          	bleu	a2,a4,50000e4c <gpio_ppu_config+0x28>
		return -EINVAL;
50000e44:	fea00513          	li	a0,-22 # ffffffea <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffeb>
50000e48:	00008067          	ret
50000e4c:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>

	/* Configure pin as gpio */
//	PPU_PADMUX |= (PPU_PAD_GPIO << pin);

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
50000e50:	fc16b833          	p.bclr	a6,a3,30,1
		gpio->paddir |= BIT(pin);
50000e54:	0007a703          	lw	a4,0(a5)
50000e58:	00c595b3          	sll	a1,a1,a2

	/* Configure pin as gpio */
//	PPU_PADMUX |= (PPU_PAD_GPIO << pin);

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
50000e5c:	00080663          	beqz	a6,50000e68 <gpio_ppu_config+0x44>
		gpio->paddir |= BIT(pin);
50000e60:	00e5e5b3          	or	a1,a1,a4
50000e64:	00c0006f          	j	50000e70 <gpio_ppu_config+0x4c>
	else
		gpio->paddir &= ~BIT(pin);
50000e68:	fff5c593          	not	a1,a1
50000e6c:	00e5f5b3          	and	a1,a1,a4
	 * gpio.
	 * Interrupt for a gpio is:
	 * 1) enabled only via a call to gpio_ppu_enable_callback.
	 * 2) disabled only via a call to gpio_ppu_disabled_callback.
	 */
	if (!(flags & GPIO_INT))
50000e70:	0026f513          	andi	a0,a3,2

	/* Configure gpio direction */
	if (flags & GPIO_DIR_OUT)
		gpio->paddir |= BIT(pin);
	else
		gpio->paddir &= ~BIT(pin);
50000e74:	00b7a023          	sw	a1,0(a5)
	 * gpio.
	 * Interrupt for a gpio is:
	 * 1) enabled only via a call to gpio_ppu_enable_callback.
	 * 2) disabled only via a call to gpio_ppu_disabled_callback.
	 */
	if (!(flags & GPIO_INT))
50000e78:	06050c63          	beqz	a0,50000ef0 <gpio_ppu_config+0xcc>
		return 0;

	/*
	 * Interrupt cannot be set for GPIO_DIR_OUT
	 */
	if (flags & GPIO_DIR_OUT)
50000e7c:	fc0814e3          	bnez	a6,50000e44 <gpio_ppu_config+0x20>
		return -EINVAL;

	/* Double edge trigger not supported */
	if (flags & GPIO_INT_DOUBLE_EDGE)
50000e80:	0406f513          	andi	a0,a3,64
50000e84:	fa0518e3          	bnez	a0,50000e34 <gpio_ppu_config+0x10>
		return -ENOTSUP;

	/* Edge or Level triggered ? */
	if (flags & GPIO_INT_EDGE)
50000e88:	0206f713          	andi	a4,a3,32
50000e8c:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50000e90:	00070a63          	beqz	a4,50000ea4 <gpio_ppu_config+0x80>
		gpio->inttype1 |= BIT(pin);
50000e94:	0147a703          	lw	a4,20(a5)
50000e98:	00c595b3          	sll	a1,a1,a2
50000e9c:	00e5e5b3          	or	a1,a1,a4
50000ea0:	0140006f          	j	50000eb4 <gpio_ppu_config+0x90>
	else
		gpio->inttype1 &= ~BIT(pin);
50000ea4:	00c595b3          	sll	a1,a1,a2
50000ea8:	0147a703          	lw	a4,20(a5)
50000eac:	fff5c593          	not	a1,a1
50000eb0:	00e5f5b3          	and	a1,a1,a4

	/* Level High/Rising Edge ? */
	if (flags & GPIO_INT_ACTIVE_HIGH)
50000eb4:	0046f693          	andi	a3,a3,4

	/* Edge or Level triggered ? */
	if (flags & GPIO_INT_EDGE)
		gpio->inttype1 |= BIT(pin);
	else
		gpio->inttype1 &= ~BIT(pin);
50000eb8:	00b7aa23          	sw	a1,20(a5)
50000ebc:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>

	/* Level High/Rising Edge ? */
	if (flags & GPIO_INT_ACTIVE_HIGH)
50000ec0:	00068e63          	beqz	a3,50000edc <gpio_ppu_config+0xb8>
		gpio->inttype0 &= ~BIT(pin);
50000ec4:	00c71733          	sll	a4,a4,a2
50000ec8:	0107a683          	lw	a3,16(a5)
50000ecc:	fff74713          	not	a4,a4
50000ed0:	00d77733          	and	a4,a4,a3
50000ed4:	00e7a823          	sw	a4,16(a5)
50000ed8:	00008067          	ret
	else
		gpio->inttype0 |= BIT(pin);
50000edc:	0107a683          	lw	a3,16(a5)
50000ee0:	00c71733          	sll	a4,a4,a2
50000ee4:	00d76733          	or	a4,a4,a3
50000ee8:	00e7a823          	sw	a4,16(a5)

	return 0;
50000eec:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
}
50000ef0:	00008067          	ret

50000ef4 <gpio_ppu_write>:
static int gpio_ppu_write(struct device *dev,
			      int access_op,
			      u32_t pin,
			      u32_t value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000ef4:	00052703          	lw	a4,0(a0)
50000ef8:	00872703          	lw	a4,8(a4)
50000efc:	00072703          	lw	a4,0(a4)

	if (access_op != GPIO_ACCESS_BY_PIN)
50000f00:	02059c63          	bnez	a1,50000f38 <gpio_ppu_write+0x44>
50000f04:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
		return -ENOTSUP;

	if (value)
50000f08:	00068a63          	beqz	a3,50000f1c <gpio_ppu_write+0x28>
		gpio->padout |= BIT(pin);
50000f0c:	00872683          	lw	a3,8(a4)
50000f10:	00c797b3          	sll	a5,a5,a2
50000f14:	00d7e7b3          	or	a5,a5,a3
50000f18:	0140006f          	j	50000f2c <gpio_ppu_write+0x38>
	else
		gpio->padout &= ~BIT(pin);
50000f1c:	00c797b3          	sll	a5,a5,a2
50000f20:	00872683          	lw	a3,8(a4)
50000f24:	fff7c793          	not	a5,a5
50000f28:	00d7f7b3          	and	a5,a5,a3
50000f2c:	00f72423          	sw	a5,8(a4)

	return 0;
50000f30:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000f34:	00008067          	ret
			      u32_t value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
50000f38:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
		gpio->padout |= BIT(pin);
	else
		gpio->padout &= ~BIT(pin);

	return 0;
}
50000f3c:	00008067          	ret

50000f40 <gpio_ppu_read>:
static int gpio_ppu_read(struct device *dev,
			     int access_op,
			     u32_t pin,
			     u32_t *value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000f40:	00052783          	lw	a5,0(a0)
50000f44:	0087a783          	lw	a5,8(a5)
50000f48:	0007a783          	lw	a5,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50000f4c:	02059a63          	bnez	a1,50000f80 <gpio_ppu_read+0x40>
	/*
	 * If gpio is configured as output,
	 * read gpio value from padout register,
	 * otherwise read gpio value from padin register
	 */
	if (gpio->paddir & BIT(pin))
50000f50:	0007a703          	lw	a4,0(a5)
50000f54:	00c75733          	srl	a4,a4,a2
50000f58:	fc173733          	p.bclr	a4,a4,30,1
50000f5c:	00070663          	beqz	a4,50000f68 <gpio_ppu_read+0x28>
		*value = !!(gpio->padout & BIT(pin));
50000f60:	0087a783          	lw	a5,8(a5)
50000f64:	0080006f          	j	50000f6c <gpio_ppu_read+0x2c>
	else
		*value = !!(gpio->padin & BIT(pin));
50000f68:	0047a783          	lw	a5,4(a5)
50000f6c:	00c7d633          	srl	a2,a5,a2
50000f70:	fc163633          	p.bclr	a2,a2,30,1
50000f74:	00c6a023          	sw	a2,0(a3)

	return 0;
50000f78:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000f7c:	00008067          	ret
			     u32_t *value)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
50000f80:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>
		*value = !!(gpio->padout & BIT(pin));
	else
		*value = !!(gpio->padin & BIT(pin));

	return 0;
}
50000f84:	00008067          	ret

50000f88 <gpio_ppu_manage_callback>:

static int gpio_ppu_manage_callback(struct device *dev,
					struct gpio_callback *callback,
					bool set)
{
	struct gpio_ppu_data *data = DEV_GPIO_DATA(dev);
50000f88:	00852503          	lw	a0,8(a0)
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
50000f8c:	00052783          	lw	a5,0(a0)
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
50000f90:	00000713          	li	a4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
50000f94:	02060463          	beqz	a2,50000fbc <gpio_ppu_manage_callback+0x34>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
50000f98:	00f5a023          	sw	a5,0(a1)
	list->head = node;

	if (!list->tail) {
50000f9c:	00452783          	lw	a5,4(a0)
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
	list->head = node;
50000fa0:	00b52023          	sw	a1,0(a0)

	if (!list->tail) {
50000fa4:	04079663          	bnez	a5,50000ff0 <gpio_ppu_manage_callback+0x68>
		list->tail = list->head;
50000fa8:	00b52223          	sw	a1,4(a0)
50000fac:	0440006f          	j	50000ff0 <gpio_ppu_manage_callback+0x68>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
50000fb0:	00f58a63          	beq	a1,a5,50000fc4 <gpio_ppu_manage_callback+0x3c>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
50000fb4:	00078713          	mv	a4,a5
50000fb8:	0007a783          	lw	a5,0(a5)
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
50000fbc:	fe079ae3          	bnez	a5,50000fb0 <gpio_ppu_manage_callback+0x28>
50000fc0:	0300006f          	j	50000ff0 <gpio_ppu_manage_callback+0x68>
50000fc4:	00452683          	lw	a3,4(a0)
50000fc8:	0005a783          	lw	a5,0(a1)
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
50000fcc:	00071a63          	bnez	a4,50000fe0 <gpio_ppu_manage_callback+0x58>
		list->head = node->next;
50000fd0:	00f52023          	sw	a5,0(a0)

		/* Was node also the tail? */
		if (list->tail == node) {
50000fd4:	00d59c63          	bne	a1,a3,50000fec <gpio_ppu_manage_callback+0x64>
			list->tail = list->head;
50000fd8:	00f52223          	sw	a5,4(a0)
50000fdc:	0100006f          	j	50000fec <gpio_ppu_manage_callback+0x64>
		}
	} else {
		prev_node->next = node->next;
50000fe0:	00f72023          	sw	a5,0(a4)

		/* Was node the tail? */
		if (list->tail == node) {
50000fe4:	00d59463          	bne	a1,a3,50000fec <gpio_ppu_manage_callback+0x64>
			list->tail = prev_node;
50000fe8:	00e52223          	sw	a4,4(a0)
		}
	}

	node->next = NULL;
50000fec:	0005a023          	sw	zero,0(a1)

	_gpio_manage_callback(&data->cb, callback, set);

	return 0;
}
50000ff0:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50000ff4:	00008067          	ret

50000ff8 <gpio_ppu_enable_callback>:

static int gpio_ppu_enable_callback(struct device *dev,
					int access_op,
					u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
50000ff8:	00052783          	lw	a5,0(a0)
50000ffc:	0087a783          	lw	a5,8(a5)
50001000:	0007a683          	lw	a3,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001004:	02059063          	bnez	a1,50001024 <gpio_ppu_enable_callback+0x2c>
		return -ENOTSUP;

	/* Enable interrupt for pin */
	gpio->inten |= BIT(pin);
50001008:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
5000100c:	00c6a783          	lw	a5,12(a3)
50001010:	00c71633          	sll	a2,a4,a2
50001014:	00f66633          	or	a2,a2,a5
50001018:	00c6a623          	sw	a2,12(a3)

	return 0;
5000101c:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001020:	00008067          	ret
					u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
50001024:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>

	/* Enable interrupt for pin */
	gpio->inten |= BIT(pin);

	return 0;
}
50001028:	00008067          	ret

5000102c <gpio_ppu_disable_callback>:

static int gpio_ppu_disable_callback(struct device *dev,
					 int access_op,
					 u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);
5000102c:	00052783          	lw	a5,0(a0)
50001030:	0087a783          	lw	a5,8(a5)
50001034:	0007a683          	lw	a3,0(a5)

	if (access_op != GPIO_ACCESS_BY_PIN)
50001038:	02059263          	bnez	a1,5000105c <gpio_ppu_disable_callback+0x30>
		return -ENOTSUP;

	/* Disable interrupt for pin */
	gpio->inten &= ~BIT(pin);
5000103c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001040:	00c79633          	sll	a2,a5,a2
50001044:	00c6a703          	lw	a4,12(a3)
50001048:	fff64613          	not	a2,a2
5000104c:	00e67633          	and	a2,a2,a4
50001050:	00c6a623          	sw	a2,12(a3)

	return 0;
50001054:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001058:	00008067          	ret
					 u32_t pin)
{
	volatile struct gpio_ppu_t *gpio = DEV_GPIO(dev);

	if (access_op != GPIO_ACCESS_BY_PIN)
		return -ENOTSUP;
5000105c:	fdd00513          	li	a0,-35 # ffffffdd <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffde>

	/* Disable interrupt for pin */
	gpio->inten &= ~BIT(pin);

	return 0;
}
50001060:	00008067          	ret

50001064 <gpio_ppu_init>:
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);
50001064:	00052783          	lw	a5,0(a0)
 * @param dev GPIO device struct
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
50001068:	ff010113          	addi	sp,sp,-16
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);

	cfg->gpio_cfg_func();
5000106c:	0087a783          	lw	a5,8(a5)
 * @param dev GPIO device struct
 *
 * @return 0
 */
static int gpio_ppu_init(struct device *dev)
{
50001070:	00112623          	sw	ra,12(sp)
	const struct gpio_ppu_config *cfg = DEV_GPIO_CFG(dev);

	cfg->gpio_cfg_func();
50001074:	0047a783          	lw	a5,4(a5)
50001078:	000780e7          	jalr	a5

	return 0;
}
5000107c:	00c12083          	lw	ra,12(sp)
50001080:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001084:	01010113          	addi	sp,sp,16
50001088:	00008067          	ret

5000108c <gpio_ppu_cfg_0>:
	IRQ_CONNECT(PPU_GPIO_0_IRQ,
		    0,
		    gpio_ppu_irq_handler,
		    DEVICE_GET(gpio_ppu_0),
		    0);
	irq_enable(PPU_GPIO_0_IRQ);
5000108c:	01900513          	li	a0,25 # 19 <__NANO_ESF_t3_OFFSET+0x1>
50001090:	7d40006f          	j	50001864 <_arch_irq_enable>

50001094 <_nop_char_out>:
 * @return a function pointer or NULL if no hook is set
 */
void *__printk_get_hook(void)
{
	return _char_out;
}
50001094:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001098:	00008067          	ret

5000109c <char_out>:
5000109c:	0005a783          	lw	a5,0(a1)
500010a0:	00178793          	addi	a5,a5,1
500010a4:	00f5a023          	sw	a5,0(a1)
500010a8:	510017b7          	lui	a5,0x51001
500010ac:	9547a303          	lw	t1,-1708(a5) # 51000954 <_char_out>
500010b0:	00030067          	jr	t1

500010b4 <_printk_dec_ulong>:
500010b4:	fc010113          	addi	sp,sp,-64
500010b8:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500010bc:	03212823          	sw	s2,48(sp)
500010c0:	03512223          	sw	s5,36(sp)
500010c4:	03612023          	sw	s6,32(sp)
500010c8:	01712e23          	sw	s7,28(sp)
500010cc:	01812c23          	sw	s8,24(sp)
500010d0:	02112e23          	sw	ra,60(sp)
500010d4:	02812c23          	sw	s0,56(sp)
500010d8:	02912a23          	sw	s1,52(sp)
500010dc:	03312623          	sw	s3,44(sp)
500010e0:	03412423          	sw	s4,40(sp)
500010e4:	01912a23          	sw	s9,20(sp)
500010e8:	01a12823          	sw	s10,16(sp)
500010ec:	01b12623          	sw	s11,12(sp)
500010f0:	00050a93          	mv	s5,a0
500010f4:	00058b13          	mv	s6,a1
500010f8:	00068b93          	mv	s7,a3
500010fc:	04f76933          	p.max	s2,a4,a5
50001100:	03000c13          	li	s8,48 # 30 <__NANO_ESF_a2_OFFSET>
50001104:	00f68463          	beq	a3,a5,5000110c <_printk_dec_ulong+0x58>
50001108:	02000c13          	li	s8,32 # 20 <CONFIG_NUM_IRQS>
5000110c:	00a00a13          	li	s4,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50001110:	3b9ad4b7          	lui	s1,0x3b9ad
50001114:	00060413          	mv	s0,a2
50001118:	00100993          	li	s3,1 # 1 <CONFIG_ARCH>
5000111c:	00000d93          	li	s11,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001120:	9ff48493          	addi	s1,s1,-1537 # 3b9ac9ff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x389fd97f>
50001124:	00200d13          	li	s10,2 # 2 <CONFIG_ARCH+0x1>
50001128:	000a0c93          	mv	s9,s4
5000112c:	000d9463          	bnez	s11,50001134 <_printk_dec_ulong+0x80>
50001130:	0284f263          	bleu	s0,s1,50001154 <_printk_dec_ulong+0xa0>
50001134:	00148513          	addi	a0,s1,1
50001138:	02a45533          	divu	a0,s0,a0
5000113c:	000b0593          	mv	a1,s6
50001140:	00198993          	addi	s3,s3,1
50001144:	00100d93          	li	s11,1 # 1 <CONFIG_ARCH>
50001148:	03050513          	addi	a0,a0,48
5000114c:	000a80e7          	jalr	s5
50001150:	01c0006f          	j	5000116c <_printk_dec_ulong+0xb8>
50001154:	01494c63          	blt	s2,s4,5000116c <_printk_dec_ulong+0xb8>
50001158:	017d6a63          	bltu	s10,s7,5000116c <_printk_dec_ulong+0xb8>
5000115c:	000b0593          	mv	a1,s6
50001160:	000c0513          	mv	a0,s8
50001164:	000a80e7          	jalr	s5
50001168:	00198993          	addi	s3,s3,1
5000116c:	00148793          	addi	a5,s1,1
50001170:	02f45733          	divu	a4,s0,a5
50001174:	fffa0a13          	addi	s4,s4,-1
50001178:	42f71433          	p.msu	s0,a4,a5
5000117c:	0394d4b3          	divu	s1,s1,s9
50001180:	fa1a36e3          	p.bneimm	s4,1,5000112c <_printk_dec_ulong+0x78>
50001184:	03040513          	addi	a0,s0,48
50001188:	000b0593          	mv	a1,s6
5000118c:	000a80e7          	jalr	s5
50001190:	41390433          	sub	s0,s2,s3
50001194:	003bbe63          	p.bneimm	s7,3,500011b0 <_printk_dec_ulong+0xfc>
50001198:	00805c63          	blez	s0,500011b0 <_printk_dec_ulong+0xfc>
5000119c:	000b0593          	mv	a1,s6
500011a0:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
500011a4:	000a80e7          	jalr	s5
500011a8:	fff40413          	addi	s0,s0,-1
500011ac:	fedff06f          	j	50001198 <_printk_dec_ulong+0xe4>
500011b0:	03c12083          	lw	ra,60(sp)
500011b4:	03812403          	lw	s0,56(sp)
500011b8:	03412483          	lw	s1,52(sp)
500011bc:	03012903          	lw	s2,48(sp)
500011c0:	02c12983          	lw	s3,44(sp)
500011c4:	02812a03          	lw	s4,40(sp)
500011c8:	02412a83          	lw	s5,36(sp)
500011cc:	02012b03          	lw	s6,32(sp)
500011d0:	01c12b83          	lw	s7,28(sp)
500011d4:	01812c03          	lw	s8,24(sp)
500011d8:	01412c83          	lw	s9,20(sp)
500011dc:	01012d03          	lw	s10,16(sp)
500011e0:	00c12d83          	lw	s11,12(sp)
500011e4:	04010113          	addi	sp,sp,64
500011e8:	00008067          	ret

500011ec <__printk_hook_install>:
500011ec:	510017b7          	lui	a5,0x51001
500011f0:	94a7aa23          	sw	a0,-1708(a5) # 51000954 <_char_out>
500011f4:	00008067          	ret

500011f8 <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
500011f8:	fb010113          	addi	sp,sp,-80
500011fc:	04812423          	sw	s0,72(sp)
50001200:	04912223          	sw	s1,68(sp)
50001204:	05212023          	sw	s2,64(sp)
50001208:	03312e23          	sw	s3,60(sp)
5000120c:	03412c23          	sw	s4,56(sp)
50001210:	03512a23          	sw	s5,52(sp)
50001214:	03612823          	sw	s6,48(sp)
50001218:	03812423          	sw	s8,40(sp)
5000121c:	03912223          	sw	s9,36(sp)
50001220:	04112623          	sw	ra,76(sp)
50001224:	03712623          	sw	s7,44(sp)
50001228:	03a12023          	sw	s10,32(sp)
5000122c:	01b12e23          	sw	s11,28(sp)
50001230:	00050413          	mv	s0,a0
50001234:	00058493          	mv	s1,a1
50001238:	00068c13          	mv	s8,a3
5000123c:	00060a93          	mv	s5,a2
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
	int min_width = -1;
	int long_ctr = 0;
50001240:	00000a13          	li	s4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
	int min_width = -1;
50001244:	fff00993          	li	s3,-1
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	enum pad_type padding = PAD_NONE;
50001248:	00000913          	li	s2,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
5000124c:	00000c93          	li	s9,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d;
				if (long_ctr < 2) {
50001250:	00100b13          	li	s6,1 # 1 <CONFIG_ARCH>
	int min_width = -1;
	int long_ctr = 0;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
50001254:	001ac50b          	p.lbu	a0,1(s5!)
50001258:	2e050a63          	beqz	a0,5000154c <_vprintk+0x354>
		if (!might_format) {
5000125c:	000c9c63          	bnez	s9,50001274 <_vprintk+0x7c>
			if (*fmt != '%') {
50001260:	02500793          	li	a5,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
50001264:	2cf50463          	beq	a0,a5,5000152c <_vprintk+0x334>
				out((int)*fmt, ctx);
50001268:	00048593          	mv	a1,s1
5000126c:	000400e7          	jalr	s0
50001270:	fe5ff06f          	j	50001254 <_vprintk+0x5c>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001274:	06400713          	li	a4,100 # 64 <CONFIG_SYS_CLOCK_TICKS_PER_SEC>
50001278:	0ee50a63          	beq	a0,a4,5000136c <_vprintk+0x174>
5000127c:	04a76e63          	bltu	a4,a0,500012d8 <_vprintk+0xe0>
50001280:	03900793          	li	a5,57 # 39 <__NANO_ESF_a4_OFFSET+0x1>
50001284:	02a7e663          	bltu	a5,a0,500012b0 <_vprintk+0xb8>
50001288:	03100793          	li	a5,49 # 31 <__NANO_ESF_a2_OFFSET+0x1>
5000128c:	0af57c63          	bleu	a5,a0,50001344 <_vprintk+0x14c>
50001290:	02d00793          	li	a5,45 # 2d <__NANO_ESF_a1_OFFSET+0x1>
50001294:	08f50e63          	beq	a0,a5,50001330 <_vprintk+0x138>
50001298:	03000793          	li	a5,48 # 30 <__NANO_ESF_a2_OFFSET>
5000129c:	08f50e63          	beq	a0,a5,50001338 <_vprintk+0x140>
500012a0:	02500793          	li	a5,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
500012a4:	26f51463          	bne	a0,a5,5000150c <_vprintk+0x314>

				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
500012a8:	00048593          	mv	a1,s1
500012ac:	2740006f          	j	50001520 <_vprintk+0x328>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
500012b0:	05800793          	li	a5,88 # 58 <__NANO_ESF_lpcount0_OFFSET>
500012b4:	14f50c63          	beq	a0,a5,5000140c <_vprintk+0x214>
500012b8:	06300793          	li	a5,99 # 63 <__NANO_ESF_lpend1_OFFSET+0x3>
500012bc:	24f51863          	bne	a0,a5,5000150c <_vprintk+0x314>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
500012c0:	000c2503          	lw	a0,0(s8)
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
500012c4:	004c0b93          	addi	s7,s8,4

				out(c, ctx);
500012c8:	00048593          	mv	a1,s1
500012cc:	000400e7          	jalr	s0
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
500012d0:	000b8c13          	mv	s8,s7
500012d4:	2500006f          	j	50001524 <_vprintk+0x32c>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
500012d8:	07000793          	li	a5,112 # 70 <_K_THREAD_NO_FLOAT_SIZEOF>
500012dc:	10f50863          	beq	a0,a5,500013ec <_vprintk+0x1f4>
500012e0:	00a7ee63          	bltu	a5,a0,500012fc <_vprintk+0x104>
500012e4:	06900793          	li	a5,105 # 69 <___thread_t_arch_OFFSET+0x1>
500012e8:	08f50263          	beq	a0,a5,5000136c <_vprintk+0x174>
500012ec:	06c00793          	li	a5,108 # 6c <K_THREAD_SIZEOF>
500012f0:	06f50a63          	beq	a0,a5,50001364 <_vprintk+0x16c>
500012f4:	06800793          	li	a5,104 # 68 <___thread_t_arch_OFFSET>
500012f8:	0300006f          	j	50001328 <_vprintk+0x130>
500012fc:	07500713          	li	a4,117 # 75 <_K_THREAD_NO_FLOAT_SIZEOF+0x5>
50001300:	0ae50a63          	beq	a0,a4,500013b4 <_vprintk+0x1bc>
50001304:	00a76c63          	bltu	a4,a0,5000131c <_vprintk+0x124>
50001308:	07300793          	li	a5,115 # 73 <_K_THREAD_NO_FLOAT_SIZEOF+0x3>
5000130c:	20f51063          	bne	a0,a5,5000150c <_vprintk+0x314>
				_printk_hex_ulong(out, ctx, x, padding,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
50001310:	004c0c93          	addi	s9,s8,4
50001314:	000c2b83          	lw	s7,0(s8)

				while (*s)
50001318:	1d80006f          	j	500014f0 <_vprintk+0x2f8>
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
5000131c:	07800793          	li	a5,120 # 78 <_K_THREAD_NO_FLOAT_SIZEOF+0x8>
50001320:	0ef50663          	beq	a0,a5,5000140c <_vprintk+0x214>
50001324:	07a00793          	li	a5,122 # 7a <_K_THREAD_NO_FLOAT_SIZEOF+0xa>
50001328:	20f50863          	beq	a0,a5,50001538 <_vprintk+0x340>
5000132c:	1e00006f          	j	5000150c <_vprintk+0x314>
			case '-':
				padding = PAD_SPACE_AFTER;
50001330:	00300913          	li	s2,3 # 3 <CONFIG_ARCH+0x2>
50001334:	2040006f          	j	50001538 <_vprintk+0x340>
				goto still_might_format;
			case '0':
				if (min_width < 0 && padding == PAD_NONE) {
50001338:	0009d863          	bgez	s3,50001348 <_vprintk+0x150>
5000133c:	20090263          	beqz	s2,50001540 <_vprintk+0x348>
50001340:	0100006f          	j	50001350 <_vprintk+0x158>
					padding = PAD_ZERO_BEFORE;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
50001344:	0009c663          	bltz	s3,50001350 <_vprintk+0x158>
					min_width = *fmt - '0';
				} else {
					min_width = 10 * min_width + *fmt - '0';
50001348:	00a00793          	li	a5,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
5000134c:	42f98533          	p.mac	a0,s3,a5
50001350:	fd050993          	addi	s3,a0,-48
50001354:	00100c93          	li	s9,1 # 1 <CONFIG_ARCH>
				}

				if (padding == PAD_NONE) {
50001358:	ee091ee3          	bnez	s2,50001254 <_vprintk+0x5c>
					padding = PAD_SPACE_BEFORE;
5000135c:	00200913          	li	s2,2 # 2 <CONFIG_ARCH+0x1>
50001360:	ef5ff06f          	j	50001254 <_vprintk+0x5c>
				}
				goto still_might_format;
			case 'l':
				long_ctr++;
50001364:	001a0a13          	addi	s4,s4,1
50001368:	1d00006f          	j	50001538 <_vprintk+0x340>
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d;
				if (long_ctr < 2) {
5000136c:	014b4863          	blt	s6,s4,5000137c <_vprintk+0x184>
					d = va_arg(ap, long);
50001370:	000c2b83          	lw	s7,0(s8)
50001374:	004c0c13          	addi	s8,s8,4
50001378:	0140006f          	j	5000138c <_vprintk+0x194>
				} else {
					d = (long)va_arg(ap, long long);
5000137c:	007c0793          	addi	a5,s8,7
50001380:	c407b7b3          	p.bclr	a5,a5,2,0
50001384:	0007ab83          	lw	s7,0(a5)
50001388:	00878c13          	addi	s8,a5,8
				}

				if (d < 0) {
5000138c:	000bdc63          	bgez	s7,500013a4 <_vprintk+0x1ac>
					out((int)'-', ctx);
50001390:	00048593          	mv	a1,s1
50001394:	02d00513          	li	a0,45 # 2d <__NANO_ESF_a1_OFFSET+0x1>
50001398:	000400e7          	jalr	s0
					d = -d;
5000139c:	41700bb3          	neg	s7,s7
					min_width--;
500013a0:	fff98993          	addi	s3,s3,-1
				}
				_printk_dec_ulong(out, ctx, d, padding,
500013a4:	00098713          	mv	a4,s3
500013a8:	00090693          	mv	a3,s2
500013ac:	000b8613          	mv	a2,s7
500013b0:	02c0006f          	j	500013dc <_vprintk+0x1e4>
				break;
			}
			case 'u': {
				unsigned long u;

				if (long_ctr < 2) {
500013b4:	014b4863          	blt	s6,s4,500013c4 <_vprintk+0x1cc>
					u = va_arg(ap, unsigned long);
500013b8:	000c2603          	lw	a2,0(s8)
500013bc:	004c0c13          	addi	s8,s8,4
500013c0:	0140006f          	j	500013d4 <_vprintk+0x1dc>
				} else {
					u = (unsigned long)va_arg(ap,
500013c4:	007c0793          	addi	a5,s8,7
500013c8:	c407b7b3          	p.bclr	a5,a5,2,0
500013cc:	0007a603          	lw	a2,0(a5)
500013d0:	00878c13          	addi	s8,a5,8
							unsigned long long);
				}
				_printk_dec_ulong(out, ctx, u, padding,
500013d4:	00098713          	mv	a4,s3
500013d8:	00090693          	mv	a3,s2
500013dc:	00048593          	mv	a1,s1
500013e0:	00040513          	mv	a0,s0
500013e4:	cd1ff0ef          	jal	500010b4 <_printk_dec_ulong>
500013e8:	13c0006f          	j	50001524 <_vprintk+0x32c>
						  min_width);
				break;
			}
			case 'p':
				  out('0', ctx);
500013ec:	00048593          	mv	a1,s1
500013f0:	03000513          	li	a0,48 # 30 <__NANO_ESF_a2_OFFSET>
500013f4:	000400e7          	jalr	s0
				  out('x', ctx);
500013f8:	00048593          	mv	a1,s1
500013fc:	07800513          	li	a0,120 # 78 <_K_THREAD_NO_FLOAT_SIZEOF+0x8>
50001400:	000400e7          	jalr	s0
				  /* left-pad pointers with zeros */
				  padding = PAD_ZERO_BEFORE;
				  min_width = 8;
50001404:	00800993          	li	s3,8 # 8 <__NANO_ESF_tp_OFFSET>
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  padding = PAD_ZERO_BEFORE;
50001408:	00100913          	li	s2,1 # 1 <CONFIG_ARCH>
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x;

				if (long_ctr < 2) {
5000140c:	014b4a63          	blt	s6,s4,50001420 <_vprintk+0x228>
					x = va_arg(ap, unsigned long);
50001410:	000c2703          	lw	a4,0(s8)
50001414:	004c0c13          	addi	s8,s8,4
50001418:	00e12423          	sw	a4,8(sp)
5000141c:	0180006f          	j	50001434 <_vprintk+0x23c>
				} else {
					x = (unsigned long)va_arg(ap,
50001420:	007c0793          	addi	a5,s8,7
50001424:	c407b7b3          	p.bclr	a5,a5,2,0
50001428:	00878c13          	addi	s8,a5,8
5000142c:	0007a783          	lw	a5,0(a5)
50001430:	00f12423          	sw	a5,8(sp)
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
50001434:	00800d13          	li	s10,8 # 8 <__NANO_ESF_tp_OFFSET>
	int digits = 0;
50001438:	00000b93          	li	s7,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
5000143c:	00000d93          	li	s11,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
	int size = sizeof(num) * 2;
50001440:	000d0c93          	mv	s9,s10
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
	int digits = 0;

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
50001444:	fffc8c93          	addi	s9,s9,-1
50001448:	002c9513          	slli	a0,s9,0x2
5000144c:	00812783          	lw	a5,8(sp)
50001450:	00a7d533          	srl	a0,a5,a0
50001454:	f6453533          	p.bclr	a0,a0,27,4

		if (nibble || found_largest_digit || size == 1) {
50001458:	00051863          	bnez	a0,50001468 <_vprintk+0x270>
5000145c:	000d9c63          	bnez	s11,50001474 <_vprintk+0x27c>
50001460:	020c9a63          	bnez	s9,50001494 <_vprintk+0x29c>
50001464:	0100006f          	j	50001474 <_vprintk+0x27c>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
50001468:	00900713          	li	a4,9 # 9 <___thread_base_t_thread_state_OFFSET>
5000146c:	05700793          	li	a5,87 # 57 <__NANO_ESF_lpend0_OFFSET+0x3>
50001470:	00a76463          	bltu	a4,a0,50001478 <_vprintk+0x280>
50001474:	03000793          	li	a5,48 # 30 <__NANO_ESF_a2_OFFSET>
			out((int)nibble, ctx);
50001478:	00048593          	mv	a1,s1
5000147c:	00f50533          	add	a0,a0,a5
50001480:	000400e7          	jalr	s0
			digits++;
50001484:	001b8b93          	addi	s7,s7,1
50001488:	01a12623          	sw	s10,12(sp)

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
5000148c:	00100d93          	li	s11,1 # 1 <CONFIG_ARCH>
50001490:	0300006f          	j	500014c0 <_vprintk+0x2c8>
			out((int)nibble, ctx);
			digits++;
			continue;
		}

		if (remaining-- <= min_width) {
50001494:	fffd0793          	addi	a5,s10,-1
50001498:	00f12623          	sw	a5,12(sp)
5000149c:	03a9c263          	blt	s3,s10,500014c0 <_vprintk+0x2c8>
			if (padding == PAD_ZERO_BEFORE) {
500014a0:	00193863          	p.bneimm	s2,1,500014b0 <_vprintk+0x2b8>
				out('0', ctx);
500014a4:	00048593          	mv	a1,s1
500014a8:	03000513          	li	a0,48 # 30 <__NANO_ESF_a2_OFFSET>
500014ac:	0100006f          	j	500014bc <_vprintk+0x2c4>
			} else if (padding == PAD_SPACE_BEFORE) {
500014b0:	00293863          	p.bneimm	s2,2,500014c0 <_vprintk+0x2c8>
				out(' ', ctx);
500014b4:	00048593          	mv	a1,s1
500014b8:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
500014bc:	000400e7          	jalr	s0
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
	int digits = 0;

	for (; size; size--) {
500014c0:	000c8663          	beqz	s9,500014cc <_vprintk+0x2d4>
500014c4:	00c12d03          	lw	s10,12(sp)
500014c8:	f7dff06f          	j	50001444 <_vprintk+0x24c>
				out(' ', ctx);
			}
		}
	}

	if (padding == PAD_SPACE_AFTER) {
500014cc:	d83934e3          	p.bneimm	s2,3,50001254 <_vprintk+0x5c>
500014d0:	00199793          	slli	a5,s3,0x1
500014d4:	41778bb3          	sub	s7,a5,s7
		remaining = min_width * 2 - digits;
		while (remaining-- > 0) {
500014d8:	05705663          	blez	s7,50001524 <_vprintk+0x32c>
			out(' ', ctx);
500014dc:	00048593          	mv	a1,s1
500014e0:	02000513          	li	a0,32 # 20 <CONFIG_NUM_IRQS>
500014e4:	000400e7          	jalr	s0
500014e8:	fffb8b93          	addi	s7,s7,-1
500014ec:	fedff06f          	j	500014d8 <_vprintk+0x2e0>
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
500014f0:	001bc50b          	p.lbu	a0,1(s7!)
500014f4:	00050863          	beqz	a0,50001504 <_vprintk+0x30c>
					out((int)(*s++), ctx);
500014f8:	00048593          	mv	a1,s1
500014fc:	000400e7          	jalr	s0
50001500:	ff1ff06f          	j	500014f0 <_vprintk+0x2f8>
				_printk_hex_ulong(out, ctx, x, padding,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
50001504:	000c8c13          	mv	s8,s9
50001508:	01c0006f          	j	50001524 <_vprintk+0x32c>
			case '%': {
				out((int)'%', ctx);
				break;
			}
			default:
				out((int)'%', ctx);
5000150c:	00048593          	mv	a1,s1
50001510:	02500513          	li	a0,37 # 25 <__NANO_ESF_t6_OFFSET+0x1>
50001514:	000400e7          	jalr	s0
				out((int)*fmt, ctx);
50001518:	fffac503          	lbu	a0,-1(s5)
5000151c:	00048593          	mv	a1,s1
50001520:	000400e7          	jalr	s0
				break;
			}
			might_format = 0;
50001524:	00000c93          	li	s9,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
50001528:	d2dff06f          	j	50001254 <_vprintk+0x5c>
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
				padding = PAD_NONE;
				long_ctr = 0;
5000152c:	00000a13          	li	s4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
50001530:	fff00993          	li	s3,-1
				padding = PAD_NONE;
50001534:	00000913          	li	s2,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
				long_ctr = 0;
			}
		} else {
			switch (*fmt) {
50001538:	00100c93          	li	s9,1 # 1 <CONFIG_ARCH>
5000153c:	d19ff06f          	j	50001254 <_vprintk+0x5c>
			case '-':
				padding = PAD_SPACE_AFTER;
				goto still_might_format;
			case '0':
				if (min_width < 0 && padding == PAD_NONE) {
					padding = PAD_ZERO_BEFORE;
50001540:	00100913          	li	s2,1 # 1 <CONFIG_ARCH>
50001544:	00090c93          	mv	s9,s2
50001548:	d0dff06f          	j	50001254 <_vprintk+0x5c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
5000154c:	04c12083          	lw	ra,76(sp)
50001550:	04812403          	lw	s0,72(sp)
50001554:	04412483          	lw	s1,68(sp)
50001558:	04012903          	lw	s2,64(sp)
5000155c:	03c12983          	lw	s3,60(sp)
50001560:	03812a03          	lw	s4,56(sp)
50001564:	03412a83          	lw	s5,52(sp)
50001568:	03012b03          	lw	s6,48(sp)
5000156c:	02c12b83          	lw	s7,44(sp)
50001570:	02812c03          	lw	s8,40(sp)
50001574:	02412c83          	lw	s9,36(sp)
50001578:	02012d03          	lw	s10,32(sp)
5000157c:	01c12d83          	lw	s11,28(sp)
50001580:	05010113          	addi	sp,sp,80
50001584:	00008067          	ret

50001588 <vprintk>:
	ctx->count++;
	return _char_out(c);
}

int vprintk(const char *fmt, va_list ap)
{
50001588:	fe010113          	addi	sp,sp,-32
	struct out_context ctx = { 0 };

	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
5000158c:	00050613          	mv	a2,a0
50001590:	50001537          	lui	a0,0x50001
50001594:	00058693          	mv	a3,a1
50001598:	09c50513          	addi	a0,a0,156 # 5000109c <char_out>
5000159c:	00c10593          	addi	a1,sp,12
	ctx->count++;
	return _char_out(c);
}

int vprintk(const char *fmt, va_list ap)
{
500015a0:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
500015a4:	00012623          	sw	zero,12(sp)

	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
500015a8:	c51ff0ef          	jal	500011f8 <_vprintk>
	return ctx.count;
}
500015ac:	01c12083          	lw	ra,28(sp)
500015b0:	00c12503          	lw	a0,12(sp)
500015b4:	02010113          	addi	sp,sp,32
500015b8:	00008067          	ret

500015bc <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
500015bc:	fc010113          	addi	sp,sp,-64
500015c0:	02b12223          	sw	a1,36(sp)
	int ret;
	va_list ap;

	va_start(ap, fmt);
500015c4:	02410593          	addi	a1,sp,36
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
500015c8:	00112e23          	sw	ra,28(sp)
500015cc:	02c12423          	sw	a2,40(sp)
500015d0:	02d12623          	sw	a3,44(sp)
500015d4:	02e12823          	sw	a4,48(sp)
500015d8:	02f12a23          	sw	a5,52(sp)
500015dc:	03012c23          	sw	a6,56(sp)
500015e0:	03112e23          	sw	a7,60(sp)
	int ret;
	va_list ap;

	va_start(ap, fmt);
500015e4:	00b12623          	sw	a1,12(sp)
	ret = vprintk(fmt, ap);
500015e8:	fa1ff0ef          	jal	50001588 <vprintk>
	va_end(ap);

	return ret;
}
500015ec:	01c12083          	lw	ra,28(sp)
500015f0:	04010113          	addi	sp,sp,64
500015f4:	00008067          	ret

500015f8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_GEN_SW_ISR_TABLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_CROSS_COMPILE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
500015f8:	00008067          	ret

500015fc <test_cb>:

void ztest_test_pass(void)
{
	test_result = 0;
	k_sem_give(&test_end_signal);
	k_thread_abort(k_current_get());
500015fc:	fe010113          	addi	sp,sp,-32
50001600:	00812c23          	sw	s0,24(sp)
50001604:	51001437          	lui	s0,0x51001
50001608:	95840413          	addi	s0,s0,-1704 # 51000958 <phase>
5000160c:	01212823          	sw	s2,16(sp)
50001610:	51001937          	lui	s2,0x51001
50001614:	00112e23          	sw	ra,28(sp)
50001618:	00852783          	lw	a5,8(a0)
5000161c:	00912a23          	sw	s1,20(sp)
50001620:	01312623          	sw	s3,12(sp)
50001624:	00050493          	mv	s1,a0
50001628:	98090913          	addi	s2,s2,-1664 # 51000980 <test_result>
5000162c:	00100993          	li	s3,1 # 1 <CONFIG_ARCH>
50001630:	00042023          	sw	zero,0(s0)
50001634:	01392023          	sw	s3,0(s2)
50001638:	000780e7          	jalr	a5
5000163c:	01342023          	sw	s3,0(s0)
50001640:	0044a783          	lw	a5,4(s1)
50001644:	000780e7          	jalr	a5
50001648:	00200793          	li	a5,2 # 2 <CONFIG_ARCH+0x1>
5000164c:	00f42023          	sw	a5,0(s0)
50001650:	00c4a483          	lw	s1,12(s1)
50001654:	000480e7          	jalr	s1
50001658:	00300793          	li	a5,3 # 3 <CONFIG_ARCH+0x2>
5000165c:	51001537          	lui	a0,0x51001
50001660:	00f42023          	sw	a5,0(s0)
50001664:	00092023          	sw	zero,0(s2)
50001668:	01c12083          	lw	ra,28(sp)
5000166c:	01812403          	lw	s0,24(sp)
50001670:	01412483          	lw	s1,20(sp)
50001674:	01012903          	lw	s2,16(sp)
50001678:	00c12983          	lw	s3,12(sp)
5000167c:	a3450513          	addi	a0,a0,-1484 # 51000a34 <test_end_signal>
50001680:	02010113          	addi	sp,sp,32
50001684:	5550006f          	j	500023d8 <k_sem_give>

50001688 <ztest_test_fail>:
50001688:	51001537          	lui	a0,0x51001
5000168c:	ff010113          	addi	sp,sp,-16
50001690:	fff00713          	li	a4,-1
50001694:	510017b7          	lui	a5,0x51001
50001698:	a3450513          	addi	a0,a0,-1484 # 51000a34 <test_end_signal>
5000169c:	00112623          	sw	ra,12(sp)
500016a0:	98e7a023          	sw	a4,-1664(a5) # 51000980 <test_result>
500016a4:	535000ef          	jal	500023d8 <k_sem_give>
500016a8:	3c5000ef          	jal	5000226c <k_current_get>
500016ac:	00c12083          	lw	ra,12(sp)
500016b0:	01010113          	addi	sp,sp,16
500016b4:	4d00106f          	j	50002b84 <k_thread_abort>

500016b8 <_ztest_run_test_suite>:
}

#endif /* !KERNEL */

void _ztest_run_test_suite(const char *name, struct unit_test *suite)
{
500016b8:	fb010113          	addi	sp,sp,-80
500016bc:	04812423          	sw	s0,72(sp)
	int fail = 0;

	if (test_status < 0) {
500016c0:	51001437          	lui	s0,0x51001
500016c4:	98442783          	lw	a5,-1660(s0) # 51000984 <test_status>
}

#endif /* !KERNEL */

void _ztest_run_test_suite(const char *name, struct unit_test *suite)
{
500016c8:	04112623          	sw	ra,76(sp)
500016cc:	04912223          	sw	s1,68(sp)
500016d0:	05212023          	sw	s2,64(sp)
500016d4:	03312e23          	sw	s3,60(sp)
500016d8:	03412c23          	sw	s4,56(sp)
500016dc:	03512a23          	sw	s5,52(sp)
500016e0:	03612823          	sw	s6,48(sp)
500016e4:	03712623          	sw	s7,44(sp)
500016e8:	03812423          	sw	s8,40(sp)
500016ec:	03912223          	sw	s9,36(sp)
500016f0:	03a12023          	sw	s10,32(sp)
500016f4:	01b12e23          	sw	s11,28(sp)
	int fail = 0;

	if (test_status < 0) {
500016f8:	1207c663          	bltz	a5,50001824 <_ztest_run_test_suite+0x16c>
	k_thread_abort(k_current_get());
}

static void init_testing(void)
{
	k_sem_init(&test_end_signal, 0, 1);
500016fc:	51001937          	lui	s2,0x51001
50001700:	00050493          	mv	s1,a0
50001704:	00058a13          	mv	s4,a1
50001708:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
5000170c:	00000593          	li	a1,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001710:	a3490513          	addi	a0,s2,-1484 # 51000a34 <test_end_signal>
50001714:	4b1000ef          	jal	500023c4 <k_sem_init>
		return;
	}

	init_testing();

	PRINT("Running test suite %s\n", name);
50001718:	51000537          	lui	a0,0x51000
5000171c:	00048593          	mv	a1,s1
50001720:	44050513          	addi	a0,a0,1088 # 51000440 <gpio_ppu_driver+0x2c>
50001724:	98440413          	addi	s0,s0,-1660
50001728:	e95ff0ef          	jal	500015bc <printk>
5000172c:	004a0993          	addi	s3,s4,4

#endif /* !KERNEL */

void _ztest_run_test_suite(const char *name, struct unit_test *suite)
{
	int fail = 0;
50001730:	00000493          	li	s1,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
static int run_test(struct unit_test *test)
{
	int ret = TC_PASS;

	TC_START(test->name);
	k_thread_create(&ztest_thread, thread_stack,
50001734:	50001ab7          	lui	s5,0x50001
50001738:	51001b37          	lui	s6,0x51001
5000173c:	51001bb7          	lui	s7,0x51001
	 * test case has not finished running yet (it has given the semaphore,
	 * but has _not_ gone back to _thread_entry() and completed it's "abort
	 * phase": this will corrupt the kernel ready queue.
	 */
	k_sem_take(&test_end_signal, K_FOREVER);
	if (test_result) {
50001740:	51001c37          	lui	s8,0x51001

	if (!test_result || !FAIL_FAST) {
		ret |= cleanup_test(test);
	}

	_TC_END_RESULT(ret, test->name);
50001744:	51000cb7          	lui	s9,0x51000
50001748:	51000d37          	lui	s10,0x51000
	}

	init_testing();

	PRINT("Running test suite %s\n", name);
	while (suite->test) {
5000174c:	0009a783          	lw	a5,0(s3)
50001750:	51000537          	lui	a0,0x51000
50001754:	08078663          	beqz	a5,500017e0 <_ztest_run_test_suite+0x128>

static int run_test(struct unit_test *test)
{
	int ret = TC_PASS;

	TC_START(test->name);
50001758:	510007b7          	lui	a5,0x51000
5000175c:	000a2583          	lw	a1,0(s4)
50001760:	45878513          	addi	a0,a5,1112 # 51000458 <gpio_ppu_driver+0x44>
50001764:	e59ff0ef          	jal	500015bc <printk>
	k_thread_create(&ztest_thread, thread_stack,
50001768:	fff00893          	li	a7,-1
5000176c:	00000813          	li	a6,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001770:	000a0713          	mv	a4,s4
50001774:	5fca8693          	addi	a3,s5,1532 # 500015fc <test_cb>
50001778:	40000613          	li	a2,1024 # 400 <CONFIG_MAIN_STACK_SIZE>
5000177c:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001780:	c50b0593          	addi	a1,s6,-944 # 51000c50 <__bss_end>
50001784:	00012223          	sw	zero,4(sp)
50001788:	00012023          	sw	zero,0(sp)
5000178c:	9c8b8513          	addi	a0,s7,-1592 # 510009c8 <ztest_thread>
50001790:	214010ef          	jal	500029a4 <k_thread_create>
	 * thread_stack will be reused for that new test case while the current
	 * test case has not finished running yet (it has given the semaphore,
	 * but has _not_ gone back to _thread_entry() and completed it's "abort
	 * phase": this will corrupt the kernel ready queue.
	 */
	k_sem_take(&test_end_signal, K_FOREVER);
50001794:	510017b7          	lui	a5,0x51001
50001798:	fff00593          	li	a1,-1
5000179c:	a3478513          	addi	a0,a5,-1484 # 51000a34 <test_end_signal>
500017a0:	4fd000ef          	jal	5000249c <k_sem_take>
	if (test_result) {
500017a4:	980c2903          	lw	s2,-1664(s8) # 51000980 <test_result>

	if (!test_result || !FAIL_FAST) {
		ret |= cleanup_test(test);
	}

	_TC_END_RESULT(ret, test->name);
500017a8:	510007b7          	lui	a5,0x51000
500017ac:	46c78513          	addi	a0,a5,1132 # 5100046c <gpio_ppu_driver+0x58>
500017b0:	e0dff0ef          	jal	500015bc <printk>
	k_sem_give(&test_end_signal);
}

static int run_test(struct unit_test *test)
{
	int ret = TC_PASS;
500017b4:	01203db3          	snez	s11,s2

	if (!test_result || !FAIL_FAST) {
		ret |= cleanup_test(test);
	}

	_TC_END_RESULT(ret, test->name);
500017b8:	438c8593          	addi	a1,s9,1080 # 51000438 <gpio_ppu_driver+0x24>
500017bc:	00091463          	bnez	s2,500017c4 <_ztest_run_test_suite+0x10c>
500017c0:	430d0593          	addi	a1,s10,1072 # 51000430 <gpio_ppu_driver+0x1c>
500017c4:	010a260b          	p.lw	a2,16(s4!)
500017c8:	51000537          	lui	a0,0x51000
500017cc:	4b450513          	addi	a0,a0,1204 # 510004b4 <gpio_ppu_driver+0xa0>
500017d0:	dedff0ef          	jal	500015bc <printk>

	init_testing();

	PRINT("Running test suite %s\n", name);
	while (suite->test) {
		fail += run_test(suite);
500017d4:	01b484b3          	add	s1,s1,s11
500017d8:	01098993          	addi	s3,s3,16
500017dc:	f71ff06f          	j	5000174c <_ztest_run_test_suite+0x94>
500017e0:	51000937          	lui	s2,0x51000
		if (fail && FAIL_FAST) {
			break;
		}
	}
	if (fail) {
		TC_END_REPORT(TC_FAIL);
500017e4:	46c50513          	addi	a0,a0,1132

		if (fail && FAIL_FAST) {
			break;
		}
	}
	if (fail) {
500017e8:	00048a63          	beqz	s1,500017fc <_ztest_run_test_suite+0x144>
		TC_END_REPORT(TC_FAIL);
500017ec:	dd1ff0ef          	jal	500015bc <printk>
500017f0:	510005b7          	lui	a1,0x51000
500017f4:	4c058593          	addi	a1,a1,1216 # 510004c0 <gpio_ppu_driver+0xac>
500017f8:	0100006f          	j	50001808 <_ztest_run_test_suite+0x150>
	} else {
		TC_END_REPORT(TC_PASS);
500017fc:	dc1ff0ef          	jal	500015bc <printk>
50001800:	510005b7          	lui	a1,0x51000
50001804:	4e058593          	addi	a1,a1,1248 # 510004e0 <gpio_ppu_driver+0xcc>
50001808:	4c890513          	addi	a0,s2,1224 # 510004c8 <gpio_ppu_driver+0xb4>
5000180c:	db1ff0ef          	jal	500015bc <printk>
	}
	test_status = (test_status || fail) ? 1 : 0;
50001810:	00042703          	lw	a4,0(s0)
50001814:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001818:	00071463          	bnez	a4,50001820 <_ztest_run_test_suite+0x168>
5000181c:	009037b3          	snez	a5,s1
50001820:	00f42023          	sw	a5,0(s0)
}
50001824:	04c12083          	lw	ra,76(sp)
50001828:	04812403          	lw	s0,72(sp)
5000182c:	04412483          	lw	s1,68(sp)
50001830:	04012903          	lw	s2,64(sp)
50001834:	03c12983          	lw	s3,60(sp)
50001838:	03812a03          	lw	s4,56(sp)
5000183c:	03412a83          	lw	s5,52(sp)
50001840:	03012b03          	lw	s6,48(sp)
50001844:	02c12b83          	lw	s7,44(sp)
50001848:	02812c03          	lw	s8,40(sp)
5000184c:	02412c83          	lw	s9,36(sp)
50001850:	02012d03          	lw	s10,32(sp)
50001854:	01c12d83          	lw	s11,28(sp)
50001858:	05010113          	addi	sp,sp,80
5000185c:	00008067          	ret

50001860 <main>:
}
#else
void main(void)
{
	_init_mock();
	test_main();
50001860:	b29fe06f          	j	50000388 <test_main>

50001864 <_arch_irq_enable>:
};

int _arch_irq_is_enabled(unsigned int irq)
{
	return !!(PPU_IER & (1 << irq));
}
50001864:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50001868:	300736f3          	csrrc	a3,mstatus,a4
5000186c:	1a1047b7          	lui	a5,0x1a104
50001870:	0007a603          	lw	a2,0(a5) # 1a104000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f80>
50001874:	00a71533          	sll	a0,a4,a0
50001878:	00a66733          	or	a4,a2,a0
5000187c:	00e7a82b          	p.sw	a4,16(a5!)
50001880:	0007a703          	lw	a4,0(a5)
50001884:	00e56533          	or	a0,a0,a4
50001888:	00a7a023          	sw	a0,0(a5)
5000188c:	fc16b7b3          	p.bclr	a5,a3,30,1
50001890:	3007a7f3          	csrrs	a5,mstatus,a5
50001894:	00008067          	ret

50001898 <soc_interrupt_init>:
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50001898:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
5000189c:	3007b7f3          	csrrc	a5,mstatus,a5
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();
	PPU_IER = 0;
500018a0:	1a1047b7          	lui	a5,0x1a104
500018a4:	0007a82b          	p.sw	zero,16(a5!) # 1a104010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154f90>
	PPU_EER = 0;
500018a8:	0007a023          	sw	zero,0(a5)
500018ac:	00008067          	ret

500018b0 <k_cpu_idle>:
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500018b0:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500018b4:	3007a773          	csrrs	a4,mstatus,a5
#endif
	/* unlock interrupts */
	irq_unlock(key);

	/* Put CPU core to sleep via SCR register */
	PPU_SCR = 0x01;
500018b8:	1a104737          	lui	a4,0x1a104
500018bc:	02f72023          	sw	a5,32(a4) # 1a104020 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17154fa0>

	/* Wait for interrupt */
	SOC_WFI;
500018c0:	10200073          	wfi
500018c4:	00008067          	ret
500018c8:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
500018cc:	3007a7f3          	csrrs	a5,mstatus,a5
500018d0:	00008067          	ret

500018d4 <__start>:
500018d4:	01000117          	auipc	sp,0x1000
500018d8:	d7c10113          	addi	sp,sp,-644 # 51001650 <_interrupt_stack>
500018dc:	000012b7          	lui	t0,0x1
500018e0:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
500018e4:	00510133          	add	sp,sp,t0
500018e8:	220000ef          	jal	50001b08 <_PrepC>

500018ec <_SysFatalErrorHandler>:
 *
 * @return N/A
 */
FUNC_NORETURN __weak void _SysFatalErrorHandler(unsigned int reason,
						const NANO_ESF *esf)
{
500018ec:	ff010113          	addi	sp,sp,-16
500018f0:	00112623          	sw	ra,12(sp)
500018f4:	00812423          	sw	s0,8(sp)
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
500018f8:	06652063          	p.beqimm	a0,6,50001958 <_SysFatalErrorHandler+0x6c>
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
500018fc:	02c010ef          	jal	50002928 <k_is_in_isr>
50001900:	00050c63          	beqz	a0,50001918 <_SysFatalErrorHandler+0x2c>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
50001904:	024010ef          	jal	50002928 <k_is_in_isr>
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
50001908:	02051e63          	bnez	a0,50001944 <_SysFatalErrorHandler+0x58>
5000190c:	510005b7          	lui	a1,0x51000
50001910:	57458593          	addi	a1,a1,1396 # 51000574 <_default_esf+0x6c>
50001914:	0380006f          	j	5000194c <_SysFatalErrorHandler+0x60>
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
50001918:	020010ef          	jal	50002938 <_is_thread_essential>
5000191c:	fe0514e3          	bnez	a0,50001904 <_SysFatalErrorHandler+0x18>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
		goto hang_system;
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
50001920:	51001437          	lui	s0,0x51001
50001924:	b1c40413          	addi	s0,s0,-1252 # 51000b1c <_kernel>
50001928:	51000537          	lui	a0,0x51000
5000192c:	00842583          	lw	a1,8(s0)
50001930:	5a850513          	addi	a0,a0,1448 # 510005a8 <_default_esf+0xa0>
50001934:	c89ff0ef          	jal	500015bc <printk>
	k_thread_abort(_current);
50001938:	00842503          	lw	a0,8(s0)
5000193c:	248010ef          	jal	50002b84 <k_thread_abort>
50001940:	0180006f          	j	50001958 <_SysFatalErrorHandler+0x6c>
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
50001944:	510005b7          	lui	a1,0x51000
50001948:	57058593          	addi	a1,a1,1392 # 51000570 <_default_esf+0x68>
5000194c:	51000537          	lui	a0,0x51000
50001950:	58850513          	addi	a0,a0,1416 # 51000588 <_default_esf+0x80>
50001954:	c69ff0ef          	jal	500015bc <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
50001958:	f59ff0ef          	jal	500018b0 <k_cpu_idle>
5000195c:	ffdff06f          	j	50001958 <_SysFatalErrorHandler+0x6c>

50001960 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *esf)
{
50001960:	fb010113          	addi	sp,sp,-80
	switch (reason) {
50001964:	00600793          	li	a5,6 # 6 <__NANO_ESF_gp_OFFSET+0x2>
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *esf)
{
50001968:	04812423          	sw	s0,72(sp)
5000196c:	04912223          	sw	s1,68(sp)
50001970:	04112623          	sw	ra,76(sp)
50001974:	00050493          	mv	s1,a0
50001978:	00058413          	mv	s0,a1
	switch (reason) {
5000197c:	04a7e663          	bltu	a5,a0,500019c8 <_NanoFatalErrorHandler+0x68>
50001980:	51000737          	lui	a4,0x51000
50001984:	00251793          	slli	a5,a0,0x2
50001988:	4ec70713          	addi	a4,a4,1260 # 510004ec <gpio_ppu_driver+0xd8>
5000198c:	20f77783          	p.lw	a5,a5(a4)
50001990:	00078067          	jr	a5
	case _NANO_ERR_CPU_EXCEPTION:
	case _NANO_ERR_SPURIOUS_INT:
		break;

	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
50001994:	51000537          	lui	a0,0x51000
50001998:	5d050513          	addi	a0,a0,1488 # 510005d0 <_default_esf+0xc8>
5000199c:	00c0006f          	j	500019a8 <_NanoFatalErrorHandler+0x48>
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
500019a0:	51000537          	lui	a0,0x51000
500019a4:	5fc50513          	addi	a0,a0,1532 # 510005fc <_default_esf+0xf4>
500019a8:	c15ff0ef          	jal	500015bc <printk>
		break;
500019ac:	02c0006f          	j	500019d8 <_NanoFatalErrorHandler+0x78>

	case _NANO_ERR_KERNEL_OOPS:
		printk("***** Kernel OOPS! *****\n");
500019b0:	51000537          	lui	a0,0x51000
500019b4:	62450513          	addi	a0,a0,1572 # 51000624 <_default_esf+0x11c>
500019b8:	ff1ff06f          	j	500019a8 <_NanoFatalErrorHandler+0x48>
		break;

	case _NANO_ERR_KERNEL_PANIC:
		printk("***** Kernel Panic! *****\n");
500019bc:	51000537          	lui	a0,0x51000
500019c0:	64050513          	addi	a0,a0,1600 # 51000640 <_default_esf+0x138>
500019c4:	fe5ff06f          	j	500019a8 <_NanoFatalErrorHandler+0x48>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
500019c8:	51000537          	lui	a0,0x51000
500019cc:	00048593          	mv	a1,s1
500019d0:	65c50513          	addi	a0,a0,1628 # 5100065c <_default_esf+0x154>
500019d4:	be9ff0ef          	jal	500015bc <printk>
		break;
	}

	printk("Current thread ID = %p\n"
500019d8:	095000ef          	jal	5000226c <k_current_get>
500019dc:	deadc7b7          	lui	a5,0xdeadc
	       "  t1: 0x%x  t2: 0x%x  t3: 0x%x  t4: 0x%x\n"
	       "  t5: 0x%x  t6: 0x%x  a0: 0x%x  a1: 0x%x\n"
	       "  a2: 0x%x  a3: 0x%x  a4: 0x%x  a5: 0x%x\n"
	       "  a6: 0x%x  a7: 0x%x\n",
	       k_current_get(),
	       (esf->mepc == 0xdeadbaad) ? 0xdeadbaad : esf->mepc - 4,
500019e0:	04842603          	lw	a2,72(s0)
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
500019e4:	aad78793          	addi	a5,a5,-1363 # deadbaad <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xdeadbaae>
500019e8:	00050593          	mv	a1,a0
500019ec:	00f60463          	beq	a2,a5,500019f4 <_NanoFatalErrorHandler+0x94>
500019f0:	ffc60613          	addi	a2,a2,-4
500019f4:	04442503          	lw	a0,68(s0)
500019f8:	01042883          	lw	a7,16(s0)
500019fc:	00c42803          	lw	a6,12(s0)
50001a00:	00842783          	lw	a5,8(s0)
50001a04:	00442703          	lw	a4,4(s0)
50001a08:	00042683          	lw	a3,0(s0)
50001a0c:	02a12823          	sw	a0,48(sp)
50001a10:	04042503          	lw	a0,64(s0)
50001a14:	02a12623          	sw	a0,44(sp)
50001a18:	03c42503          	lw	a0,60(s0)
50001a1c:	02a12423          	sw	a0,40(sp)
50001a20:	03842503          	lw	a0,56(s0)
50001a24:	02a12223          	sw	a0,36(sp)
50001a28:	03442503          	lw	a0,52(s0)
50001a2c:	02a12023          	sw	a0,32(sp)
50001a30:	03042503          	lw	a0,48(s0)
50001a34:	00a12e23          	sw	a0,28(sp)
50001a38:	02c42503          	lw	a0,44(s0)
50001a3c:	00a12c23          	sw	a0,24(sp)
50001a40:	02842503          	lw	a0,40(s0)
50001a44:	00a12a23          	sw	a0,20(sp)
50001a48:	02442503          	lw	a0,36(s0)
50001a4c:	00a12823          	sw	a0,16(sp)
50001a50:	02042503          	lw	a0,32(s0)
50001a54:	00a12623          	sw	a0,12(sp)
50001a58:	01c42503          	lw	a0,28(s0)
50001a5c:	00a12423          	sw	a0,8(sp)
50001a60:	01842503          	lw	a0,24(s0)
50001a64:	00a12223          	sw	a0,4(sp)
50001a68:	01442503          	lw	a0,20(s0)
50001a6c:	00a12023          	sw	a0,0(sp)
50001a70:	51000537          	lui	a0,0x51000
50001a74:	68050513          	addi	a0,a0,1664 # 51000680 <_default_esf+0x178>
50001a78:	b45ff0ef          	jal	500015bc <printk>
	       esf->t1, esf->t2, esf->t3, esf->t4,
	       esf->t5, esf->t6, esf->a0, esf->a1,
	       esf->a2, esf->a3, esf->a4, esf->a5,
	       esf->a6, esf->a7);

	_SysFatalErrorHandler(reason, esf);
50001a7c:	00040593          	mv	a1,s0
50001a80:	00048513          	mv	a0,s1
50001a84:	e69ff0ef          	jal	500018ec <_SysFatalErrorHandler>

50001a88 <_Fault>:
}
#endif


FUNC_NORETURN void _Fault(const NANO_ESF *esf)
{
50001a88:	ff010113          	addi	sp,sp,-16
50001a8c:	00812423          	sw	s0,8(sp)
50001a90:	00112623          	sw	ra,12(sp)
50001a94:	00050413          	mv	s0,a0
	u32_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
50001a98:	34202673          	csrr	a2,mcause
50001a9c:	00500793          	li	a5,5 # 5 <__NANO_ESF_gp_OFFSET+0x1>

	mcause &= SOC_MCAUSE_EXP_MASK;
50001aa0:	f4563633          	p.bclr	a2,a2,26,5
50001aa4:	00c7ec63          	bltu	a5,a2,50001abc <_Fault+0x34>
50001aa8:	510017b7          	lui	a5,0x51001
50001aac:	00261593          	slli	a1,a2,0x2
50001ab0:	84c78793          	addi	a5,a5,-1972 # 5100084c <CSWTCH.4>
50001ab4:	20b7f583          	p.lw	a1,a1(a5)
50001ab8:	00c0006f          	j	50001ac4 <_Fault+0x3c>
50001abc:	510005b7          	lui	a1,0x51000
50001ac0:	77858593          	addi	a1,a1,1912 # 51000778 <_default_esf+0x270>

	printk("Exception cause %s (%d)\n", cause_str(mcause), (int)mcause);
50001ac4:	51000537          	lui	a0,0x51000
50001ac8:	78050513          	addi	a0,a0,1920 # 51000780 <_default_esf+0x278>
50001acc:	af1ff0ef          	jal	500015bc <printk>

	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
50001ad0:	00040593          	mv	a1,s0
50001ad4:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001ad8:	e89ff0ef          	jal	50001960 <_NanoFatalErrorHandler>

50001adc <_irq_spurious>:
#include <toolchain.h>
#include <kernel_structs.h>
#include <misc/printk.h>

void _irq_spurious(void *unused)
{
50001adc:	ff010113          	addi	sp,sp,-16
50001ae0:	00112623          	sw	ra,12(sp)
	u32_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
50001ae4:	342025f3          	csrr	a1,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
50001ae8:	51001537          	lui	a0,0x51001
50001aec:	f455b5b3          	p.bclr	a1,a1,26,5
50001af0:	82450513          	addi	a0,a0,-2012 # 51000824 <_default_esf+0x31c>
50001af4:	ac9ff0ef          	jal	500015bc <printk>
		printk("PLIC interrupt line causing the IRQ: %d\n",
		       riscv_plic_get_irq());
	}
#endif

	_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
50001af8:	510005b7          	lui	a1,0x51000
50001afc:	50858593          	addi	a1,a1,1288 # 51000508 <_default_esf>
50001b00:	00400513          	li	a0,4 # 4 <__NANO_ESF_gp_OFFSET>
50001b04:	e5dff0ef          	jal	50001960 <_NanoFatalErrorHandler>

50001b08 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
50001b08:	ff010113          	addi	sp,sp,-16
50001b0c:	00112623          	sw	ra,12(sp)
	_bss_zero();
50001b10:	1b4000ef          	jal	50001cc4 <_bss_zero>
#ifdef CONFIG_XIP
	_data_copy();
#endif
	_Cstart();
50001b14:	210000ef          	jal	50001d24 <_Cstart>

50001b18 <_thread_entry_wrapper>:
50001b18:	6350006f          	j	5000294c <_thread_entry>

50001b1c <_new_thread>:

void _new_thread(struct k_thread *thread, char *stack_memory,
		 size_t stack_size, _thread_entry_t thread_func,
		 void *arg1, void *arg2, void *arg3,
		 int priority, unsigned int options)
{
50001b1c:	fe010113          	addi	sp,sp,-32
50001b20:	00812c23          	sw	s0,24(sp)
50001b24:	01212823          	sw	s2,16(sp)
50001b28:	01612023          	sw	s6,0(sp)
50001b2c:	00058413          	mv	s0,a1
50001b30:	00060913          	mv	s2,a2
50001b34:	00068b13          	mv	s6,a3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
50001b38:	00088593          	mv	a1,a7
50001b3c:	02012683          	lw	a3,32(sp)
50001b40:	00400613          	li	a2,4 # 4 <__NANO_ESF_gp_OFFSET>
50001b44:	00112e23          	sw	ra,28(sp)
50001b48:	00912a23          	sw	s1,20(sp)
50001b4c:	01312623          	sw	s3,12(sp)
50001b50:	00050493          	mv	s1,a0
50001b54:	01412423          	sw	s4,8(sp)
50001b58:	01512223          	sw	s5,4(sp)
50001b5c:	00078a13          	mv	s4,a5
50001b60:	00070a93          	mv	s5,a4
50001b64:	00080993          	mv	s3,a6
50001b68:	7f5000ef          	jal	50002b5c <_init_thread_base>

	_new_thread_init(thread, stack_memory, stack_size, priority, options);

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
50001b6c:	f9890593          	addi	a1,s2,-104
50001b70:	00b405b3          	add	a1,s0,a1
50001b74:	c605b5b3          	p.bclr	a1,a1,3,0
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to _thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
50001b78:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
50001b7c:	0404ae23          	sw	zero,92(s1)
	thread->fn_abort = NULL;
50001b80:	0604a023          	sw	zero,96(s1)
50001b84:	04f5a623          	sw	a5,76(a1)
	stack_init->mepc = (u32_t)_thread_entry_wrapper;
50001b88:	500027b7          	lui	a5,0x50002
50001b8c:	b1878793          	addi	a5,a5,-1256 # 50001b18 <_thread_entry_wrapper>

	thread->callee_saved.sp = (u32_t)stack_init;

	thread_monitor_init(thread);
}
50001b90:	01c12083          	lw	ra,28(sp)
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
				 stack_size - sizeof(struct __esf));

	/* Setup the initial stack frame */
	stack_init->a0 = (u32_t)thread_func;
50001b94:	0365a423          	sw	s6,40(a1)
	stack_init->a1 = (u32_t)arg1;
50001b98:	0355a623          	sw	s5,44(a1)
	stack_init->a2 = (u32_t)arg2;
50001b9c:	0345a823          	sw	s4,48(a1)
	stack_init->a3 = (u32_t)arg3;
50001ba0:	0335aa23          	sw	s3,52(a1)
	 * 2) the core will jump to _thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
	stack_init->mepc = (u32_t)_thread_entry_wrapper;
50001ba4:	04f5a423          	sw	a5,72(a1)

	thread->callee_saved.sp = (u32_t)stack_init;

	thread_monitor_init(thread);
}
50001ba8:	01812403          	lw	s0,24(sp)
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
	stack_init->mepc = (u32_t)_thread_entry_wrapper;

	thread->callee_saved.sp = (u32_t)stack_init;
50001bac:	02b4a423          	sw	a1,40(s1)

	thread_monitor_init(thread);
}
50001bb0:	01012903          	lw	s2,16(sp)
50001bb4:	01412483          	lw	s1,20(sp)
50001bb8:	00c12983          	lw	s3,12(sp)
50001bbc:	00812a03          	lw	s4,8(sp)
50001bc0:	00412a83          	lw	s5,4(sp)
50001bc4:	00012b03          	lw	s6,0(sp)
50001bc8:	02010113          	addi	sp,sp,32
50001bcc:	00008067          	ret

50001bd0 <_irq_do_offload>:
 */
void _irq_do_offload(void)
{
	irq_offload_routine_t tmp;

	if (!_offload_routine)
50001bd0:	510017b7          	lui	a5,0x51001
50001bd4:	c387a703          	lw	a4,-968(a5) # 51000c38 <_offload_routine>
50001bd8:	00070c63          	beqz	a4,50001bf0 <_irq_do_offload+0x20>
		return;

	tmp = _offload_routine;
50001bdc:	c387a303          	lw	t1,-968(a5)
	_offload_routine = NULL;
50001be0:	c207ac23          	sw	zero,-968(a5)

	tmp((void *)offload_param);
50001be4:	510017b7          	lui	a5,0x51001
50001be8:	9887a503          	lw	a0,-1656(a5) # 51000988 <offload_param>
50001bec:	00030067          	jr	t1
50001bf0:	00008067          	ret

50001bf4 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
50001bf4:	ff010113          	addi	sp,sp,-16
50001bf8:	00912223          	sw	s1,4(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50001bfc:	510017b7          	lui	a5,0x51001
50001c00:	00150493          	addi	s1,a0,1
50001c04:	86478793          	addi	a5,a5,-1948 # 51000864 <config_levels>
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
50001c08:	00812423          	sw	s0,8(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50001c0c:	00249493          	slli	s1,s1,0x2
50001c10:	00251413          	slli	s0,a0,0x2
50001c14:	2087f403          	p.lw	s0,s0(a5)
50001c18:	2097f483          	p.lw	s1,s1(a5)
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
50001c1c:	00112623          	sw	ra,12(sp)
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
50001c20:	00947e63          	bleu	s1,s0,50001c3c <_sys_device_do_config_level+0x48>
								info++) {
		struct device_config *device = info->config;

		device->init(info);
50001c24:	00042783          	lw	a5,0(s0)
50001c28:	00040513          	mv	a0,s0
50001c2c:	0047a783          	lw	a5,4(a5)
50001c30:	000780e7          	jalr	a5
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
								info++) {
50001c34:	00c40413          	addi	s0,s0,12
50001c38:	fe9ff06f          	j	50001c20 <_sys_device_do_config_level+0x2c>
		struct device_config *device = info->config;

		device->init(info);
	}
}
50001c3c:	00c12083          	lw	ra,12(sp)
50001c40:	00812403          	lw	s0,8(sp)
50001c44:	00412483          	lw	s1,4(sp)
50001c48:	01010113          	addi	sp,sp,16
50001c4c:	00008067          	ret

50001c50 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
50001c50:	ff010113          	addi	sp,sp,-16
50001c54:	00812423          	sw	s0,8(sp)
50001c58:	00912223          	sw	s1,4(sp)
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
50001c5c:	51001437          	lui	s0,0x51001
50001c60:	510014b7          	lui	s1,0x51001
		device->init(info);
	}
}

struct device *device_get_binding(const char *name)
{
50001c64:	01212023          	sw	s2,0(sp)
50001c68:	00112623          	sw	ra,12(sp)
50001c6c:	00050913          	mv	s2,a0
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
50001c70:	8f040413          	addi	s0,s0,-1808 # 510008f0 <__device_PRE_KERNEL_1_start>
50001c74:	92c48493          	addi	s1,s1,-1748 # 5100092c <__device_APPLICATION_start>
50001c78:	02940863          	beq	s0,s1,50001ca8 <device_get_binding+0x58>
		if (info->driver_api && !strcmp(name, info->config->name)) {
50001c7c:	00442783          	lw	a5,4(s0)
50001c80:	00079663          	bnez	a5,50001c8c <device_get_binding+0x3c>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
50001c84:	00c40413          	addi	s0,s0,12
50001c88:	ff1ff06f          	j	50001c78 <device_get_binding+0x28>
		if (info->driver_api && !strcmp(name, info->config->name)) {
50001c8c:	00042783          	lw	a5,0(s0)
50001c90:	00090513          	mv	a0,s2
50001c94:	0007a583          	lw	a1,0(a5)
50001c98:	a3dfe0ef          	jal	500006d4 <strcmp>
50001c9c:	fe0514e3          	bnez	a0,50001c84 <device_get_binding+0x34>
50001ca0:	00040513          	mv	a0,s0
50001ca4:	0080006f          	j	50001cac <device_get_binding+0x5c>
			return info;
		}
	}

	return NULL;
50001ca8:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
}
50001cac:	00c12083          	lw	ra,12(sp)
50001cb0:	00812403          	lw	s0,8(sp)
50001cb4:	00412483          	lw	s1,4(sp)
50001cb8:	00012903          	lw	s2,0(sp)
50001cbc:	01010113          	addi	sp,sp,16
50001cc0:	00008067          	ret

50001cc4 <_bss_zero>:
	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}

void __weak main(void)
{
50001cc4:	51001537          	lui	a0,0x51001
50001cc8:	51001637          	lui	a2,0x51001
50001ccc:	97050793          	addi	a5,a0,-1680 # 51000970 <__bss_start>
50001cd0:	c5060613          	addi	a2,a2,-944 # 51000c50 <__bss_end>
50001cd4:	40f60633          	sub	a2,a2,a5
50001cd8:	00000593          	li	a1,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001cdc:	97050513          	addi	a0,a0,-1680
50001ce0:	a11fe06f          	j	500006f0 <memset>

50001ce4 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
50001ce4:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
50001ce8:	00200513          	li	a0,2 # 2 <CONFIG_ARCH+0x1>
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
50001cec:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
50001cf0:	f05ff0ef          	jal	50001bf4 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
50001cf4:	00300513          	li	a0,3 # 3 <CONFIG_ARCH+0x2>
50001cf8:	efdff0ef          	jal	50001bf4 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
50001cfc:	585000ef          	jal	50002a80 <_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
50001d00:	b61ff0ef          	jal	50001860 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
50001d04:	510017b7          	lui	a5,0x51001
50001d08:	a4478793          	addi	a5,a5,-1468 # 51000a44 <_main_thread_s>
50001d0c:	0087c703          	lbu	a4,8(a5)
50001d10:	c0073733          	p.bclr	a4,a4,0,0
50001d14:	00e78423          	sb	a4,8(a5)
}
50001d18:	00c12083          	lw	ra,12(sp)
50001d1c:	01010113          	addi	sp,sp,16
50001d20:	00008067          	ret

50001d24 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
50001d24:	f6010113          	addi	sp,sp,-160
50001d28:	08812c23          	sw	s0,152(sp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
50001d2c:	51001437          	lui	s0,0x51001
50001d30:	b1c40793          	addi	a5,s0,-1252 # 51000b1c <_kernel>
50001d34:	01410713          	addi	a4,sp,20
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
50001d38:	08112e23          	sw	ra,156(sp)
50001d3c:	08912a23          	sw	s1,148(sp)
50001d40:	09212823          	sw	s2,144(sp)
50001d44:	09312623          	sw	s3,140(sp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
50001d48:	00e7a423          	sw	a4,8(a5)

	dummy_thread->base.user_options = K_ESSENTIAL;
50001d4c:	00100793          	li	a5,1 # 1 <CONFIG_ARCH>
50001d50:	00f10e23          	sb	a5,28(sp)
	dummy_thread->base.thread_state = _THREAD_DUMMY;
50001d54:	00f10ea3          	sb	a5,29(sp)
}

static inline void _IntLibInit(void)
{
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
50001d58:	b41ff0ef          	jal	50001898 <soc_interrupt_init>
50001d5c:	510017b7          	lui	a5,0x51001
50001d60:	b3878793          	addi	a5,a5,-1224 # 51000b38 <_kernel+0x1c>
50001d64:	b1c40413          	addi	s0,s0,-1252
50001d68:	020350fb          	lp.setupi	x1,32,50001d74 <_Cstart+0x50>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
50001d6c:	00f7a023          	sw	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
50001d70:	00f7a223          	sw	a5,4(a5)
50001d74:	00878793          	addi	a5,a5,8
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
50001d78:	51001937          	lui	s2,0x51001
50001d7c:	a4490993          	addi	s3,s2,-1468 # 51000a44 <_main_thread_s>

	_new_thread(_main_thread, _main_stack,
50001d80:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
50001d84:	500026b7          	lui	a3,0x50002
50001d88:	510015b7          	lui	a1,0x51001
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
50001d8c:	01342a23          	sw	s3,20(s0)

	_new_thread(_main_thread, _main_stack,
50001d90:	00000893          	li	a7,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001d94:	00000813          	li	a6,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001d98:	00000713          	li	a4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001d9c:	ce468693          	addi	a3,a3,-796 # 50001ce4 <_main>
50001da0:	40000613          	li	a2,1024 # 400 <CONFIG_MAIN_STACK_SIZE>
50001da4:	05058593          	addi	a1,a1,80 # 51001050 <_main_stack>
50001da8:	a4490513          	addi	a0,s2,-1468
50001dac:	00912023          	sw	s1,0(sp)
50001db0:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001db4:	d69ff0ef          	jal	50001b1c <_new_thread>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
50001db8:	0099c783          	lbu	a5,9(s3)
		    MAIN_STACK_SIZE, _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
50001dbc:	a4490513          	addi	a0,s2,-1468
50001dc0:	c027b7b3          	p.bclr	a5,a5,0,2
50001dc4:	00f984a3          	sb	a5,9(s3)
50001dc8:	174000ef          	jal	50001f3c <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_thread, _idle_stack,
50001dcc:	51001937          	lui	s2,0x51001
50001dd0:	500036b7          	lui	a3,0x50003
50001dd4:	510015b7          	lui	a1,0x51001
50001dd8:	00f00893          	li	a7,15 # f <CONFIG_NUM_PREEMPT_PRIORITIES>
50001ddc:	00000813          	li	a6,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001de0:	bd868693          	addi	a3,a3,-1064 # 50002bd8 <idle>
50001de4:	20000613          	li	a2,512 # 200 <CONFIG_IDLE_STACK_SIZE>
50001de8:	45058593          	addi	a1,a1,1104 # 51001450 <_idle_stack>
50001dec:	ab090993          	addi	s3,s2,-1360 # 51000ab0 <_idle_thread_s>
50001df0:	00000713          	li	a4,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001df4:	ab090513          	addi	a0,s2,-1360
50001df8:	00912023          	sw	s1,0(sp)
50001dfc:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001e00:	d1dff0ef          	jal	50001b1c <_new_thread>
50001e04:	0099c783          	lbu	a5,9(s3)
		    IDLE_STACK_SIZE, idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
50001e08:	ab090513          	addi	a0,s2,-1360
50001e0c:	c027b7b3          	p.bclr	a5,a5,0,2
50001e10:	00f984a3          	sb	a5,9(s3)
50001e14:	128000ef          	jal	50001f3c <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
50001e18:	510017b7          	lui	a5,0x51001
50001e1c:	b2878793          	addi	a5,a5,-1240 # 51000b28 <_kernel+0xc>
50001e20:	00f42623          	sw	a5,12(s0)
	list->tail = (sys_dnode_t *)list;
50001e24:	00f42823          	sw	a5,16(s0)
void k_cpu_idle(void);
void k_cpu_atomic_idle(unsigned int key);

static ALWAYS_INLINE void kernel_arch_init(void)
{
	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
50001e28:	000017b7          	lui	a5,0x1
50001e2c:	80078713          	addi	a4,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
50001e30:	510017b7          	lui	a5,0x51001
50001e34:	65078793          	addi	a5,a5,1616 # 51001650 <_interrupt_stack>
50001e38:	00e787b3          	add	a5,a5,a4
	 */

	prepare_multithreading(dummy_thread);

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
50001e3c:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001e40:	00f42223          	sw	a5,4(s0)
50001e44:	db1ff0ef          	jal	50001bf4 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
50001e48:	00048513          	mv	a0,s1
50001e4c:	da9ff0ef          	jal	50001bf4 <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
50001e50:	510015b7          	lui	a1,0x51001
50001e54:	51001537          	lui	a0,0x51001
50001e58:	87858593          	addi	a1,a1,-1928 # 51000878 <config_levels+0x14>
50001e5c:	89450513          	addi	a0,a0,-1900 # 51000894 <config_levels+0x30>
50001e60:	f5cff0ef          	jal	500015bc <printk>
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50001e64:	3004b4f3          	csrrc	s1,mstatus,s1

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
50001e68:	46c000ef          	jal	500022d4 <_update_time_slice_before_swap>
#endif

	return __swap(key);
50001e6c:	fc14b533          	p.bclr	a0,s1,30,1
50001e70:	cf0fe0ef          	jal	50000360 <__swap>

50001e74 <_add_timeout>:
	__ASSERT(duration_in_ms >= 0, "");
	__ASSERT((prio >= 0) && (prio < CONFIG_NUM_PREEMPT_PRIORITIES), "");

	_time_slice_duration = duration_in_ms;
	_time_slice_elapsed = 0;
	_time_slice_prio_ceiling = prio;
50001e74:	51001737          	lui	a4,0x51001
50001e78:	00a5a423          	sw	a0,8(a1)
50001e7c:	b1c70793          	addi	a5,a4,-1252 # 51000b1c <_kernel>
50001e80:	00c5a623          	sw	a2,12(a1)
50001e84:	51001537          	lui	a0,0x51001
50001e88:	00c7a783          	lw	a5,12(a5)
50001e8c:	b2850513          	addi	a0,a0,-1240 # 51000b28 <_kernel+0xc>
50001e90:	00d5a823          	sw	a3,16(a1)
50001e94:	b1c70713          	addi	a4,a4,-1252
50001e98:	02a79063          	bne	a5,a0,50001eb8 <_add_timeout+0x44>
50001e9c:	00a5a023          	sw	a0,0(a1)
50001ea0:	01072783          	lw	a5,16(a4)
50001ea4:	00f5a223          	sw	a5,4(a1)
50001ea8:	01072783          	lw	a5,16(a4)
50001eac:	00b7a023          	sw	a1,0(a5)
50001eb0:	00b72823          	sw	a1,16(a4)
50001eb4:	00008067          	ret
50001eb8:	fe0782e3          	beqz	a5,50001e9c <_add_timeout+0x28>
50001ebc:	01072803          	lw	a6,16(a4)
50001ec0:	0105a683          	lw	a3,16(a1)
50001ec4:	0107a603          	lw	a2,16(a5)
50001ec8:	02d64463          	blt	a2,a3,50001ef0 <_add_timeout+0x7c>
50001ecc:	0047a703          	lw	a4,4(a5)
50001ed0:	40d606b3          	sub	a3,a2,a3
50001ed4:	00d7a823          	sw	a3,16(a5)
50001ed8:	00e5a223          	sw	a4,4(a1)
50001edc:	00f5a023          	sw	a5,0(a1)
50001ee0:	0047a703          	lw	a4,4(a5)
50001ee4:	00b72023          	sw	a1,0(a4)
50001ee8:	00b7a223          	sw	a1,4(a5)
50001eec:	00008067          	ret
50001ef0:	40c686b3          	sub	a3,a3,a2
50001ef4:	00d5a823          	sw	a3,16(a1)
50001ef8:	fb0782e3          	beq	a5,a6,50001e9c <_add_timeout+0x28>
50001efc:	0007a783          	lw	a5,0(a5)
50001f00:	fc0790e3          	bnez	a5,50001ec0 <_add_timeout+0x4c>
50001f04:	f99ff06f          	j	50001e9c <_add_timeout+0x28>

50001f08 <_get_ready_q_head>:
50001f08:	51001537          	lui	a0,0x51001
50001f0c:	b1c50713          	addi	a4,a0,-1252 # 51000b1c <_kernel>
50001f10:	01872703          	lw	a4,24(a4)
50001f14:	b1c50513          	addi	a0,a0,-1252
50001f18:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50001f1c:	00070663          	beqz	a4,50001f28 <_get_ready_q_head+0x20>
50001f20:	100707b3          	p.ff1	a5,a4
50001f24:	00178793          	addi	a5,a5,1
50001f28:	00178793          	addi	a5,a5,1
50001f2c:	00379793          	slli	a5,a5,0x3
50001f30:	00f50533          	add	a0,a0,a5
50001f34:	00c52503          	lw	a0,12(a0)
50001f38:	00008067          	ret

50001f3c <_add_thread_to_ready_q>:
50001f3c:	00a50783          	lb	a5,10(a0)
50001f40:	51001637          	lui	a2,0x51001
50001f44:	01078813          	addi	a6,a5,16
50001f48:	40585713          	srai	a4,a6,0x5
50001f4c:	00470713          	addi	a4,a4,4
50001f50:	b1c60693          	addi	a3,a2,-1252 # 51000b1c <_kernel>
50001f54:	00271713          	slli	a4,a4,0x2
50001f58:	00e68733          	add	a4,a3,a4
50001f5c:	00100593          	li	a1,1 # 1 <CONFIG_ARCH>
50001f60:	01278793          	addi	a5,a5,18
50001f64:	010595b3          	sll	a1,a1,a6
50001f68:	00379793          	slli	a5,a5,0x3
50001f6c:	00872803          	lw	a6,8(a4)
50001f70:	00f687b3          	add	a5,a3,a5
50001f74:	0105e5b3          	or	a1,a1,a6
50001f78:	00b72423          	sw	a1,8(a4)
50001f7c:	00c78713          	addi	a4,a5,12
50001f80:	00e52023          	sw	a4,0(a0)
50001f84:	0107a703          	lw	a4,16(a5)
50001f88:	00e52223          	sw	a4,4(a0)
50001f8c:	0107a703          	lw	a4,16(a5)
50001f90:	00a72023          	sw	a0,0(a4)
50001f94:	00a7a823          	sw	a0,16(a5)
50001f98:	0146a783          	lw	a5,20(a3)
50001f9c:	00a78703          	lb	a4,10(a5)
50001fa0:	00a50683          	lb	a3,10(a0)
50001fa4:	b1c60613          	addi	a2,a2,-1252
50001fa8:	00e6d463          	ble	a4,a3,50001fb0 <_add_thread_to_ready_q+0x74>
50001fac:	00050793          	mv	a5,a0
50001fb0:	00f62a23          	sw	a5,20(a2)
50001fb4:	00008067          	ret

50001fb8 <_remove_thread_from_ready_q>:
50001fb8:	ff010113          	addi	sp,sp,-16
50001fbc:	00812423          	sw	s0,8(sp)
50001fc0:	00112623          	sw	ra,12(sp)
50001fc4:	00052603          	lw	a2,0(a0)
50001fc8:	00452683          	lw	a3,4(a0)
50001fcc:	00a50783          	lb	a5,10(a0)
50001fd0:	00c6a023          	sw	a2,0(a3)
50001fd4:	00052603          	lw	a2,0(a0)
50001fd8:	51001437          	lui	s0,0x51001
50001fdc:	01278793          	addi	a5,a5,18
50001fe0:	00d62223          	sw	a3,4(a2)
50001fe4:	00379793          	slli	a5,a5,0x3
50001fe8:	b1c40693          	addi	a3,s0,-1252 # 51000b1c <_kernel>
50001fec:	00f687b3          	add	a5,a3,a5
50001ff0:	00c78693          	addi	a3,a5,12
50001ff4:	00c7a783          	lw	a5,12(a5)
50001ff8:	00050713          	mv	a4,a0
50001ffc:	b1c40413          	addi	s0,s0,-1252
50002000:	02d79a63          	bne	a5,a3,50002034 <_remove_thread_from_ready_q+0x7c>
50002004:	00a50683          	lb	a3,10(a0)
50002008:	00100613          	li	a2,1 # 1 <CONFIG_ARCH>
5000200c:	01068693          	addi	a3,a3,16
50002010:	4056d793          	srai	a5,a3,0x5
50002014:	00478793          	addi	a5,a5,4
50002018:	00279793          	slli	a5,a5,0x2
5000201c:	00f407b3          	add	a5,s0,a5
50002020:	00d616b3          	sll	a3,a2,a3
50002024:	fff6c693          	not	a3,a3
50002028:	0087a603          	lw	a2,8(a5)
5000202c:	00c6f6b3          	and	a3,a3,a2
50002030:	00d7a423          	sw	a3,8(a5)
50002034:	01442503          	lw	a0,20(s0)
50002038:	00a71463          	bne	a4,a0,50002040 <_remove_thread_from_ready_q+0x88>
5000203c:	ecdff0ef          	jal	50001f08 <_get_ready_q_head>
50002040:	00c12083          	lw	ra,12(sp)
50002044:	00a42a23          	sw	a0,20(s0)
50002048:	00812403          	lw	s0,8(sp)
5000204c:	01010113          	addi	sp,sp,16
50002050:	00008067          	ret

50002054 <_pend_thread>:
50002054:	0005a783          	lw	a5,0(a1)
50002058:	04f58063          	beq	a1,a5,50002098 <_pend_thread+0x44>
5000205c:	02078e63          	beqz	a5,50002098 <_pend_thread+0x44>
50002060:	00a50683          	lb	a3,10(a0)
50002064:	00a78703          	lb	a4,10(a5)
50002068:	02e6d063          	ble	a4,a3,50002088 <_pend_thread+0x34>
5000206c:	0047a703          	lw	a4,4(a5)
50002070:	00e52223          	sw	a4,4(a0)
50002074:	00f52023          	sw	a5,0(a0)
50002078:	0047a703          	lw	a4,4(a5)
5000207c:	00a72023          	sw	a0,0(a4)
50002080:	00a7a223          	sw	a0,4(a5)
50002084:	02c0006f          	j	500020b0 <_pend_thread+0x5c>
50002088:	0045a703          	lw	a4,4(a1)
5000208c:	00e78663          	beq	a5,a4,50002098 <_pend_thread+0x44>
50002090:	0007a783          	lw	a5,0(a5)
50002094:	fc9ff06f          	j	5000205c <_pend_thread+0x8>
50002098:	00b52023          	sw	a1,0(a0)
5000209c:	0045a783          	lw	a5,4(a1)
500020a0:	00f52223          	sw	a5,4(a0)
500020a4:	0045a783          	lw	a5,4(a1)
500020a8:	00a7a023          	sw	a0,0(a5)
500020ac:	00a5a223          	sw	a0,4(a1)
500020b0:	00954783          	lbu	a5,9(a0)
500020b4:	c017c7b3          	p.bset	a5,a5,0,1
500020b8:	00f504a3          	sb	a5,9(a0)
500020bc:	03f62063          	p.beqimm	a2,-1,500020dc <_pend_thread+0x88>
500020c0:	00960613          	addi	a2,a2,9
500020c4:	00a00693          	li	a3,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
500020c8:	02d656b3          	divu	a3,a2,a3
500020cc:	00058613          	mv	a2,a1
500020d0:	01050593          	addi	a1,a0,16
500020d4:	00168693          	addi	a3,a3,1
500020d8:	d9dff06f          	j	50001e74 <_add_timeout>
500020dc:	00008067          	ret

500020e0 <_pend_current_thread>:
500020e0:	ff010113          	addi	sp,sp,-16
500020e4:	00812423          	sw	s0,8(sp)
500020e8:	51001437          	lui	s0,0x51001
500020ec:	b1c40413          	addi	s0,s0,-1252 # 51000b1c <_kernel>
500020f0:	00912223          	sw	s1,4(sp)
500020f4:	01212023          	sw	s2,0(sp)
500020f8:	00050493          	mv	s1,a0
500020fc:	00058913          	mv	s2,a1
50002100:	00842503          	lw	a0,8(s0)
50002104:	00112623          	sw	ra,12(sp)
50002108:	eb1ff0ef          	jal	50001fb8 <_remove_thread_from_ready_q>
5000210c:	00090613          	mv	a2,s2
50002110:	00012903          	lw	s2,0(sp)
50002114:	00048593          	mv	a1,s1
50002118:	00842503          	lw	a0,8(s0)
5000211c:	00c12083          	lw	ra,12(sp)
50002120:	00812403          	lw	s0,8(sp)
50002124:	00412483          	lw	s1,4(sp)
50002128:	01010113          	addi	sp,sp,16
5000212c:	f29ff06f          	j	50002054 <_pend_thread>

50002130 <__must_switch_threads>:
50002130:	510017b7          	lui	a5,0x51001
50002134:	b1c78713          	addi	a4,a5,-1252 # 51000b1c <_kernel>
50002138:	01872703          	lw	a4,24(a4)
5000213c:	b1c78793          	addi	a5,a5,-1252
50002140:	00000693          	li	a3,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50002144:	00070663          	beqz	a4,50002150 <__must_switch_threads+0x20>
50002148:	10070733          	p.ff1	a4,a4
5000214c:	00170693          	addi	a3,a4,1
50002150:	0087a783          	lw	a5,8(a5)
50002154:	00a78503          	lb	a0,10(a5)
50002158:	fef68713          	addi	a4,a3,-17
5000215c:	00a72533          	slt	a0,a4,a0
50002160:	00008067          	ret

50002164 <_reschedule_threads>:
50002164:	510017b7          	lui	a5,0x51001
50002168:	b247a783          	lw	a5,-1244(a5) # 51000b24 <_kernel+0x8>
5000216c:	ff010113          	addi	sp,sp,-16
50002170:	00a7d703          	lhu	a4,10(a5)
50002174:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
50002178:	00812423          	sw	s0,8(sp)
5000217c:	00112623          	sw	ra,12(sp)
50002180:	00050413          	mv	s0,a0
50002184:	00e7e663          	bltu	a5,a4,50002190 <_reschedule_threads+0x2c>
50002188:	fa9ff0ef          	jal	50002130 <__must_switch_threads>
5000218c:	00051e63          	bnez	a0,500021a8 <_reschedule_threads+0x44>
50002190:	fc143433          	p.bclr	s0,s0,30,1
50002194:	30042473          	csrrs	s0,mstatus,s0
50002198:	00c12083          	lw	ra,12(sp)
5000219c:	00812403          	lw	s0,8(sp)
500021a0:	01010113          	addi	sp,sp,16
500021a4:	00008067          	ret
500021a8:	510017b7          	lui	a5,0x51001
500021ac:	00040513          	mv	a0,s0
500021b0:	00c12083          	lw	ra,12(sp)
500021b4:	00812403          	lw	s0,8(sp)
500021b8:	01010113          	addi	sp,sp,16
500021bc:	c407a223          	sw	zero,-956(a5) # 51000c44 <_time_slice_elapsed>
500021c0:	9a0fe06f          	j	50000360 <__swap>

500021c4 <k_sched_unlock>:
500021c4:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
500021c8:	30053573          	csrrc	a0,mstatus,a0
500021cc:	510017b7          	lui	a5,0x51001
500021d0:	b247a703          	lw	a4,-1244(a5) # 51000b24 <_kernel+0x8>
500021d4:	fc153533          	p.bclr	a0,a0,30,1
500021d8:	00b74783          	lbu	a5,11(a4)
500021dc:	00178793          	addi	a5,a5,1
500021e0:	00f705a3          	sb	a5,11(a4)
500021e4:	f81ff06f          	j	50002164 <_reschedule_threads>

500021e8 <_move_thread_to_end_of_prio_q>:
500021e8:	ff010113          	addi	sp,sp,-16
500021ec:	00812423          	sw	s0,8(sp)
500021f0:	00112623          	sw	ra,12(sp)
500021f4:	00a50703          	lb	a4,10(a0)
500021f8:	51001437          	lui	s0,0x51001
500021fc:	01270713          	addi	a4,a4,18
50002200:	b1c40693          	addi	a3,s0,-1252 # 51000b1c <_kernel>
50002204:	00371713          	slli	a4,a4,0x3
50002208:	00e68733          	add	a4,a3,a4
5000220c:	01072603          	lw	a2,16(a4)
50002210:	04c50663          	beq	a0,a2,5000225c <_move_thread_to_end_of_prio_q+0x74>
50002214:	00052583          	lw	a1,0(a0)
50002218:	00452603          	lw	a2,4(a0)
5000221c:	00b62023          	sw	a1,0(a2)
50002220:	00052583          	lw	a1,0(a0)
50002224:	00c70693          	addi	a3,a4,12
50002228:	00c5a223          	sw	a2,4(a1)
5000222c:	00d52023          	sw	a3,0(a0)
50002230:	01072683          	lw	a3,16(a4)
50002234:	00d52223          	sw	a3,4(a0)
50002238:	01072683          	lw	a3,16(a4)
5000223c:	00a6a023          	sw	a0,0(a3)
50002240:	b1c40413          	addi	s0,s0,-1252
50002244:	00050793          	mv	a5,a0
50002248:	00a72823          	sw	a0,16(a4)
5000224c:	01442503          	lw	a0,20(s0)
50002250:	00a79463          	bne	a5,a0,50002258 <_move_thread_to_end_of_prio_q+0x70>
50002254:	cb5ff0ef          	jal	50001f08 <_get_ready_q_head>
50002258:	00a42a23          	sw	a0,20(s0)
5000225c:	00c12083          	lw	ra,12(sp)
50002260:	00812403          	lw	s0,8(sp)
50002264:	01010113          	addi	sp,sp,16
50002268:	00008067          	ret

5000226c <k_current_get>:
5000226c:	510017b7          	lui	a5,0x51001
50002270:	b247a503          	lw	a0,-1244(a5) # 51000b24 <_kernel+0x8>
50002274:	00008067          	ret

50002278 <_is_thread_time_slicing>:
	 * Should not be the idle thread
	 * Priority should be higher than time slice priority ceiling
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
50002278:	51001737          	lui	a4,0x51001
5000227c:	99072703          	lw	a4,-1648(a4) # 51000990 <_time_slice_duration>
	_time_slice_elapsed = 0;
	_time_slice_prio_ceiling = prio;
}

int _is_thread_time_slicing(struct k_thread *thread)
{
50002280:	00050793          	mv	a5,a0
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
	    || _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
		return 0;
50002284:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
	 * Should not be the idle thread
	 * Priority should be higher than time slice priority ceiling
	 * There should be multiple threads active with same priority
	 */

	if (!(_time_slice_duration > 0) || (_is_idle_thread_ptr(thread))
50002288:	04e05463          	blez	a4,500022d0 <_is_thread_time_slicing+0x58>
5000228c:	51001737          	lui	a4,0x51001
50002290:	96072703          	lw	a4,-1696(a4) # 51000960 <_idle_thread>
50002294:	02e78e63          	beq	a5,a4,500022d0 <_is_thread_time_slicing+0x58>
	    || _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
50002298:	51001737          	lui	a4,0x51001
5000229c:	00a78783          	lb	a5,10(a5)
500022a0:	98c72703          	lw	a4,-1652(a4) # 5100098c <_time_slice_prio_ceiling>
500022a4:	02e7c663          	blt	a5,a4,500022d0 <_is_thread_time_slicing+0x58>
 * @return 1 if multiple nodes, 0 otherwise
 */

static inline int sys_dlist_has_multiple_nodes(sys_dlist_t *list)
{
	return list->head != list->tail;
500022a8:	01278513          	addi	a0,a5,18
500022ac:	510017b7          	lui	a5,0x51001
500022b0:	b1c78793          	addi	a5,a5,-1252 # 51000b1c <_kernel>
500022b4:	00351513          	slli	a0,a0,0x3
500022b8:	00a78533          	add	a0,a5,a0
500022bc:	00c52783          	lw	a5,12(a0)
500022c0:	01052503          	lw	a0,16(a0)
500022c4:	40a78533          	sub	a0,a5,a0
500022c8:	00a03533          	snez	a0,a0
	}

	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];

	return sys_dlist_has_multiple_nodes(q);
500022cc:	00008067          	ret
}
500022d0:	00008067          	ret

500022d4 <_update_time_slice_before_swap>:
	if (!remaining || (_time_slice_duration < remaining)) {
		_set_time(_time_slice_duration);
	}
#endif
	/* Restart time slice count at new thread switch */
	_time_slice_elapsed = 0;
500022d4:	510017b7          	lui	a5,0x51001
500022d8:	c407a223          	sw	zero,-956(a5) # 51000c44 <_time_slice_elapsed>
500022dc:	00008067          	ret

500022e0 <_ready_thread>:

	_abort_thread_timeout(thread);

	_ready_thread(thread);
	_set_thread_return_value(thread, 0);
}
500022e0:	00954703          	lbu	a4,9(a0)
500022e4:	c02736b3          	p.bclr	a3,a4,0,2
500022e8:	01b77713          	andi	a4,a4,27
500022ec:	00d504a3          	sb	a3,9(a0)
500022f0:	00071863          	bnez	a4,50002300 <_ready_thread+0x20>
500022f4:	02052783          	lw	a5,32(a0)
500022f8:	01f7b463          	p.bneimm	a5,-1,50002300 <_ready_thread+0x20>
500022fc:	c41ff06f          	j	50001f3c <_add_thread_to_ready_q>
50002300:	00008067          	ret

50002304 <_unpend_first_thread>:
50002304:	510017b7          	lui	a5,0x51001
50002308:	c407a783          	lw	a5,-960(a5) # 51000c40 <_handling_timeouts>
5000230c:	00052703          	lw	a4,0(a0)
50002310:	02078463          	beqz	a5,50002338 <_unpend_first_thread+0x34>
50002314:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50002318:	04e50c63          	beq	a0,a4,50002370 <_unpend_first_thread+0x6c>
5000231c:	04070863          	beqz	a4,5000236c <_unpend_first_thread+0x68>
50002320:	02072783          	lw	a5,32(a4)
50002324:	03e7b063          	p.bneimm	a5,-2,50002344 <_unpend_first_thread+0x40>
50002328:	00452783          	lw	a5,4(a0)
5000232c:	04e78063          	beq	a5,a4,5000236c <_unpend_first_thread+0x68>
50002330:	00072703          	lw	a4,0(a4)
50002334:	fe9ff06f          	j	5000231c <_unpend_first_thread+0x18>
50002338:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
5000233c:	02e50a63          	beq	a0,a4,50002370 <_unpend_first_thread+0x6c>
50002340:	02070863          	beqz	a4,50002370 <_unpend_first_thread+0x6c>
50002344:	00070793          	mv	a5,a4
50002348:	0007a683          	lw	a3,0(a5)
5000234c:	00472703          	lw	a4,4(a4)
50002350:	00d72023          	sw	a3,0(a4)
50002354:	0007a683          	lw	a3,0(a5)
50002358:	00e6a223          	sw	a4,4(a3)
5000235c:	0097c703          	lbu	a4,9(a5)
50002360:	c0173733          	p.bclr	a4,a4,0,1
50002364:	00e784a3          	sb	a4,9(a5)
50002368:	0080006f          	j	50002370 <_unpend_first_thread+0x6c>
5000236c:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50002370:	00078513          	mv	a0,a5
50002374:	00008067          	ret

50002378 <_abort_timeout>:
50002378:	00050793          	mv	a5,a0
5000237c:	01052503          	lw	a0,16(a0)
50002380:	05f52063          	p.beqimm	a0,-1,500023c0 <_abort_timeout+0x48>
50002384:	51001737          	lui	a4,0x51001
50002388:	b2c72703          	lw	a4,-1236(a4) # 51000b2c <_kernel+0x10>
5000238c:	00e78a63          	beq	a5,a4,500023a0 <_abort_timeout+0x28>
50002390:	0007a683          	lw	a3,0(a5)
50002394:	0106a703          	lw	a4,16(a3)
50002398:	00a70533          	add	a0,a4,a0
5000239c:	00a6a823          	sw	a0,16(a3)
500023a0:	0007a683          	lw	a3,0(a5)
500023a4:	0047a703          	lw	a4,4(a5)
500023a8:	00d72023          	sw	a3,0(a4)
500023ac:	0007a683          	lw	a3,0(a5)
500023b0:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500023b4:	00e6a223          	sw	a4,4(a3)
500023b8:	fff00713          	li	a4,-1
500023bc:	00e7a823          	sw	a4,16(a5)
500023c0:	00008067          	ret

500023c4 <k_sem_init>:
500023c4:	00b52423          	sw	a1,8(a0)
500023c8:	00c52623          	sw	a2,12(a0)
500023cc:	00a52023          	sw	a0,0(a0)
500023d0:	00a52223          	sw	a0,4(a0)
500023d4:	00008067          	ret

500023d8 <k_sem_give>:

void k_sem_give(struct k_sem *sem)
{
500023d8:	ff010113          	addi	sp,sp,-16
500023dc:	00812423          	sw	s0,8(sp)
500023e0:	01212023          	sw	s2,0(sp)
500023e4:	00112623          	sw	ra,12(sp)
500023e8:	00912223          	sw	s1,4(sp)
500023ec:	00050913          	mv	s2,a0
500023f0:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500023f4:	30043473          	csrrc	s0,mstatus,s0
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
500023f8:	fc143433          	p.bclr	s0,s0,30,1
}

/* returns 1 if _Swap() will need to be invoked, 0 otherwise */
static int do_sem_give(struct k_sem *sem)
{
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
500023fc:	f09ff0ef          	jal	50002304 <_unpend_first_thread>

	if (!thread) {
50002400:	02051063          	bnez	a0,50002420 <k_sem_give+0x48>
#endif
}

static inline void increment_count_up_to_limit(struct k_sem *sem)
{
	sem->count += (sem->count != sem->limit);
50002404:	00892703          	lw	a4,8(s2)
50002408:	00c92783          	lw	a5,12(s2)
5000240c:	40e787b3          	sub	a5,a5,a4
50002410:	00f037b3          	snez	a5,a5
50002414:	00e787b3          	add	a5,a5,a4
50002418:	00f92423          	sw	a5,8(s2)
5000241c:	0440006f          	j	50002460 <k_sem_give+0x88>
50002420:	00050493          	mv	s1,a0
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
50002424:	01050513          	addi	a0,a0,16
50002428:	f51ff0ef          	jal	50002378 <_abort_timeout>
	if (!thread) {
		increment_count_up_to_limit(sem);
		return handle_poll_event(sem);
	}
	(void)_abort_thread_timeout(thread);
	_ready_thread(thread);
5000242c:	00048513          	mv	a0,s1
50002430:	eb1ff0ef          	jal	500022e0 <_ready_thread>
	_set_thread_return_value(thread, 0);

	return !_is_in_isr() && _must_switch_threads();
50002434:	510017b7          	lui	a5,0x51001
50002438:	b1c7a703          	lw	a4,-1252(a5) # 51000b1c <_kernel>
}

static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
5000243c:	0604a423          	sw	zero,104(s1)
50002440:	02071063          	bnez	a4,50002460 <k_sem_give+0x88>
50002444:	b1c78793          	addi	a5,a5,-1252
50002448:	0087a783          	lw	a5,8(a5)
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
5000244c:	00a7d703          	lhu	a4,10(a5)
50002450:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
50002454:	00e7e663          	bltu	a5,a4,50002460 <k_sem_give+0x88>
50002458:	cd9ff0ef          	jal	50002130 <__must_switch_threads>
5000245c:	02051063          	bnez	a0,5000247c <k_sem_give+0xa4>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002460:	30042473          	csrrs	s0,mstatus,s0
	if (do_sem_give(sem)) {
		_Swap(key);
	} else {
		irq_unlock(key);
	}
}
50002464:	00c12083          	lw	ra,12(sp)
50002468:	00812403          	lw	s0,8(sp)
5000246c:	00412483          	lw	s1,4(sp)
50002470:	00012903          	lw	s2,0(sp)
50002474:	01010113          	addi	sp,sp,16
50002478:	00008067          	ret

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
5000247c:	e59ff0ef          	jal	500022d4 <_update_time_slice_before_swap>
50002480:	00012903          	lw	s2,0(sp)
#endif

	return __swap(key);
50002484:	00040513          	mv	a0,s0
50002488:	00c12083          	lw	ra,12(sp)
5000248c:	00812403          	lw	s0,8(sp)
50002490:	00412483          	lw	s1,4(sp)
50002494:	01010113          	addi	sp,sp,16
50002498:	ec9fd06f          	j	50000360 <__swap>

5000249c <k_sem_take>:

int k_sem_take(struct k_sem *sem, s32_t timeout)
{
5000249c:	ff010113          	addi	sp,sp,-16
500024a0:	00812423          	sw	s0,8(sp)
500024a4:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500024a8:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500024ac:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
500024b0:	00852783          	lw	a5,8(a0)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
500024b4:	fc143433          	p.bclr	s0,s0,30,1
500024b8:	00078c63          	beqz	a5,500024d0 <k_sem_take+0x34>
		sem->count--;
500024bc:	fff78793          	addi	a5,a5,-1
500024c0:	00f52423          	sw	a5,8(a0)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500024c4:	30042473          	csrrs	s0,mstatus,s0
		irq_unlock(key);
		return 0;
500024c8:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500024cc:	0300006f          	j	500024fc <k_sem_take+0x60>
	}

	if (timeout == K_NO_WAIT) {
500024d0:	00059863          	bnez	a1,500024e0 <k_sem_take+0x44>
500024d4:	30042473          	csrrs	s0,mstatus,s0
		irq_unlock(key);
		return -EBUSY;
500024d8:	ff000513          	li	a0,-16 # fffffff0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xfffffff1>
500024dc:	0200006f          	j	500024fc <k_sem_take+0x60>
	}

	_pend_current_thread(&sem->wait_q, timeout);
500024e0:	c01ff0ef          	jal	500020e0 <_pend_current_thread>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
500024e4:	df1ff0ef          	jal	500022d4 <_update_time_slice_before_swap>
#endif

	return __swap(key);
500024e8:	00040513          	mv	a0,s0

	return _Swap(key);
}
500024ec:	00c12083          	lw	ra,12(sp)
500024f0:	00812403          	lw	s0,8(sp)
500024f4:	01010113          	addi	sp,sp,16
500024f8:	e69fd06f          	j	50000360 <__swap>
500024fc:	00c12083          	lw	ra,12(sp)
50002500:	00812403          	lw	s0,8(sp)
50002504:	01010113          	addi	sp,sp,16
50002508:	00008067          	ret

5000250c <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(s32_t ticks)
{
5000250c:	fd010113          	addi	sp,sp,-48
50002510:	01612823          	sw	s6,16(sp)
50002514:	02112623          	sw	ra,44(sp)
50002518:	02812423          	sw	s0,40(sp)
5000251c:	02912223          	sw	s1,36(sp)
50002520:	03212023          	sw	s2,32(sp)
50002524:	01312e23          	sw	s3,28(sp)
50002528:	01412c23          	sw	s4,24(sp)
5000252c:	01512a23          	sw	s5,20(sp)
50002530:	00050b13          	mv	s6,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002534:	00100693          	li	a3,1 # 1 <CONFIG_ARCH>
50002538:	3006b7f3          	csrrc	a5,mstatus,a3

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
5000253c:	51001637          	lui	a2,0x51001
50002540:	c4862503          	lw	a0,-952(a2) # 51000c48 <_sys_clock_tick_count>
50002544:	c4c62583          	lw	a1,-948(a2)
50002548:	00ab0833          	add	a6,s6,a0
5000254c:	41fb5713          	srai	a4,s6,0x1f
50002550:	016838b3          	sltu	a7,a6,s6
50002554:	00b70733          	add	a4,a4,a1
50002558:	00e885b3          	add	a1,a7,a4
5000255c:	c5062423          	sw	a6,-952(a2)
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002560:	fc17b7b3          	p.bclr	a5,a5,30,1
50002564:	c4b62623          	sw	a1,-948(a2)
50002568:	3007a7f3          	csrrs	a5,mstatus,a5
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
5000256c:	00810613          	addi	a2,sp,8
50002570:	00c12423          	sw	a2,8(sp)
	list->tail = (sys_dnode_t *)list;
50002574:	00c12623          	sw	a2,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002578:	3006b773          	csrrc	a4,mstatus,a3
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
5000257c:	510014b7          	lui	s1,0x51001
50002580:	b1c48793          	addi	a5,s1,-1252 # 51000b1c <_kernel>
50002584:	510015b7          	lui	a1,0x51001
50002588:	00c7a783          	lw	a5,12(a5)
5000258c:	b2858593          	addi	a1,a1,-1240 # 51000b28 <_kernel+0xc>
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50002590:	fc173733          	p.bclr	a4,a4,30,1
50002594:	b1c48493          	addi	s1,s1,-1252
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50002598:	00b78463          	beq	a5,a1,500025a0 <_nano_sys_clock_tick_announce+0x94>
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
5000259c:	00079663          	bnez	a5,500025a8 <_nano_sys_clock_tick_announce+0x9c>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500025a0:	30072773          	csrrs	a4,mstatus,a4
500025a4:	14c0006f          	j	500026f0 <_nano_sys_clock_tick_announce+0x1e4>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
500025a8:	0107a503          	lw	a0,16(a5)
500025ac:	41650533          	sub	a0,a0,s6
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
500025b0:	510019b7          	lui	s3,0x51001
	if (!head) {
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
500025b4:	00a7a823          	sw	a0,16(a5)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
500025b8:	c4d9a023          	sw	a3,-960(s3) # 51000c40 <_handling_timeouts>
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
500025bc:	ffe00813          	li	a6,-2 # fffffffe <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xffffffff>
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
500025c0:	0107a503          	lw	a0,16(a5)
500025c4:	04051663          	bnez	a0,50002610 <_nano_sys_clock_tick_announce+0x104>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
500025c8:	0007a883          	lw	a7,0(a5)
500025cc:	0047a503          	lw	a0,4(a5)
500025d0:	01152023          	sw	a7,0(a0)
	node->next->prev = node->prev;
500025d4:	0007a883          	lw	a7,0(a5)
500025d8:	00a8a223          	sw	a0,4(a7)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
500025dc:	00812503          	lw	a0,8(sp)
500025e0:	00a7a023          	sw	a0,0(a5)
	node->prev = list;

	list->head->prev = node;
500025e4:	00812503          	lw	a0,8(sp)
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
	node->prev = list;
500025e8:	00c7a223          	sw	a2,4(a5)

	list->head->prev = node;
	list->head = node;
500025ec:	00f12423          	sw	a5,8(sp)
static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
	node->prev = list;

	list->head->prev = node;
500025f0:	00f52223          	sw	a5,4(a0)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
500025f4:	0107a823          	sw	a6,16(a5)
500025f8:	30072773          	csrrs	a4,mstatus,a4
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
500025fc:	3006b773          	csrrc	a4,mstatus,a3
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
50002600:	00c4a783          	lw	a5,12(s1)
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50002604:	fc173733          	p.bclr	a4,a4,30,1
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50002608:	00b78463          	beq	a5,a1,50002610 <_nano_sys_clock_tick_announce+0x104>
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
5000260c:	fa079ae3          	bnez	a5,500025c0 <_nano_sys_clock_tick_announce+0xb4>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002610:	30072773          	csrrs	a4,mstatus,a4
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
50002614:	00812503          	lw	a0,8(sp)
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
50002618:	00810793          	addi	a5,sp,8
5000261c:	00f51663          	bne	a0,a5,50002628 <_nano_sys_clock_tick_announce+0x11c>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
50002620:	c409a023          	sw	zero,-960(s3)
50002624:	0cc0006f          	j	500026f0 <_nano_sys_clock_tick_announce+0x1e4>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
50002628:	fe050ce3          	beqz	a0,50002620 <_nano_sys_clock_tick_announce+0x114>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
5000262c:	00c12783          	lw	a5,12(sp)
50002630:	00000413          	li	s0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50002634:	00f50463          	beq	a0,a5,5000263c <_nano_sys_clock_tick_announce+0x130>
50002638:	00052403          	lw	s0,0(a0)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
5000263c:	00100a13          	li	s4,1 # 1 <CONFIG_ARCH>
static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
50002640:	fff00a93          	li	s5,-1
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50002644:	00052703          	lw	a4,0(a0)
50002648:	00452783          	lw	a5,4(a0)
5000264c:	00e7a023          	sw	a4,0(a5)
	node->next->prev = node->prev;
50002650:	00052703          	lw	a4,0(a0)
50002654:	00f72223          	sw	a5,4(a4)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
50002658:	00852703          	lw	a4,8(a0)
5000265c:	300a3973          	csrrc	s2,mstatus,s4
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50002660:	fc193933          	p.bclr	s2,s2,30,1
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
50002664:	01552823          	sw	s5,16(a0)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
50002668:	04070a63          	beqz	a4,500026bc <_nano_sys_clock_tick_announce+0x1b0>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
5000266c:	00c52783          	lw	a5,12(a0)
50002670:	02078463          	beqz	a5,50002698 <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50002674:	00072683          	lw	a3,0(a4)
50002678:	00472783          	lw	a5,4(a4)
5000267c:	00d7a023          	sw	a3,0(a5)
	node->next->prev = node->prev;
50002680:	00072683          	lw	a3,0(a4)
50002684:	00f6a223          	sw	a5,4(a3)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
50002688:	00974783          	lbu	a5,9(a4)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
5000268c:	00072e23          	sw	zero,28(a4)
50002690:	c017b7b3          	p.bclr	a5,a5,0,1
50002694:	00f704a3          	sb	a5,9(a4)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
50002698:	00974783          	lbu	a5,9(a4)
5000269c:	c027b6b3          	p.bclr	a3,a5,0,2
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
500026a0:	01b7f793          	andi	a5,a5,27
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
500026a4:	00d704a3          	sb	a3,9(a4)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
500026a8:	00079663          	bnez	a5,500026b4 <_nano_sys_clock_tick_announce+0x1a8>
500026ac:	02072783          	lw	a5,32(a4)
500026b0:	09f7a663          	p.beqimm	a5,-1,5000273c <_nano_sys_clock_tick_announce+0x230>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
500026b4:	30092973          	csrrs	s2,mstatus,s2
500026b8:	0140006f          	j	500026cc <_nano_sys_clock_tick_announce+0x1c0>
500026bc:	30092973          	csrrs	s2,mstatus,s2
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
500026c0:	01452783          	lw	a5,20(a0)
500026c4:	00078463          	beqz	a5,500026cc <_nano_sys_clock_tick_announce+0x1c0>
			timeout->func(timeout);
500026c8:	000780e7          	jalr	a5
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
500026cc:	f4040ae3          	beqz	s0,50002620 <_nano_sys_clock_tick_announce+0x114>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
500026d0:	00c12503          	lw	a0,12(sp)
500026d4:	00000793          	li	a5,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
500026d8:	00a41863          	bne	s0,a0,500026e8 <_nano_sys_clock_tick_announce+0x1dc>
500026dc:	00040513          	mv	a0,s0
500026e0:	00078413          	mv	s0,a5
500026e4:	f61ff06f          	j	50002644 <_nano_sys_clock_tick_announce+0x138>
500026e8:	00042783          	lw	a5,0(s0)
500026ec:	ff1ff06f          	j	500026dc <_nano_sys_clock_tick_announce+0x1d0>
static void handle_time_slicing(s32_t ticks)
{
#ifdef CONFIG_TICKLESS_KERNEL
	next_ts = 0;
#endif
	if (!_is_thread_time_slicing(_current)) {
500026f0:	0084a503          	lw	a0,8(s1)
500026f4:	b85ff0ef          	jal	50002278 <_is_thread_time_slicing>
500026f8:	04050863          	beqz	a0,50002748 <_nano_sys_clock_tick_announce+0x23c>
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
500026fc:	51001737          	lui	a4,0x51001
50002700:	c4472783          	lw	a5,-956(a4) # 51000c44 <_time_slice_elapsed>
50002704:	00a00693          	li	a3,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50002708:	42db07b3          	p.mac	a5,s6,a3
	if (_time_slice_elapsed >= _time_slice_duration) {
5000270c:	510016b7          	lui	a3,0x51001
50002710:	9906a683          	lw	a3,-1648(a3) # 51000990 <_time_slice_duration>
#endif
	if (!_is_thread_time_slicing(_current)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
50002714:	c4f72223          	sw	a5,-956(a4)
	if (_time_slice_elapsed >= _time_slice_duration) {
50002718:	02d7c863          	blt	a5,a3,50002748 <_nano_sys_clock_tick_announce+0x23c>

		unsigned int key;

		_time_slice_elapsed = 0;
5000271c:	c4072223          	sw	zero,-956(a4)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002720:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50002724:	30043473          	csrrc	s0,mstatus,s0

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
50002728:	0084a503          	lw	a0,8(s1)
5000272c:	abdff0ef          	jal	500021e8 <_move_thread_to_end_of_prio_q>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002730:	fc143433          	p.bclr	s0,s0,30,1
50002734:	30042473          	csrrs	s0,mstatus,s0
	if ((!remaining && next_to) || (next_to < remaining)) {
		/* Clears current program if next_to = 0 and remaining > 0 */
		_set_time(next_to);
	}
#endif
}
50002738:	0100006f          	j	50002748 <_nano_sys_clock_tick_announce+0x23c>

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
5000273c:	00070513          	mv	a0,a4
50002740:	ffcff0ef          	jal	50001f3c <_add_thread_to_ready_q>
50002744:	f71ff06f          	j	500026b4 <_nano_sys_clock_tick_announce+0x1a8>
50002748:	02c12083          	lw	ra,44(sp)
5000274c:	02812403          	lw	s0,40(sp)
50002750:	02412483          	lw	s1,36(sp)
50002754:	02012903          	lw	s2,32(sp)
50002758:	01c12983          	lw	s3,28(sp)
5000275c:	01812a03          	lw	s4,24(sp)
50002760:	01412a83          	lw	s5,20(sp)
50002764:	01012b03          	lw	s6,16(sp)
50002768:	03010113          	addi	sp,sp,48
5000276c:	00008067          	ret

50002770 <_is_thread_ready>:
{
	unsigned int  key = irq_lock();

	_k_thread_single_resume(thread);

	_reschedule_threads(key);
50002770:	00954783          	lbu	a5,9(a0)
50002774:	f457b7b3          	p.bclr	a5,a5,26,5
50002778:	00079a63          	bnez	a5,5000278c <_is_thread_ready+0x1c>
5000277c:	02052503          	lw	a0,32(a0)
50002780:	00150513          	addi	a0,a0,1
50002784:	00153513          	seqz	a0,a0
50002788:	00008067          	ret
5000278c:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
50002790:	00008067          	ret

50002794 <start_thread>:
50002794:	ff010113          	addi	sp,sp,-16
50002798:	00812423          	sw	s0,8(sp)
5000279c:	00912223          	sw	s1,4(sp)
500027a0:	00112623          	sw	ra,12(sp)
500027a4:	00050493          	mv	s1,a0
500027a8:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
500027ac:	30043473          	csrrc	s0,mstatus,s0
500027b0:	00954783          	lbu	a5,9(a0)
500027b4:	fc143433          	p.bclr	s0,s0,30,1
500027b8:	c027b7b3          	p.bclr	a5,a5,0,2
500027bc:	00f504a3          	sb	a5,9(a0)
500027c0:	fb1ff0ef          	jal	50002770 <_is_thread_ready>
500027c4:	04050263          	beqz	a0,50002808 <start_thread+0x74>
500027c8:	00048513          	mv	a0,s1
500027cc:	f70ff0ef          	jal	50001f3c <_add_thread_to_ready_q>
500027d0:	510017b7          	lui	a5,0x51001
500027d4:	b247a783          	lw	a5,-1244(a5) # 51000b24 <_kernel+0x8>
500027d8:	00a7d703          	lhu	a4,10(a5)
500027dc:	07f00793          	li	a5,127 # 7f <_K_THREAD_NO_FLOAT_SIZEOF+0xf>
500027e0:	02e7e463          	bltu	a5,a4,50002808 <start_thread+0x74>
500027e4:	94dff0ef          	jal	50002130 <__must_switch_threads>
500027e8:	02050063          	beqz	a0,50002808 <start_thread+0x74>
500027ec:	ae9ff0ef          	jal	500022d4 <_update_time_slice_before_swap>
500027f0:	00040513          	mv	a0,s0
500027f4:	00c12083          	lw	ra,12(sp)
500027f8:	00812403          	lw	s0,8(sp)
500027fc:	00412483          	lw	s1,4(sp)
50002800:	01010113          	addi	sp,sp,16
50002804:	b5dfd06f          	j	50000360 <__swap>
50002808:	30042473          	csrrs	s0,mstatus,s0
5000280c:	00c12083          	lw	ra,12(sp)
50002810:	00812403          	lw	s0,8(sp)
50002814:	00412483          	lw	s1,4(sp)
50002818:	01010113          	addi	sp,sp,16
5000281c:	00008067          	ret

50002820 <_abort_timeout>:
50002820:	00050793          	mv	a5,a0
50002824:	01052503          	lw	a0,16(a0)
50002828:	05f52063          	p.beqimm	a0,-1,50002868 <_abort_timeout+0x48>
5000282c:	51001737          	lui	a4,0x51001
50002830:	b2c72703          	lw	a4,-1236(a4) # 51000b2c <_kernel+0x10>
50002834:	00e78a63          	beq	a5,a4,50002848 <_abort_timeout+0x28>
50002838:	0007a683          	lw	a3,0(a5)
5000283c:	0106a703          	lw	a4,16(a3)
50002840:	00a70533          	add	a0,a4,a0
50002844:	00a6a823          	sw	a0,16(a3)
50002848:	0007a683          	lw	a3,0(a5)
5000284c:	0047a703          	lw	a4,4(a5)
50002850:	00d72023          	sw	a3,0(a4)
50002854:	0007a683          	lw	a3,0(a5)
50002858:	00000513          	li	a0,0 # 0 <CONFIG_GEN_IRQ_START_VECTOR>
5000285c:	00e6a223          	sw	a4,4(a3)
50002860:	fff00713          	li	a4,-1
50002864:	00e7a823          	sw	a4,16(a5)
50002868:	00008067          	ret

5000286c <schedule_new_thread.part.14>:
5000286c:	00100713          	li	a4,1 # 1 <CONFIG_ARCH>
50002870:	30073773          	csrrc	a4,mstatus,a4
50002874:	00a00793          	li	a5,10 # a <CONFIG_NUM_MBOX_ASYNC_MSGS>
50002878:	00958593          	addi	a1,a1,9
5000287c:	02f5d5b3          	divu	a1,a1,a5
50002880:	510016b7          	lui	a3,0x51001
50002884:	b1c68793          	addi	a5,a3,-1252 # 51000b1c <_kernel>
50002888:	51001837          	lui	a6,0x51001
5000288c:	00c7a783          	lw	a5,12(a5)
50002890:	b2880813          	addi	a6,a6,-1240 # 51000b28 <_kernel+0xc>
50002894:	fc173733          	p.bclr	a4,a4,30,1
50002898:	00a52c23          	sw	a0,24(a0)
5000289c:	00052e23          	sw	zero,28(a0)
500028a0:	b1c68693          	addi	a3,a3,-1252
500028a4:	00158593          	addi	a1,a1,1
500028a8:	02b52023          	sw	a1,32(a0)
500028ac:	03079063          	bne	a5,a6,500028cc <schedule_new_thread.part.14+0x60>
500028b0:	01052823          	sw	a6,16(a0)
500028b4:	0106a603          	lw	a2,16(a3)
500028b8:	01050793          	addi	a5,a0,16
500028bc:	00c52a23          	sw	a2,20(a0)
500028c0:	00f62023          	sw	a5,0(a2)
500028c4:	00f6a823          	sw	a5,16(a3)
500028c8:	0580006f          	j	50002920 <schedule_new_thread.part.14+0xb4>
500028cc:	fe0782e3          	beqz	a5,500028b0 <schedule_new_thread.part.14+0x44>
500028d0:	0106a883          	lw	a7,16(a3)
500028d4:	02052603          	lw	a2,32(a0)
500028d8:	0107a583          	lw	a1,16(a5)
500028dc:	02c5c663          	blt	a1,a2,50002908 <schedule_new_thread.part.14+0x9c>
500028e0:	40c58633          	sub	a2,a1,a2
500028e4:	00c7a823          	sw	a2,16(a5)
500028e8:	0047a603          	lw	a2,4(a5)
500028ec:	00c52a23          	sw	a2,20(a0)
500028f0:	00f52823          	sw	a5,16(a0)
500028f4:	01050693          	addi	a3,a0,16
500028f8:	0047a603          	lw	a2,4(a5)
500028fc:	00d62023          	sw	a3,0(a2)
50002900:	00d7a223          	sw	a3,4(a5)
50002904:	01c0006f          	j	50002920 <schedule_new_thread.part.14+0xb4>
50002908:	40b60633          	sub	a2,a2,a1
5000290c:	02c52023          	sw	a2,32(a0)
50002910:	fb1780e3          	beq	a5,a7,500028b0 <schedule_new_thread.part.14+0x44>
50002914:	0007a783          	lw	a5,0(a5)
50002918:	fa079ee3          	bnez	a5,500028d4 <schedule_new_thread.part.14+0x68>
5000291c:	f95ff06f          	j	500028b0 <schedule_new_thread.part.14+0x44>
50002920:	30072773          	csrrs	a4,mstatus,a4
50002924:	00008067          	ret

50002928 <k_is_in_isr>:
50002928:	510017b7          	lui	a5,0x51001
5000292c:	b1c7a503          	lw	a0,-1252(a5) # 51000b1c <_kernel>
50002930:	00a03533          	snez	a0,a0
50002934:	00008067          	ret

50002938 <_is_thread_essential>:
50002938:	510017b7          	lui	a5,0x51001
5000293c:	b247a783          	lw	a5,-1244(a5) # 51000b24 <_kernel+0x8>
50002940:	0087c503          	lbu	a0,8(a5)
50002944:	fc153533          	p.bclr	a0,a0,30,1
50002948:	00008067          	ret

5000294c <_thread_entry>:
5000294c:	ff010113          	addi	sp,sp,-16
50002950:	00112623          	sw	ra,12(sp)
50002954:	00050793          	mv	a5,a0
50002958:	00058513          	mv	a0,a1
5000295c:	00060593          	mv	a1,a2
50002960:	00068613          	mv	a2,a3
50002964:	000780e7          	jalr	a5
50002968:	fd1ff0ef          	jal	50002938 <_is_thread_essential>
5000296c:	02050663          	beqz	a0,50002998 <_thread_entry+0x4c>
50002970:	510015b7          	lui	a1,0x51001
50002974:	51001537          	lui	a0,0x51001
50002978:	8c058593          	addi	a1,a1,-1856 # 510008c0 <config_levels+0x5c>
5000297c:	0c100613          	li	a2,193 # c1 <CONFIG_CONSOLE_INPUT_MAX_LINE_LEN+0x41>
50002980:	8e450513          	addi	a0,a0,-1820 # 510008e4 <config_levels+0x80>
50002984:	c39fe0ef          	jal	500015bc <printk>
50002988:	510005b7          	lui	a1,0x51000
5000298c:	50858593          	addi	a1,a1,1288 # 51000508 <_default_esf>
50002990:	00100513          	li	a0,1 # 1 <CONFIG_ARCH>
50002994:	fcdfe0ef          	jal	50001960 <_NanoFatalErrorHandler>
50002998:	510017b7          	lui	a5,0x51001
5000299c:	b247a503          	lw	a0,-1244(a5) # 51000b24 <_kernel+0x8>
500029a0:	1e4000ef          	jal	50002b84 <k_thread_abort>

500029a4 <k_thread_create>:
500029a4:	fe010113          	addi	sp,sp,-32
500029a8:	02012303          	lw	t1,32(sp)
500029ac:	00612023          	sw	t1,0(sp)
500029b0:	00812c23          	sw	s0,24(sp)
500029b4:	00112e23          	sw	ra,28(sp)
500029b8:	00050413          	mv	s0,a0
500029bc:	960ff0ef          	jal	50001b1c <_new_thread>
500029c0:	02412783          	lw	a5,36(sp)
500029c4:	00079863          	bnez	a5,500029d4 <k_thread_create+0x30>
500029c8:	00040513          	mv	a0,s0
500029cc:	dc9ff0ef          	jal	50002794 <start_thread>
500029d0:	0100006f          	j	500029e0 <k_thread_create+0x3c>
500029d4:	02412583          	lw	a1,36(sp)
500029d8:	00040513          	mv	a0,s0
500029dc:	e91ff0ef          	jal	5000286c <schedule_new_thread.part.14>
500029e0:	01c12083          	lw	ra,28(sp)
500029e4:	00040513          	mv	a0,s0
500029e8:	01812403          	lw	s0,24(sp)
500029ec:	02010113          	addi	sp,sp,32
500029f0:	00008067          	ret

500029f4 <_k_thread_single_abort>:
}

void _k_thread_single_abort(struct k_thread *thread)
{
500029f4:	ff010113          	addi	sp,sp,-16
	if (thread->fn_abort != NULL) {
500029f8:	06052783          	lw	a5,96(a0)

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
500029fc:	00812423          	sw	s0,8(sp)
50002a00:	00112623          	sw	ra,12(sp)
50002a04:	00050413          	mv	s0,a0
	if (thread->fn_abort != NULL) {
50002a08:	00078463          	beqz	a5,50002a10 <_k_thread_single_abort+0x1c>
		thread->fn_abort();
50002a0c:	000780e7          	jalr	a5
	}

	if (_is_thread_ready(thread)) {
50002a10:	00040513          	mv	a0,s0
50002a14:	d5dff0ef          	jal	50002770 <_is_thread_ready>
50002a18:	00050863          	beqz	a0,50002a28 <_k_thread_single_abort+0x34>
		_remove_thread_from_ready_q(thread);
50002a1c:	00040513          	mv	a0,s0
50002a20:	d98ff0ef          	jal	50001fb8 <_remove_thread_from_ready_q>
50002a24:	0400006f          	j	50002a64 <_k_thread_single_abort+0x70>
	} else {
		if (_is_thread_pending(thread)) {
50002a28:	00944783          	lbu	a5,9(s0)
50002a2c:	0027f793          	andi	a5,a5,2
50002a30:	02078263          	beqz	a5,50002a54 <_k_thread_single_abort+0x60>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
50002a34:	00042703          	lw	a4,0(s0)
50002a38:	00442783          	lw	a5,4(s0)
50002a3c:	00e7a023          	sw	a4,0(a5)
	node->next->prev = node->prev;
50002a40:	00042703          	lw	a4,0(s0)
50002a44:	00f72223          	sw	a5,4(a4)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
50002a48:	00944783          	lbu	a5,9(s0)
50002a4c:	c017b7b3          	p.bclr	a5,a5,0,1
50002a50:	00f404a3          	sb	a5,9(s0)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
50002a54:	02042783          	lw	a5,32(s0)
50002a58:	01f7a663          	p.beqimm	a5,-1,50002a64 <_k_thread_single_abort+0x70>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
50002a5c:	01040513          	addi	a0,s0,16
50002a60:	dc1ff0ef          	jal	50002820 <_abort_timeout>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
50002a64:	00944783          	lbu	a5,9(s0)
50002a68:	c037c7b3          	p.bset	a5,a5,0,3
50002a6c:	00f404a3          	sb	a5,9(s0)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
50002a70:	00c12083          	lw	ra,12(sp)
50002a74:	00812403          	lw	s0,8(sp)
50002a78:	01010113          	addi	sp,sp,16
50002a7c:	00008067          	ret

50002a80 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50002a80:	fd010113          	addi	sp,sp,-48
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50002a84:	510017b7          	lui	a5,0x51001
	_mark_thread_as_dead(thread);
}

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50002a88:	02912223          	sw	s1,36(sp)
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50002a8c:	510014b7          	lui	s1,0x51001
	_mark_thread_as_dead(thread);
}

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
50002a90:	02812423          	sw	s0,40(sp)
50002a94:	01312e23          	sw	s3,28(sp)
50002a98:	02112623          	sw	ra,44(sp)
50002a9c:	03212023          	sw	s2,32(sp)
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50002aa0:	92c78413          	addi	s0,a5,-1748 # 5100092c <__device_APPLICATION_start>
50002aa4:	92c78993          	addi	s3,a5,-1748
50002aa8:	92c48493          	addi	s1,s1,-1748 # 5100092c <__device_APPLICATION_start>
50002aac:	00048913          	mv	s2,s1
50002ab0:	04947063          	bleu	s1,s0,50002af0 <_init_static_threads+0x70>
		_new_thread(
50002ab4:	00042503          	lw	a0,0(s0)
50002ab8:	02042303          	lw	t1,32(s0)
50002abc:	01442783          	lw	a5,20(s0)
50002ac0:	01c42883          	lw	a7,28(s0)
50002ac4:	01842803          	lw	a6,24(s0)
50002ac8:	01042703          	lw	a4,16(s0)
50002acc:	00c42683          	lw	a3,12(s0)
50002ad0:	00842603          	lw	a2,8(s0)
50002ad4:	00442583          	lw	a1,4(s0)
50002ad8:	00612023          	sw	t1,0(sp)
50002adc:	840ff0ef          	jal	50001b1c <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->init_thread->init_data = thread_data;
50002ae0:	00042783          	lw	a5,0(s0)
50002ae4:	0487ae23          	sw	s0,92(a5)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
50002ae8:	03040413          	addi	s0,s0,48
50002aec:	fc1ff06f          	j	50002aac <_init_static_threads+0x2c>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
50002af0:	510017b7          	lui	a5,0x51001
50002af4:	b247a703          	lw	a4,-1244(a5) # 51000b24 <_kernel+0x8>
50002af8:	00b74783          	lbu	a5,11(a4)
50002afc:	fff78793          	addi	a5,a5,-1
50002b00:	00f705a3          	sb	a5,11(a4)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002b04:	00100493          	li	s1,1 # 1 <CONFIG_ARCH>
50002b08:	3004b4f3          	csrrc	s1,mstatus,s1
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50002b0c:	fc14b4b3          	p.bclr	s1,s1,30,1
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
50002b10:	00098413          	mv	s0,s3
50002b14:	03247463          	bleu	s2,s0,50002b3c <_init_static_threads+0xbc>
		if (thread_data->init_delay != K_FOREVER) {
50002b18:	02442583          	lw	a1,36(s0)
50002b1c:	01f5ac63          	p.beqimm	a1,-1,50002b34 <_init_static_threads+0xb4>
			schedule_new_thread(thread_data->init_thread,
50002b20:	00042503          	lw	a0,0(s0)

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
50002b24:	00059663          	bnez	a1,50002b30 <_init_static_threads+0xb0>
		start_thread(thread);
50002b28:	c6dff0ef          	jal	50002794 <start_thread>
50002b2c:	0080006f          	j	50002b34 <_init_static_threads+0xb4>
50002b30:	d3dff0ef          	jal	5000286c <schedule_new_thread.part.14>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
50002b34:	03040413          	addi	s0,s0,48
50002b38:	fddff06f          	j	50002b14 <_init_static_threads+0x94>
 */
static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
50002b3c:	3004a4f3          	csrrs	s1,mstatus,s1
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
50002b40:	02c12083          	lw	ra,44(sp)
50002b44:	02812403          	lw	s0,40(sp)
50002b48:	02412483          	lw	s1,36(sp)
50002b4c:	02012903          	lw	s2,32(sp)
50002b50:	01c12983          	lw	s3,28(sp)
50002b54:	03010113          	addi	sp,sp,48
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
50002b58:	e6cff06f          	j	500021c4 <k_sched_unlock>

50002b5c <_init_thread_base>:
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
50002b5c:	fff00793          	li	a5,-1
void _init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
50002b60:	00d50423          	sb	a3,8(a0)
	thread_base->thread_state = (u8_t)initial_state;
50002b64:	00c504a3          	sb	a2,9(a0)

	thread_base->prio = priority;
50002b68:	00b50523          	sb	a1,10(a0)

	thread_base->sched_locked = 0;
50002b6c:	000505a3          	sb	zero,11(a0)
50002b70:	02f52023          	sw	a5,32(a0)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
50002b74:	00052e23          	sw	zero,28(a0)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
50002b78:	00052c23          	sw	zero,24(a0)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
50002b7c:	02052223          	sw	zero,36(a0)
50002b80:	00008067          	ret

50002b84 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
50002b84:	ff010113          	addi	sp,sp,-16
50002b88:	00812423          	sw	s0,8(sp)
50002b8c:	00912223          	sw	s1,4(sp)
50002b90:	00112623          	sw	ra,12(sp)
50002b94:	00050493          	mv	s1,a0
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002b98:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50002b9c:	30043473          	csrrc	s0,mstatus,s0
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
50002ba0:	e55ff0ef          	jal	500029f4 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
50002ba4:	510017b7          	lui	a5,0x51001
50002ba8:	b247a783          	lw	a5,-1244(a5) # 51000b24 <_kernel+0x8>
			  : "=r" (mstatus)
			  : "r" (SOC_MSTATUS_IEN)
			  : "memory");

	key = (mstatus & SOC_MSTATUS_IEN);
50002bac:	fc143433          	p.bclr	s0,s0,30,1
50002bb0:	00f49863          	bne	s1,a5,50002bc0 <k_thread_abort+0x3c>

#ifdef CONFIG_STACK_SENTINEL
	_check_stack_sentinel();
#endif
#ifdef CONFIG_TIMESLICING
	_update_time_slice_before_swap();
50002bb4:	f20ff0ef          	jal	500022d4 <_update_time_slice_before_swap>
#endif

	return __swap(key);
50002bb8:	00040513          	mv	a0,s0
50002bbc:	fa4fd0ef          	jal	50000360 <__swap>
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
50002bc0:	00040513          	mv	a0,s0
}
50002bc4:	00c12083          	lw	ra,12(sp)
50002bc8:	00812403          	lw	s0,8(sp)
50002bcc:	00412483          	lw	s1,4(sp)
50002bd0:	01010113          	addi	sp,sp,16
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
50002bd4:	d90ff06f          	j	50002164 <_reschedule_threads>

50002bd8 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
50002bd8:	ff010113          	addi	sp,sp,-16
50002bdc:	00812423          	sw	s0,8(sp)
50002be0:	00112623          	sw	ra,12(sp)
 */
static ALWAYS_INLINE unsigned int _arch_irq_lock(void)
{
	unsigned int key, mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
50002be4:	00100413          	li	s0,1 # 1 <CONFIG_ARCH>
50002be8:	300437f3          	csrrc	a5,mstatus,s0
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
50002bec:	cc5fe0ef          	jal	500018b0 <k_cpu_idle>
50002bf0:	ff9ff06f          	j	50002be8 <idle+0x10>

50002bf4 <_OffsetAbsSyms>:
 * are aligned accordingly.
 */
GEN_ABSOLUTE_SYM(__NANO_ESF_SIZEOF, STACK_ROUND_UP(sizeof(NANO_ESF)));

/* size of the struct tcs structure sans save area for floating point regs */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
50002bf4:	00008067          	ret
